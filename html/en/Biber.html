<html>
<head><meta charset=utf-8/>
<title>Biber - main module for biber, a bibtex replacement for users of biblatex</title></head>
<body><pre>

Biber(3pm)             User Contributed Perl Documentation            Biber(3pm)



NAME
       Biber - main module for biber, a bibtex replacement for users of biblatex

SYNOPSIS
           use Biber;

           my $biber = Biber-&gt;new();
           $biber-&gt;parse_ctrlfile(&quot;example.bcf&quot;);
           $biber-&gt;prepare;

METHODS
   new
           Initialize the Biber object, optionally passing named options as arguments.

   display_problems
          Output summary of warnings/errors before exit

   biber_tempdir
           my $sections= $biber-&gt;biber_tempdir

           Returns a File::Temp directory object for use in various things

   sections
           my $sections= $biber-&gt;sections

           Returns a Biber::Sections object describing the bibliography sections

   set_output_obj
           Sets the object used to output final results
           Must be a subclass of Biber::Output::base

   get_preamble
           Returns the current preamble as an array ref

   get_output_obj
           Returns the object used to output final results

   set_current_section
           Sets the current section number that we are working on to a section number

   get_current_section
           Gets the current section number that we are working on

   parse_ctrlfile
           This method reads the control file
           generated by biblatex to work out the various biblatex options.
           See Constants.pm for defaults and example of the data structure being built here.

   process_setup
          Place to put misc pre-processing things needed later

   process_citekey_aliases
         Remove citekey aliases from citekeys as they don&apos;t point to real
         entries.

   instantiate_dynamic
           This instantiates any dynamic entries so that they are available
           for processing later on. This has to be done before most all other
           processing so that when we call $section-&gt;bibentry($key), as we
           do many times in the code, we don&apos;t die because there is a key but
           no Entry object.
&#12;   resolve_xdata
           Resolve xdata entries

   cite_setmembers
           $biber-&gt;cite_setmembers

   process_crossrefs
           $biber-&gt;process_crossrefs

           This does two things:
           1. Ensures proper inheritance of data from cross-references.
           2. Ensures that crossrefs/xrefs that are directly cited or cross-referenced
              at least mincrossrefs times are included in the bibliography.

   validate_structure
         Validate bib structure according to a bib schema
         Note that we are validating the internal Biber::Entries
         after they have been created from the datasources so this is
         datasource neutral, as it should be. It is here to enforce
         adherence to what biblatex expects.

   process_entries_pre
           Main processing operations, to generate metadata and entry information
           This method is automatically called by C&lt;prepare&gt;.
           Here we generate the &quot;namehash&quot; and the strings for
           &quot;labelname&quot;, &quot;labelyear&quot;, &quot;labelalpha&quot;, &quot;sortstrings&quot;, etc.
           Runs prior to uniqueness processing

   process_entries_post
           More processing operations, to generate things which require uniqueness
           information like namehash
           Runs after uniqueness processing

   process_singletitle
           Track seen name combination for generation of singletitle

   process_extrayear
           Track labelname/year combination for generation of extrayear

   process_sets
           Postprocess set entries

           Checks for common set errors and enforces &apos;dataonly&apos; for set members

   process_labelname
           Generate labelname information. Fields set are:

           * labelnamename - the name of the labelname field to use
           * labelnamenamefullhash - the name of the labelname field to use for
                                     fulhash generation.

           We can retreive the actual labelname value later with:

           $entry-&gt;get_field($entry-&gt;get_field(&apos;labelnamename&apos;))

           It is neat this way as we often need to know what the labelname field is
           as well as its actual string value

   process_labelyear
           Generate labelyear
           Here, &quot;labelyearname&quot; is the name of the labelyear field
           and &quot;labelyear&quot; is the actual copy of the relevant field

   process_fullhash
           Generate fullhash
&#12;   process_namehash
           Generate namehash

   process_pername_hashes
           Generate per_name_hashes

   process_visible_names
           Generate the visible name information.
           This is used in various places and it is useful to have it generated in one place.

   process_labelalpha
           Generate the labelalpha and also the variant for sorting

   process_extraalpha
           Generate the extraalpha information

   process_presort
           Put presort fields for an entry into the main Biber bltx state
           so that it is all available in the same place since this can be
           set per-type and globally too.

   process_lists
           Sort and filter lists for a section

   check_list_filter
           Run an entry through a list filter. Returns a boolean.

   generate_sortinfo
           Generate information for sorting

   uniqueness
           Generate the uniqueness information needed when creating .bbl

   create_uniquename_info
           Gather the uniquename information as we look through the names

           What is happening in here is the following:
           We are registering the number of occurences of each name, name+init and fullname
           within a specific context. For example, the context is &quot;global&quot; with uniquename &lt; 5
           and &quot;name list&quot; for uniquename=5 or 6. The keys we store to count this are the most specific
           information for the context, so, for uniquename &lt; 5, this is the full name and for
           uniquename=5 or 6, this is the complete list of full names. These keys have values in a hash
           which are ignored. They serve only to accumulate repeated occurences with the context
           and we don&apos;t care about this and so the values are a useful sinkhole for such repetition.

           For example, if we find in the global context a lastname &quot;Smith&quot; in two different entries
           under the same form &quot;Alan Smith&quot;, the data structure will look like:

           {Smith}-&gt;{global}-&gt;{Alan Smith} = 2

           We don&apos;t care about the value as this means that there are 2 &quot;Alan Smith&quot;s in the global
           context which need disambiguating identically anyway. So, we just count the keys for the
           lastname &quot;Smith&quot; in the global context to see how ambiguous the lastname itself is. This
           would be &quot;1&quot; and so &quot;Alan Smith&quot; would get uniquename=0 because it&apos;s unambiguous as just
           &quot;Smith&quot;.

           The same goes for &quot;minimal&quot; list context disambiguation for uniquename=5 or 6.
           For example, if we had the lastname &quot;Smith&quot; to disambiguate in two entries with labelname
           &quot;John Smith and Alan Jones&quot;, the data structure would look like:

           {Smith}-&gt;{Smith+Jones}-&gt;{John Smith+Alan Jones} = 2

           Again, counting the keys of the context for the lastname gives us &quot;1&quot; which means we
           have uniquename=0 for &quot;John Smith&quot; in both entries because it&apos;s the same list. This also works
           for repeated names in the same list &quot;John Smith and Bert Smith&quot;. Disambiguating &quot;Smith&quot; in this:
&#12;           {Smith}-&gt;{Smith+Smith}-&gt;{John Smith+Bert Smith} = 2

           So both &quot;John Smith&quot; and &quot;Bert Smith&quot; in this entry get uniquename=0 (of course, as long as
           there are no other &quot;X Smith and Y Smith&quot; entries where X != &quot;John&quot; or Y != &quot;Bert&quot;).

   generate_uniquename
          Generate the per-name uniquename values using the information
          harvested by create_uniquename_info()

   create_uniquelist_info
           Gather the uniquename information as we look through the names

   generate_uniquelist
          Generate the per-namelist uniquelist values using the information
          harvested by create_uniquelist_info()

   generate_extra
           Generate information for:

             * extraalpha
             * extrayear

   generate_singletitle
           Generate the singletitle field, if requested. The information for generating
           this is gathered in process_singletitle()

   sort_list
           Sort a list using information in entries according to a certain sorting scheme.
           Use a flag to skip info messages on first pass

   prepare
           Do the main work.
           Process and sort all entries before writing the bbl output.

   fetch_data
           Fetch citekey and dependents data from section datasources
           Expects to find datasource packages named:

           Biber::Input::&lt;type&gt;::&lt;datatype&gt;

           and one defined subroutine called:

           Biber::Input::&lt;type&gt;::&lt;datatype&gt;::extract_entries

           which takes args:

           1: Biber object
           2: Datasource name
           3: Reference to an array of cite keys to look for

           and returns an array of the cite keys it did not find in the datasource

   get_dependents
         Get dependents of the entries for a given list of citekeys. Is called recursively
         until there are no more dependents to look for.

   remove_undef_dependent
           Remove undefined dependent keys from an entry using a map of
           dependent keys to entries

   _parse_sort
          Convenience sub to parse a .bcf sorting section and return nice
          sorting object

   _filedump and _stringdump
           Dump the biber object with Data::Dump for debugging
&#12;AUTHORS
       Francois Charette, &quot;&lt;firmicus at ankabut.net&gt;&quot; Philip Kime &quot;&lt;philip at
       kime.org.uk&gt;&quot;

BUGS
       Please report any bugs or feature requests on our sourceforge tracker at
       &lt;https://sourceforge.net/tracker2/?func=browse&amp;group_id=228270&gt;.

COPYRIGHT &amp; LICENSE
       Copyright 2009-2012 Francois Charette and Philip Kime, all rights
       reserved.

       This module is free software.  You can redistribute it and/or modify it
       under the terms of the Artistic License 2.0.

       This program is distributed in the hope that it will be useful, but
       without any warranty; without even the implied warranty of
       merchantability or fitness for a particular purpose.



perl v5.14.2                       2012-06-17                         Biber(3pm)

</pre></body></html>
