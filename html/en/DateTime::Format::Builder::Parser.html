<html>
<head><meta charset=utf-8/>
<title>DateTime::Format::Builder::Parser - Parser creation</title></head>
<body><pre>

DateTime::Format::BuildUserPContributed PeDateTime::Format::Builder::Parser(3pm)



NAME
       DateTime::Format::Builder::Parser - Parser creation

SYNOPSIS
           my $class = &apos;DateTime::Format::Builder::Parser&apos;;
           my $parser = $class-&gt;create_single_parser( %specs );

DESCRIPTION
       This is a utility class for DateTime::Format::Builder that handles
       creation of parsers. It is to here that &quot;Builder&quot; delegates most of its
       responsibilities.

CONSTRUCTORS
METHODS
       There are two sorts of methods in this class. Those used by parser
       implementations and those used by &quot;Builder&quot;. It is generally unlikely the
       user will want to use any of them.

       They are presented, grouped according to use.

   Parameter Handling (implementations)
       These methods allow implementations to have validation of their arguments
       in a standard manner and due to &quot;Parser&quot;&apos;s impelementation, these methods
       also allow &quot;Parser&quot; to determine which implementation to use.

       Common parameters

       These parameters appear for all parser implementations.  These are
       primarily documented in the main docs.

       &#183;   on_match

       &#183;   on_fail

       &#183;   postprocess

       &#183;   preprocess

       &#183;   label

       &#183;   length may be a number or an arrayref of numbers indicating the
           length of the input. This lets us optimise in the case of static
           length input. If supplying an arrayref of numbers, please keep the
           number of numbers to a minimum.

       params

           my $params = $self-&gt;params();
           validate( @_, $params );

       Returns declared parameters and &quot;common&quot; parameters in a hashref suitable
       for handing to Params::Validate&apos;s &quot;validate&quot; function.

       params_all

           my $all_params = $self-&gt;params_all();

       Returns a hash of all the valid options. Not recommended for general use.

       valid_params

           __PACKAGE__-&gt;valid_params( %params );
&#12;       Arguments are as per Params::Validate&apos;s &quot;validate&quot; function.  This method
       is used to declare what your valid arguments are in a parser
       specification.

       whose_params

           my $class = whose_params( $key );

       Internal function which merely returns to which class a parameter is
       unique. If not unique, returns &quot;undef&quot;.

   Organising and Creating Parsers
       create_single_parser

       This takes a single specification and returns a coderef that is a parser
       that suits that specification. This is the end of the line for all the
       parser creation methods. It delegates no further.

       If a coderef is specified, then that coderef is immediately returned (it
       is assumed to be appropriate).

       The single specification (if not a coderef) can be either a hashref or a
       hash. The keys and values must be as per the specification.

       It is here that any arrays of callbacks are unified. It is also here that
       any parser implementations are used. With the spec that&apos;s given, the keys
       are looked at and whichever module is the first to have a unique key in
       the spec is the one to whom the spec is given.

       Note: please declare a &quot;valid_params&quot; argument with an uppercase letter.
       For example, if you&apos;re writing
       &quot;DateTime::Format::Builder::Parser::Fnord&quot;, declare a parameter called
       &quot;Fnord&quot;. Similarly, &quot;DTFBP::Strptime&quot; should have &quot;Strptime&quot; and
       &quot;DTFBP::Regex&quot; should have &quot;Regex&quot;. These latter two don&apos;t for backwards
       compatibility reasons.

       The returned parser will return either a &quot;DateTime&quot; object or &quot;undef&quot;.

       merge_callbacks

       Produce either undef or a single coderef from either undef, an empty
       array, a single coderef or an array of coderefs

   create_multiple_parsers
       Given the options block (as made from &quot;create_parser()&quot;) and a list of
       single parser specifications, this returns a coderef that returns either
       the resultant &quot;DateTime&quot; object or &quot;undef&quot;.

       It first sorts the specifications using &quot;sort_parsers()&quot; and then creates
       the function based on what that returned.

   sort_parsers
       This takes the list of specifications and sorts them while turning the
       specifications into parsers. It returns two values: the first is a
       hashref containing all the length based parsers. The second is an array
       containing all the other parsers.

       If any of the specs are not code or hash references, then it will call
       &quot;croak()&quot;.

       Code references are put directly into the &apos;other&apos; array. Any hash
       references without length keys are run through &quot;create_single_parser()&quot;
       and the resultant parser is placed in the &apos;other&apos; array.

       Hash references with length keys are run through
       &quot;create_single_parser()&quot;, but the resultant parser is used as the value
       in the length hashref with the length being the key. If two or more
       parsers have the same length specified then an error is thrown.

   create_parser
       &quot;create_class()&quot; is mostly a wrapper around &quot;create_parser()&quot; that does
       loops and stuff and calls &quot;create_parser()&quot; to create the actual parsers.

       &quot;create_parser()&quot; takes the parser specifications (be they single
       specifications or multiple specifications) and returns an anonymous
       coderef that is suitable for use as a method. The coderef will call
       &quot;croak()&quot; in the event of being unable to parse the single string it
       expects as input.

       The simplest input is that of a single specification, presented just as a
       plain hash, not a hashref. This is passed directly to
       &quot;create_single_parser()&quot; with the return value from that being wrapped in
       a function that lets it &quot;croak()&quot; on failure, with that wrapper being
       returned.

       If the first argument to &quot;create_parser()&quot; is an arrayref, then that is
       taken to be an options block (as per the multiple parser specification
       documented earlier).

       Any further arguments should be either hashrefs or coderefs.  If the
       first argument after the optional arrayref is not a hashref or coderef
       then that argument and all remaining arguments are passed off to
       &quot;create_single_parser()&quot; directly. If the first argument is a hashref or
       coderef, then it and the remaining arguments are passed to
       &quot;create_multiple_parsers()&quot;.

       The resultant coderef from calling either of the creation methods is then
       wrapped in a function that calls &quot;croak()&quot; in event of failure or the
       &quot;DateTime&quot; object in event of success.

FINDING IMPLEMENTATIONS
       &quot;Parser&quot; automatically loads any parser classes in @INC.

       To be loaded automatically, you must be a
       &quot;DateTime::Format::Builder::Parser::XXX&quot; module.

       To be invisible, and not loaded, start your class with a lower class
       letter. These are ignored.

WRITING A PARSER IMPLEMENTATION
   Naming your parser
       Create a module and name it in the form
       &quot;DateTime::Format::Builder::Parser::XXX&quot; where XXX is whatever you like,
       so long as it doesn&apos;t start with a lower case letter.

       Alternatively, call it something completely different if you don&apos;t mind
       the users explicitly loading your module.

       I&apos;d recommend keeping within the &quot;DateTime::Format::Builder&quot; namespace
       though --- at the time of writing I&apos;ve not given thought to what non-auto
       loaded ones should be called. Any ideas, please email me.

   Declaring specification arguments
       Call &quot;&lt;DateTime::Format::Builder::Parser-&quot;valid_params()&gt;&gt; with
       &quot;Params::Validate&quot; style arguments. For example:

          DateTime::Format::Builder::Parser-&gt;valid_params(
              params =&gt; { type =&gt; ARRAYREF },
              Regex  =&gt; { type =&gt; SCALARREF, callbacks =&gt; {
                 &apos;is a regex&apos; =&gt; sub { ref(shift) eq &apos;Regexp&apos; }
              }}
          );

       Start one of the key names with a capital letter. Ideally that key should
       match the XXX from earlier. This will be used to help identify which
       module a parser specification should be given to.

       The key names on_match, on_fail, postprocess, preprocess, label and
       length are predefined. You are recommended to make use of them. You may
       ignore length as &quot;sort_parsers&quot; takes care of that.

   Define create_parser
       A class method of the name &quot;create_parser&quot; that does the following:

       Its arguments are as for a normal method (i.e. class as first argument).
       The other arguments are the result from a call to &quot;Params::Validate&quot;
       according to your specification (the &quot;valid_params&quot; earlier), i.e. a hash
       of argument name and value.

       The return value should be a coderef that takes a date string as its
       first argument and returns either a &quot;DateTime&quot; object or &quot;undef&quot;.

   Callbacks
       It is preferred that you support some callbacks to your parsers.  In
       particular, &quot;preprocess&quot;, &quot;on_match&quot;, &quot;on_fail&quot; and &quot;postprocess&quot;. See
       the main Builder docs for the appropriate placing of calls to the
       callbacks.

SUPPORT
       Support for this module is provided via the datetime@perl.org email list.
       See http://lists.perl.org/ for more details.

       Alternatively, log them via the CPAN RT system via the web or email:

           http://perl.dellah.org/rt/dtbuilder
           bug-datetime-format-builder@rt.cpan.org

       This makes it much easier for me to track things and thus means your
       problem is less likely to be neglected.

THANKS
       See DateTime::Format::Builder.

LICENCE AND COPYRIGHT
       Copyright X Iain Truskett, 2003. All rights reserved.

       This library is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself, either Perl version 5.000 or, at
       your option, any later version of Perl 5 you may have available.

       The full text of the licences can be found in the Artistic and COPYING
       files included with this module, or in perlartistic and perlgpl as
       supplied with Perl 5.8.1 and later.

AUTHOR
       Iain Truskett &lt;spoon@cpan.org&gt;

SEE ALSO
       &quot;datetime@perl.org&quot; mailing list.

       http://datetime.perl.org/

       perl, DateTime, DateTime::Format::Builder.

       Params::Validate.

       DateTime::Format::Builder::Parser::generic,
       DateTime::Format::Builder::Parser::Dispatch,
       DateTime::Format::Builder::Parser::Quick,
       DateTime::Format::Builder::Parser::Regex,
       DateTime::Format::Builder::Parser::Strptime.



perl v5.10.1                       2010-03DateTime::Format::Builder::Parser(3pm)

</pre></body></html>
