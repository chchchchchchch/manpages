<html>
<head><meta charset=utf-8/>
<title>DateTime::Format::Builder::Tutorial - Quick class on using Builder</title></head>
<body><pre>

DateTime::Format::BuildUserTContributed)DateTime::Format::Builder::Tutorial(3pm)



NAME
       DateTime::Format::Builder::Tutorial - Quick class on using Builder

CREATING A CLASS
       As most people who are writing modules know, you start a package with a
       package declaration and some indication of module version:

           package DateTime::Format::ICal;
           our $VERSION = &apos;0.04&apos;;

       After that, you call Builder with some options. There are only a few
       (detailed later). Right now, we&apos;re only interested in parsers.

           use DateTime::Format::Builder
           (
               parsers =&gt; {
               ...
               }
           );

       The parsers option takes a reference to a hash of method names and
       specifications:

               parsers =&gt; {
                   parse_datetime =&gt; ... ,
                   parse_datetime_with_timezone =&gt; ... ,
                   ...
               }

       Builder will create methods in your class, each method being a parser
       that follows the given specifications. It is strongly recommended that
       one method is called parse_datetime, be it a Builder created method or
       one of your own.

       In addition to creating any of the parser methods it also creates a
       &quot;new()&quot; method that can instantiate (or clone) objects of this class.
       This behaviour can be modified with the constructor option, but we don&apos;t
       need to know that yet.

       Each value corresponding to a method name in the parsers list is either a
       single specification, or a list of specifications. We&apos;ll start with the
       simple case.

               parse_briefdate =&gt; {
                   params =&gt; [ qw( year month day ) ],
                   regex  =&gt; qr/^(\d\d\d\d)(\d\d)(\d\d)$/,
               },

       This will result in a method named parse_briefdate which will take
       strings in the form 20040716 and return DateTime objects representing
       that date. A user of the class might write:

           use DateTime::Format::ICal;
           my $date = &quot;19790716&quot;;
           my $dt = DateTime::Format::ICal-&gt;parse_briefdate( $date );
           print &quot;My birth month is &quot;, $dt-&gt;month_name, &quot;\n&quot;;

       The &quot;regex&quot; is applied to the input string, and if it matches, then $1,
       $2, ... are mapped to the params given and handed to &quot;DateTime-&gt;new()&quot;.
       Essentially:

           my $rv = DateTime-&gt;new( year =&gt; $1, month =&gt; $2, day =&gt; $3 );
&#12;       There are more complicated things one can do within a single
       specification, but we&apos;ll cover those later.

       Often, you&apos;ll want a method to be able to take one string, and run it
       against multiple parser specifications. It would be very irritating if
       the user had to work out what format the datetime string was in and then
       which method was most appropriate.

       So, Builder lets you specify multiple specifications:

           parse_datetime =&gt; [
               {
                   params =&gt; [ qw( year month day hour minute second ) ],
                   regex  =&gt; qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)(\d\d)(\d\d)$/,
               },
               {
                   params =&gt; [ qw( year month day hour minute ) ],
                   regex  =&gt; qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)(\d\d)$/,
               },
               {
                   params =&gt; [ qw( year month day hour ) ],
                   regex  =&gt; qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)$/,
               },
               {
                   params =&gt; [ qw( year month day ) ],
                   regex  =&gt; qr/^(\d\d\d\d)(\d\d)(\d\d)$/,
               },
           ],

       It&apos;s an arrayref of specifications. A parser will be created that will
       try each of these specifications sequentially, in the order you
       specified.

       There&apos;s a flaw with this though. In this example, we&apos;re building a parser
       for ICal datetimes. One can place a timezone id at the start of an ICal
       datetime. You might extract such an id with the following code:

           if ( $date =~ s/^TZID=([^:]+):// )
           {
               $time_zone = $1;
           }
           # Z at end means UTC
           elsif ( $date =~ s/Z$// )
           {
               $time_zone = &apos;UTC&apos;;
           }
           else
           {
               $time_zone = &apos;floating&apos;;
           }

       $date would end up without the id, and $time_zone would contain something
       appropriate to give to DateTime&apos;s set_time_zone method, or time_zone
       argument.

       But how to get this scrap of code into your parser? You might be tempted
       to call the parser something else and build a small wrapper. There&apos;s no
       need though because an option is provided for preprocesing dates:

           parse_datetime =&gt; [
               [ preprocess =&gt; \&amp;_parse_tz ], # Only changed line!
               {
                   params =&gt; [ qw( year month day hour minute second ) ],
                   regex  =&gt; qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)(\d\d)(\d\d)$/,
               },
               {
                   params =&gt; [ qw( year month day hour minute ) ],
                   regex  =&gt; qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)(\d\d)$/,
               },
               {
                   params =&gt; [ qw( year month day hour ) ],
                   regex  =&gt; qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)$/,
               },
               {
                   params =&gt; [ qw( year month day ) ],
                   regex  =&gt; qr/^(\d\d\d\d)(\d\d)(\d\d)$/,
               },
           ],

       It will necessitate _parse_tz to be written, and that routine looks like
       this:

           sub _parse_tz
           {
               my %args = @_;
               my ($date, $p) = @args{qw( input parsed )};
               if ( $date =~ s/^TZID=([^:]+):// )
               {
                   $p-&gt;{time_zone} = $1;
               }
               # Z at end means UTC
               elsif ( $date =~ s/Z$// )
               {
                   $p-&gt;{time_zone} = &apos;UTC&apos;;
               }
               else
               {
                   $p-&gt;{time_zone} = &apos;floating&apos;;
               }
               return $date;
           }

       On input it is given a hash containing two items: the input date and a
       hashref that will be used in the parsing. The return value from the
       routine is what the parser specifications will run against, and anything
       in the parsed hash ($p in the example) will be put in the call to
       &quot;DateTime-&gt;new(...)&quot;.

       So, we now have a happily working ICal parser. It parses the assorted
       formats, and can also handle timezones. Is there anything else it needs
       to do? No. But we can make it work more efficiently.

       At present, the specifications are tested sequentially.  However, each
       one applies to strings of particular lengths.  Thus we could be efficient
       and have the parser only test the given strings against a parser that
       handles that string length. Again, Builder makes it easy:

           parse_datetime =&gt; [
               [ preprocess =&gt; \&amp;_parse_tz ],
               {
                   length =&gt; 15, # We handle strings of exactly 15 chars
                   params =&gt; [ qw( year month day hour minute second ) ],
                   regex  =&gt; qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)(\d\d)(\d\d)$/,
               },
               {
                   length =&gt; 13, # exactly 13 chars...
                   params =&gt; [ qw( year month day hour minute ) ],
                   regex  =&gt; qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)(\d\d)$/,
               },
               {
                   length =&gt; 11, # 11..
                   params =&gt; [ qw( year month day hour ) ],
                   regex  =&gt; qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)$/,
               },
               {
                   length =&gt; 8, # yes.
                   params =&gt; [ qw( year month day ) ],
                   regex  =&gt; qr/^(\d\d\d\d)(\d\d)(\d\d)$/,
               },
               ],

       Now the created parser will create a parser that only runs specifications
       against appropriate strings.

       So our complete code looks like:

           package DateTime::Format::ICal;
           use strict;
           our $VERSION = &apos;0.04&apos;;

           use DateTime::Format::Builder
           (
               parsers =&gt; {
                   parse_datetime =&gt; [
                   [ preprocess =&gt; \&amp;_parse_tz ],
                   {
                       length =&gt; 15,
                       params =&gt; [ qw( year month day hour minute second ) ],
                       regex  =&gt; qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)(\d\d)(\d\d)$/,
                   },
                   {
                       length =&gt; 13,
                       params =&gt; [ qw( year month day hour minute ) ],
                       regex  =&gt; qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)(\d\d)$/,
                   },
                   {
                       length =&gt; 11,
                       params =&gt; [ qw( year month day hour ) ],
                       regex  =&gt; qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)$/,
                   },
                   {
                       length =&gt; 8,
                       params =&gt; [ qw( year month day ) ],
                       regex  =&gt; qr/^(\d\d\d\d)(\d\d)(\d\d)$/,
                   },
                   ],
               },
           );

           sub _parse_tz
           {
               my %args = @_;
               my ($date, $p) = @args{qw( input parsed )};
               if ( $date =~ s/^TZID=([^:]+):// )
               {
                   $p-&gt;{time_zone} = $1;
               }
               # Z at end means UTC
               elsif ( $date =~ s/Z$// )
               {
                   $p-&gt;{time_zone} = &apos;UTC&apos;;
               }
               else
               {
                   $p-&gt;{time_zone} = &apos;floating&apos;;
               }
               return $date;
           }

           1;

       And that&apos;s an ICal parser. The actual DateTime::Format::ICal module also
       includes formatting methods and parsing for durations, but Builder
       doesn&apos;t support those yet. A drop in replacement (at the time of writing
       the replacement) can be found in the examples directory of the Builder
       distribution, along with similar variants of other common modules.

SUPPORT
       Any errors you see in this document, please log them with CPAN RT system
       via the web or email:

           http://perl.dellah.org/rt/dtbuilder
           bug-datetime-format-builder@rt.cpan.org

       This makes it much easier for me to track things and thus means your
       problem is less likely to be neglected.

LICENSE AND COPYRIGHT
       Copyright X Iain Truskett, 2003. All rights reserved.

       You can redistribute this document and/or modify it under the same terms
       as Perl itself.

       The full text of the licenses can be found in the Artistic and COPYING
       files included with this document.

AUTHOR
       Iain Truskett &lt;spoon@cpan.org&gt;

SEE ALSO
       &quot;datetime@perl.org&quot; mailing list.

       http://datetime.perl.org/

       perl, DateTime, DateTime::Format::Builder



perl v5.10.1                       2010-DateTime::Format::Builder::Tutorial(3pm)

</pre></body></html>
