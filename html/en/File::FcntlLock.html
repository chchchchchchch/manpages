<html>
<head><meta charset=utf-8/>
<title>File::FcntlLock - File locking with fcntl(2)</title></head>
<body><pre>

File::FcntlLock(3pm)   User Contributed Perl Documentation  File::FcntlLock(3pm)



NAME
       File::FcntlLock - File locking with fcntl(2)

SYNOPSIS
         use File::FcntlLock;

         my $fs = new File::FcntlLock;
         $fs-&gt;l_type( F_RDLCK );
         $fs-&gt;l_whence( SEEK_CUR );
         $fs-&gt;l_start( 100 );
         $fs-&gt;l_len( 123 );

         open my $fh, &apos;&lt;&apos;, &apos;file_name&apos; or die &quot;Can&apos;t open file: $!\n&quot;;
         $fs-&gt;lock( $fh, F_SETLK )
             or print &quot;Locking failed: &quot; . $fs-&gt;error . &quot;\n&quot;;
         $fs-&gt;l_type( F_UNLCK );
         $fs-&gt;lock( $fh, F_SETLK )
             or print &quot;Unlocking failed: &quot; . $fs-&gt;error . &quot;\n&quot;;

DESCRIPTION
       File locking in Perl is usually done using the flock() function.
       Unfortunately, this only allows locks on whole files and is often
       implemented in terms of flock(2), which has some shortcomings.

       Using this module file locking via fcntl(2) can be done (obviously, this
       restricts the use of the module to systems that have a fcntl(2) system
       call). Before a file (or parts of a file) can be locked, an object
       simulating a flock structure must be created and its properties set.
       Afterwards, by calling the &quot;lock()&quot; method a lock can be set or it can be
       determined if and which process currently holds the lock.

       To create a new object representing a flock structure call &quot;new()&quot;:

         $fs = new File::FcntlLock;

       You also can pass the &quot;new()&quot; method a set of key-value pairs to
       initialize the objects properties, e.g. use

         $fs = new File::FcntlLock l_type   =&gt; F_WRLCK,
                                   l_whence =&gt; SEEK_SET,
                                   l_start  =&gt; 0,
                                   l_len    =&gt; 100;

       if you plan to obtain a write lock for the first 100 bytes of a file.

       Once you have created the object simulating the flock structure the
       following methods allow to query and in most cases also to modify the
       properties of the object.

       &quot;l_type()&quot;
           If called without an argument returns the current setting of the lock
           type, otherwise the lock type is set to the argument, which must be
           either &quot;F_RDLCK&quot;, &quot;F_WRLCK&quot; or &quot;F_UNLCK&quot; (for read lock, write lock
           or unlock).

       &quot;l_whence()&quot;
           Queries or sets the &quot;l_whence&quot; property of the flock object,
           determining if the &quot;l_start&quot; value is relative to the start of the
           file, to the current position in the file or to the end of the file.
           The corresponding values are &quot;SEEK_SET&quot;, &quot;SEEK_CUR&quot; and &quot;SEEK_END&quot;.
           See also the man page for lseek(2).
&#12;       &quot;l_start()&quot;
           Queries or sets the start position (offset) of the lock in the file
           according to the mode selected by the &quot;l_whence&quot; member.  See also
           the man page for lseek(2).

       &quot;l_len()&quot;
           Queries or sets the length of the region (in bytes) in the file to be
           locked. A value of 0 is interpreted as to mean a lock (starting at
           &quot;l_start&quot;) up to the very end of the file.

           According to SUSv3 negative values for &quot;l_start&quot; are allowed
           (resulting in a lock ranging from &quot;l_start + l_len&quot; to &quot;l_start - 1&quot;)
           Unfortunately, not all systems allow negative arguments and will
           return an error when you try to obtain the lock, so please read the
           fcntl(2) man page of your system carefully for details.

       &quot;l_pid()&quot;
           This method allows retrieving the PID of a process currently holding
           the lock after a call of &quot;lock()&quot; with &quot;F_SETLK&quot; indicated that
           another process is holding the lock. A call to &quot;lock()&quot; with
           &quot;F_GETLK&quot; will fill in this value so &quot;l_pid()&quot; can be called.

       When not initialized the flock objects &quot;l_type&quot; property is set to
       &quot;F_RDLCK&quot; by default, &quot;l_whence&quot; to &quot;SEEK_SET&quot;, and both &quot;l_start&quot; and
       &quot;l_len&quot; to 0, i.e. the settings for a read lock on the whole file.

       After having set up the object representing a flock structure you can
       determine the current holder of a lock or try to obtain a lock by
       invoking the &quot;lock()&quot; method with two arguments, a file handle (or a file
       descriptor, the module figures out automatically what it got) and a flag
       indicating the action to be taken, e.g.

         $fs-&gt;lock( $fh, F_SETLK );

       There are three values that can be used as the second argument:

       &quot;F_GETLK&quot;
           For &quot;F_GETLK&quot; the &quot;lock()&quot; method determines if and who currently is
           holding the lock.  If no other process is holding the lock the
           &quot;l_type&quot; field is set to &quot;F_UNLCK&quot;. Otherwise the flock structure
           object is set to the values that prevent us from obtaining a lock.
           There may be multiple such blocking processes, including some that
           are themselves blocked waiting to obtain a lock. &quot;F_GETLK&quot; will only
           make details of one of these visible, and one has no control over
           which process this is.

       &quot;F_SETLK&quot;
           For &quot;F_SETLK&quot; the &quot;lock()&quot; method tries to obtain the lock (when
           &quot;l_type&quot; is set to either &quot;F_WRLCK&quot; or &quot;F_RDLCK&quot;) or releases the
           lock (if &quot;l_type&quot; is set to &quot;F_UNLCK&quot;). If a lock is held by some
           other process the method call returns &quot;undef&quot; and errno is set to
           &quot;EACCESS&quot; or &quot;EAGAIN&quot; (please see the the man page for fcntl(2) for
           the details).

       &quot;F_SETLKW&quot;
           is similar to &quot;F_SETLK&quot; but instead of returning an error if the lock
           can&apos;t be obtained immediately it blocks until the lock is obtained.
           If a signal is received while waiting for the lock the method returns
           &quot;undef&quot; and errno is set to &quot;EINTR&quot;.

       On success the method returns the string &quot;0 but true&quot;. If the method
       fails (as indicated by an &quot;undef&quot; return value) you can either
       immediately evaluate the error number (usingf $!, $ERRNO or $OS_ERROR) or
       check for it at some later time via the methods discussed below.

       There are three methods for obtaining information about the reason the
       the last call of &quot;lock()&quot; for the object failed:

       &quot;lock_errno()&quot;
           Returns the error number from the latest call of &quot;lock()&quot;. If the
           last call did not result in an error the method returns &quot;undef&quot;.

       &quot;error()&quot;
           Returns a short description of the error that happened during the
           latest call of &quot;lock()&quot; with the object. Please take the messages
           with a grain of salt, they represent what SUSv3 (IEEE 1003.1-2001)
           and the Linux, TRUE64, OpenBSD3 and Solaris8 man pages tell what the
           error numbers mean, there could be differences (and additional error
           numbers) on other systems. If there was no error the method returns
           &quot;undef&quot;.

       &quot;system_error()&quot;
           While the previous method, &quot;error()&quot;, tries to return a string with
           some relevance to the locking operation (i.e. &quot;File or segment
           already locked by other process(es)&quot; instead of &quot;Permission denied&quot;)
           this method returns the &quot;normal&quot; system error message associated with
           errno. The method returns &quot;undef&quot; if there was no error.

   EXPORT
       F_GETLK F_SETLK F_SETLKW F_RDLCK F_WRLCK F_UNLCK SEEK_SET SEEK_CUR
       SEEK_END

CREDITS
       Thanks to Mark Jason Dominus (MJD) and Benjamin Goldberg (GOLDBB) for
       helpful discussions, code examples and encouragement. Glenn Herteg
       pointed out several problems and also helped improve the documentation.
       Julian Moreno Patino also helped correcting the documentation and pointed
       out problems arising on GNU Hurd (which seems to have only very
       rudimentary support for locking with fcntl()).

AUTHOR
       Jens Thoms Toerring &lt;jt@toerring.de&gt;

SEE ALSO
       perl(1), fcntl(2), lseek(2).



perl v5.14.2                       2011-10-29               File::FcntlLock(3pm)

</pre></body></html>
