<html>
<head><meta charset=utf-8/>
<title>File::Find::Rule - Alternative interface to File::Find</title></head>
<body><pre>

File::Find::Rule(3pm)  User Contributed Perl Documentation File::Find::Rule(3pm)



NAME
       File::Find::Rule - Alternative interface to File::Find

SYNOPSIS
         use File::Find::Rule;
         # find all the subdirectories of a given directory
         my @subdirs = File::Find::Rule-&gt;directory-&gt;in( $directory );

         # find all the .pm files in @INC
         my @files = File::Find::Rule-&gt;file()
                                     -&gt;name( &apos;*.pm&apos; )
                                     -&gt;in( @INC );

         # as above, but without method chaining
         my $rule =  File::Find::Rule-&gt;new;
         $rule-&gt;file;
         $rule-&gt;name( &apos;*.pm&apos; );
         my @files = $rule-&gt;in( @INC );

DESCRIPTION
       File::Find::Rule is a friendlier interface to File::Find.  It allows you
       to build rules which specify the desired files and directories.

METHODS
       &quot;new&quot;
           A constructor.  You need not invoke &quot;new&quot; manually unless you wish
           to, as each of the rule-making methods will auto-create a suitable
           object if called as class methods.

   Matching Rules
       &quot;name( @patterns )&quot;
           Specifies names that should match.  May be globs or regular
           expressions.

            $set-&gt;name( &apos;*.mp3&apos;, &apos;*.ogg&apos; ); # mp3s or oggs
            $set-&gt;name( qr/\.(mp3|ogg)$/ ); # the same as a regex
            $set-&gt;name( &apos;foo.bar&apos; );        # just things named foo.bar

       -X tests
           Synonyms are provided for each of the -X tests. See &quot;-X&quot; in perlfunc
           for details.  None of these methods take arguments.

             Test | Method               Test |  Method
            ------|-------------        ------|----------------
              -r  |  readable             -R  |  r_readable
              -w  |  writeable            -W  |  r_writeable
              -w  |  writable             -W  |  r_writable
              -x  |  executable           -X  |  r_executable
              -o  |  owned                -O  |  r_owned
                  |                           |
              -e  |  exists               -f  |  file
              -z  |  empty                -d  |  directory
              -s  |  nonempty             -l  |  symlink
                  |                       -p  |  fifo
              -u  |  setuid               -S  |  socket
              -g  |  setgid               -b  |  block
              -k  |  sticky               -c  |  character
                  |                       -t  |  tty
              -M  |  modified                 |
              -A  |  accessed             -T  |  ascii
              -C  |  changed              -B  |  binary
&#12;           Though some tests are fairly meaningless as binary flags (&quot;modified&quot;,
           &quot;accessed&quot;, &quot;changed&quot;), they have been included for completeness.

            # find nonempty files
            $rule-&gt;file,
                 -&gt;nonempty;

       stat tests
           The following &quot;stat&quot; based methods are provided: &quot;dev&quot;, &quot;ino&quot;,
           &quot;mode&quot;, &quot;nlink&quot;, &quot;uid&quot;, &quot;gid&quot;, &quot;rdev&quot;, &quot;size&quot;, &quot;atime&quot;, &quot;mtime&quot;,
           &quot;ctime&quot;, &quot;blksize&quot;, and &quot;blocks&quot;.  See &quot;stat&quot; in perlfunc for
           details.

           Each of these can take a number of targets, which will follow
           Number::Compare semantics.

            $rule-&gt;size( 7 );         # exactly 7
            $rule-&gt;size( &quot;&gt;7Ki&quot; );    # larger than 7 * 1024 * 1024 bytes
            $rule-&gt;size( &quot;&gt;=7&quot; )
                 -&gt;size( &quot;&lt;=90&quot; );    # between 7 and 90, inclusive
            $rule-&gt;size( 7, 9, 42 );  # 7, 9 or 42

       &quot;any( @rules )&quot;
       &quot;or( @rules )&quot;
           Allows shortcircuiting boolean evaluation as an alternative to the
           default and-like nature of combined rules.  &quot;any&quot; and &quot;or&quot; are
           interchangeable.

            # find avis, movs, things over 200M and empty files
            $rule-&gt;any( File::Find::Rule-&gt;name( &apos;*.avi&apos;, &apos;*.mov&apos; ),
                        File::Find::Rule-&gt;size( &apos;&gt;200M&apos; ),
                        File::Find::Rule-&gt;file-&gt;empty,
                      );

       &quot;none( @rules )&quot;
       &quot;not( @rules )&quot;
           Negates a rule.  (The inverse of &quot;any&quot;.)  &quot;none&quot; and &quot;not&quot; are
           interchangeable.

             # files that aren&apos;t 8.3 safe
             $rule-&gt;file
                  -&gt;not( $rule-&gt;new-&gt;name( qr/^[^.]{1,8}(\.[^.]{0,3})?$/ ) );

       &quot;prune&quot;
           Traverse no further.  This rule always matches.

       &quot;discard&quot;
           Don&apos;t keep this file.  This rule always matches.

       &quot;exec( \&amp;subroutine( $shortname, $path, $fullname ) )&quot;
           Allows user-defined rules.  Your subroutine will be invoked with $_
           set to the current short name, and with parameters of the name, the
           path you&apos;re in, and the full relative filename.

           Return a true value if your rule matched.

            # get things with long names
            $rules-&gt;exec( sub { length &gt; 20 } );

       &quot;grep( @specifiers )&quot;
           Opens a file and tests it each line at a time.

           For each line it evaluates each of the specifiers, stopping at the
           first successful match.  A specifier may be a regular expression or a
           subroutine.  The subroutine will be invoked with the same parameters
           as an -&gt;exec subroutine.

           It is possible to provide a set of negative specifiers by enclosing
           them in anonymous arrays.  Should a negative specifier match the
           iteration is aborted and the clause is failed.  For example:

            $rule-&gt;grep( qr/^#!.*\bperl/, [ sub { 1 } ] );

           Is a passing clause if the first line of a file looks like a perl
           shebang line.

       &quot;maxdepth( $level )&quot;
           Descend at most $level (a non-negative integer) levels of directories
           below the starting point.

           May be invoked many times per rule, but only the most recent value is
           used.

       &quot;mindepth( $level )&quot;
           Do not apply any tests at levels less than $level (a non-negative
           integer).

       &quot;extras( \%extras )&quot;
           Specifies extra values to pass through to &quot;File::File::find&quot; as part
           of the options hash.

           For example this allows you to specify following of symlinks like so:

            my $rule = File::Find::Rule-&gt;extras({ follow =&gt; 1 });

           May be invoked many times per rule, but only the most recent value is
           used.

       &quot;relative&quot;
           Trim the leading portion of any path found

       &quot;not_*&quot;
           Negated version of the rule.  An effective shortand related to ! in
           the procedural interface.

            $foo-&gt;not_name(&apos;*.pl&apos;);

            $foo-&gt;not( $foo-&gt;new-&gt;name(&apos;*.pl&apos; ) );

   Query Methods
       &quot;in( @directories )&quot;
           Evaluates the rule, returns a list of paths to matching files and
           directories.

       &quot;start( @directories )&quot;
           Starts a find across the specified directories.  Matching items may
           then be queried using &quot;match&quot;.  This allows you to use a rule as an
           iterator.

            my $rule = File::Find::Rule-&gt;file-&gt;name(&quot;*.jpeg&quot;)-&gt;start( &quot;/web&quot; );
            while ( defined ( my $image = $rule-&gt;match ) ) {
                ...
            }

       &quot;match&quot;
           Returns the next file which matches, false if there are no more.

   Extensions
       Extension modules are available from CPAN in the File::Find::Rule
       namespace.  In order to use these extensions either use them directly:

        use File::Find::Rule::ImageSize;
        use File::Find::Rule::MMagic;
&#12;        # now your rules can use the clauses supplied by the ImageSize and
        # MMagic extension

       or, specify that File::Find::Rule should load them for you:

        use File::Find::Rule qw( :ImageSize :MMagic );

       For notes on implementing your own extensions, consult
       File::Find::Rule::Extending

   Further examples
       Finding perl scripts
            my $finder = File::Find::Rule-&gt;or
             (
              File::Find::Rule-&gt;name( &apos;*.pl&apos; ),
              File::Find::Rule-&gt;exec(
                                     sub {
                                         if (open my $fh, $_) {
                                             my $shebang = &lt;$fh&gt;;
                                             close $fh;
                                             return $shebang =~ /^#!.*\bperl/;
                                         }
                                         return 0;
                                     } ),
             );

           Based upon this message
           http://use.perl.org/comments.pl?sid=7052&amp;cid=10842

       ignore CVS directories
            my $rule = File::Find::Rule-&gt;new;
            $rule-&gt;or($rule-&gt;new
                           -&gt;directory
                           -&gt;name(&apos;CVS&apos;)
                           -&gt;prune
                           -&gt;discard,
                      $rule-&gt;new);

           Note here the use of a null rule.  Null rules match anything they
           see, so the effect is to match (and discard) directories called &apos;CVS&apos;
           or to match anything.

TWO FOR THE PRICE OF ONE
       File::Find::Rule also gives you a procedural interface.  This is
       documented in File::Find::Rule::Procedural

EXPORTS
       &quot;find&quot;, &quot;rule&quot;

TAINT MODE INTERACTION
       As of 0.32 File::Find::Rule doesn&apos;t capture the current working directory
       in a taint-unsafe manner.  File::Find itself still does operations that
       the taint system will flag as insecure but you can use the &quot;extras&quot;
       feature to ask File::Find to internally &quot;untaint&quot; file paths with a regex
       like so:

           my $rule = File::Find::Rule-&gt;extras({ untaint =&gt; 1 });

       Please consult File::Find&apos;s documentation for &quot;untaint&quot;,
       &quot;untaint_pattern&quot;, and &quot;untaint_skip&quot; for more information.

BUGS
       The code makes use of the &quot;our&quot; keyword and as such requires perl version
       5.6.0 or newer.

       Currently it isn&apos;t possible to remove a clause from a rule object.  If
       this becomes a significant issue it will be addressed.
&#12;AUTHOR
       Richard Clamp &lt;richardc@unixbeard.net&gt; with input gained from this
       use.perl discussion: http://use.perl.org/~richardc/journal/6467

       Additional proofreading and input provided by Kake, Greg McCarroll, and
       Andy Lester andy@petdance.com.

COPYRIGHT
       Copyright (C) 2002, 2003, 2004, 2006, 2009, 2011 Richard Clamp.  All
       Rights Reserved.

       This module is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.

SEE ALSO
       File::Find, Text::Glob, Number::Compare, find(1)

       If you want to know about the procedural interface, see
       File::Find::Rule::Procedural, and if you have an idea for a neat
       extension File::Find::Rule::Extending



perl v5.12.4                       2011-09-20              File::Find::Rule(3pm)

</pre></body></html>
