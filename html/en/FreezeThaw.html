<html>
<head><meta charset=utf-8/>
<title>FreezeThaw - converting Perl structures to strings and back.</title></head>
<body><pre>

FreezeThaw(3pm)        User Contributed Perl Documentation       FreezeThaw(3pm)



NAME
       FreezeThaw - converting Perl structures to strings and back.

SYNOPSIS
         use FreezeThaw qw(freeze thaw cmpStr safeFreeze cmpStrHard);
         $string = freeze $data1, $data2, $data3;
         ...
         ($olddata1, $olddata2, $olddata3) = thaw $string;
         if (cmpStr($olddata2,$data2) == 0) {print &quot;OK!&quot;}

DESCRIPTION
       Converts data to/from stringified form, appropriate for
       saving-to/reading-from permanent storage.

       Deals with objects, circular lists, repeated appearance of the same
       reference. Does not deal with overloaded stringify operator yet.

EXPORT
       Default     None.

       Exportable  &quot;freeze thaw cmpStr cmpStrHard safeFreeze&quot;.

User API
       &quot;cmpStr&quot;    analogue of &quot;cmp&quot; for data. Takes two arguments and compares
                   them as separate entities.

       &quot;cmpStrHard&quot;
                   analogue of &quot;cmp&quot; for data. Takes two arguments and compares
                   them considered as a group.

       &quot;freeze&quot;    returns a string that encupsulates its arguments (considered
                   as a group). &quot;thaw&quot;ing this string leads to a fatal error if
                   arguments to &quot;freeze&quot; contained references to &quot;GLOB&quot;s and
                   &quot;CODE&quot;s.

       &quot;safeFreeze&quot;
                   returns a string that encupsulates its arguments (considered
                   as a group). The result is &quot;thaw&quot;able in the same process.
                   &quot;thaw&quot;ing the result in a different process should result in
                   a fatal error if arguments to &quot;safeFreeze&quot; contained
                   references to &quot;GLOB&quot;s and &quot;CODE&quot;s.

       &quot;thaw&quot;      takes one string argument and returns an array. The elements
                   of the array are &quot;equivalent&quot; to arguments of the &quot;freeze&quot;
                   command that created the string. Can result in a fatal error
                   (see above).

Developer API
       &quot;FreezeThaw&quot; &quot;freeze&quot;s and &quot;thaw&quot;s data blessed in some package by
       calling methods &quot;Freeze&quot; and &quot;Thaw&quot; in the package. The fallback methods
       are provided by the &quot;FreezeThaw&quot; itself. The fallback &quot;Freeze&quot; freezes
       the &quot;content&quot; of blessed object (from Perl point of view). The fallback
       &quot;Thaw&quot; blesses the &quot;thaw&quot;ed data back into the package.

       So the package needs to define its own methods only if the fallback
       methods will fail (for example, for a lot of data the &quot;content&quot; of an
       object is an address of some C data). The methods are called like

         $newcooky = $obj-&gt;Freeze($cooky);
         $obj = Package-&gt;Thaw($content,$cooky);

       To save and restore the data the following method are applicable:

         $cooky-&gt;FreezeScalar($data,$ignorePackage,$noduplicate);

       during Freeze()ing, and

         $data = $cooky-&gt;ThawScalar;

       Two optional arguments $ignorePackage and $noduplicate regulate whether
       the freezing should not call the methods even if $data is a reference to
       a blessed object, and whether the data should not be marked as seen
       already even if it was seen before. The default methods

         sub UNIVERSAL::Freeze {
           my ($obj, $cooky) = (shift, shift);
           $cooky-&gt;FreezeScalar($obj,1,1);
         }

         sub UNIVERSAL::Thaw {
           my ($package, $cooky) = (shift, shift);
           my $obj = $cooky-&gt;ThawScalar;
           bless $obj, $package;
         }

       call the &quot;FreezeScalar&quot; method of the $cooky since the freezing engine
       will see the data the second time during this call. Indeed, it is the
       freezing engine who calls UNIVERSAL::Freeze(), and it calls it because it
       needs to freeze $obj. The above call to $cooky-&gt;FreezeScalar() handles
       the same data back to engine, but because flags are different, the code
       does not cycle.

       Freezing and thawing $cooky also allows the following additional methods:

         $cooky-&gt;isSafe;

       to find out whether the current freeze was initiated by &quot;freeze&quot; or
       &quot;safeFreeze&quot; command. Analogous method for thaw $cooky returns whether
       the current thaw operation is considered safe (i.e., either does not
       contain cached elsewhere data, or comes from the same application). You
       can use

         $cooky-&gt;makeSafe;

       to prohibit cached data for the duration of the rest of freezing or
       thawing of current object.

       Two methods

         $value = $cooky-&gt;repeatedOK;
         $cooky-&gt;noRepeated;           # Now repeated are prohibited

       allow to find out/change the current setting for allowing repeated
       references.

       If you want to flush the cache of saved objects you can use

         FreezeThaw-&gt;flushCache;

       this can invalidate some frozen string, so that thawing them will result
       in fatal error.

   Instantiating
       Sometimes, when an object from a package is recreated in presense of
       repeated references, it is not safe to recreate the internal structure of
       an object in one step. In such a situation recreation of an object is
       carried out in two steps: in the first the object is &quot;allocate&quot;d, in the
       second it is &quot;instantiate&quot;d.

       The restriction is that during the allocation step you cannot use any
       reference to any Perl object that can be referenced from any other place.
       This restriction is applied since that object may not exist yet.

       Correspondingly, during instantiation step the previosly allocated object
       should be &quot;filled&quot;, i.e., it can be changed in any way such that the
       references to this object remain valid.

       The methods are called like this:

         $pre_object_ref = Package-&gt;Allocate($pre_pre_object_ref);
               # Returns reference
         Package-&gt;Instantiate($pre_object_ref,$cooky);
               # Converts into reference to blessed object

       The reverse operations are

         $object_ref-&gt;FreezeEmpty($cooky);
         $object_ref-&gt;FreezeInstance($cooky);

       during these calls object can &quot;freezeScalar&quot; some information (in a usual
       way) that will be used during &quot;Allocate&quot; and &quot;Instantiate&quot; calls (via
       &quot;thawScalar&quot;). Note that the return value of &quot;FreezeEmpty&quot; is cached
       during the phase of creation of uninialized objects. This must be used
       like this: the return value is the reference to the created object, so it
       is not destructed until other objects are created, thus the frozen values
       of the different objects will not share the same references. Example of
       bad result:

         $o1-&gt;FreezeEmpty($cooky)

       freezes &quot;{}&quot;, and &quot;$o2-&gt;FreezeEmpty($cooky)&quot; makes the same. Now nobody
       guaranties that that these two copies of &quot;{}&quot; are different, unless a
       reference to the first one is preserved during the call to
       &quot;$o2-&gt;FreezeEmpty($cooky)&quot;. If &quot;$o1-&gt;FreezeEmpty($cooky)&quot; returns the
       value of &quot;{}&quot; it uses, it will be preserved by the engine.

       The helper function &quot;FreezeThaw::copyContents&quot; is provided for
       simplification of instantiation. The syntax is

         FreezeThaw::copyContents $to, $from;

       The function copies contents the object $from point to into what the
       object $to points to (including package for blessed references). Both
       arguments should be references.

       The default methods are provided. They do the following:

       &quot;FreezeEmpty&quot;
                   Freezes an empty object of underlying type.

       &quot;FreezeInstance&quot;
                   Calls &quot;Freeze&quot;.

       &quot;Allocate&quot;  Thaws what was frozen by &quot;FreezeEmpty&quot;.

       &quot;Instantiate&quot;
                   Thaws what was frozen by &quot;FreezeInstance&quot;, uses
                   &quot;copyContents&quot; to transfer this to the $pre_object.

BUGS and LIMITATIONS
       A lot of objects are blessed in some obscure packages by XSUB typemaps.
       It is not clear how to (automatically) prevent the &quot;UNIVERSAL&quot; methods to
       be called for objects in these packages.
&#12;       The objects which can survive freeze()/thaw() cycle must also survive a
       change of a &quot;member&quot; to an equal member.  Say, after

         $a = [a =&gt; 3];
         $a-&gt;{b} = \ $a-&gt;{a};

       $a satisfies

         $a-&gt;{b} == \ $a-&gt;{a}

       This property will be broken by freeze()/thaw(), but it is also broken by

         $a-&gt;{a} = delete $a-&gt;{a};



perl v5.10.1                       2010-04-07                    FreezeThaw(3pm)

</pre></body></html>
