<html>
<head><meta charset=utf-8/>
<title>gg-queue, GG_SLIST_HEAD, GG_SLIST_HEAD_INITIALIZER, GG_SLIST_ENTRY, GG_SLIST_INIT2, GG_SLIST_INSERT_AFTER, GG_SLIST_INSERT_HEAD, GG_SLIST_REMOVE_HEAD, GG_SLIST_REMOVE, GG_SLIST_FOREACH, GG_SLIST_EMPTY, GG_SLIST_FIRST, GG_SLIST_NEXT, GG_SIMPLEQ_HEAD, GG_SIMPLEQ_HEAD_INITIALIZER, GG_SIMPLEQ_ENTRY, GG_SIMPLEQ_INIT, GG_SIMPLEQ_INSERT_HEAD, GG_SIMPLEQ_INSERT_TAIL, GG_SIMPLEQ_INSERT_AFTER, GG_SIMPLEQ_REMOVE_HEAD, GG_SIMPLEQ_REMOVE, GG_SIMPLEQ_FOREACH, GG_SIMPLEQ_EMPTY, GG_SIMPLEQ_FIRST, GG_SIMPLEQ_NEXT, GG_LIST_HEAD, GG_LIST_HEAD_INITIALIZER, GG_LIST_ENTRY, GG_LIST_INIT, GG_LIST_INSERT_AFTER, GG_LIST_INSERT_BEFORE, GG_LIST_INSERT_HEAD, GG_LIST_REMOVE, GG_LIST_FOREACH, GG_LIST_EMPTY, GG_LIST_FIRST, GG_LIST_NEXT, GG_TAILQ_HEAD, GG_TAILQ_HEAD_INITIALIZER, GG_TAILQ_ENTRY, GG_TAILQ_INIT, GG_TAILQ_INSERT_HEAD, GG_TAILQ_INSERT_TAIL, GG_TAILQ_INSERT_AFTER, GG_TAILQ_INSERT_BEFORE, GG_TAILQ_REMOVE, GG_TAILQ_FOREACH, GG_TAILQ_FOREACH_REVERSE, GG_TAILQ_EMPTY, GG_TAILQ_FIRST, GG_TAILQ_NEXT, GG_TAILQ_LAST, GG_TAILQ_PREV, GG_CIRCLEQ_HEAD, GG_CIRCLEQ_HEAD_INITIALIZER, GG_CIRCLEQ_ENTRY, GG_CIRCLEQ_INIT, GG_CIRCLEQ_INSERT_AFTER, GG_CIRCLEQ_INSERT_BEFORE, GG_CIRCLEQ_INSERT_HEAD, GG_CIRCLEQ_INSERT_TAIL, GG_CIRCLEQ_REMOVE, GG_CIRCLEQ_FOREACH, GG_CIRCLEQ_FOREACH_REVERSE, GG_CIRCLEQ_EMPTY, GG_CIRCLEQ_FIRST, GG_CIRCLEQ_LAST, GG_CIRCLEQ_NEXT, GG_CIRCLEQ_PREV - implementations of singly-linked lists, simple queues, lists, tail queues, and circular queues</title></head>
<body><pre>

gg-queue(3)                            GGI                           gg-queue(3)



NAME
       gg-queue,   GG_SLIST_HEAD,   GG_SLIST_HEAD_INITIALIZER,   GG_SLIST_ENTRY,
       GG_SLIST_INIT2,       GG_SLIST_INSERT_AFTER,        GG_SLIST_INSERT_HEAD,
       GG_SLIST_REMOVE_HEAD,  GG_SLIST_REMOVE, GG_SLIST_FOREACH, GG_SLIST_EMPTY,
       GG_SLIST_FIRST, GG_SLIST_NEXT, GG_SIMPLEQ_HEAD,  GG_SIMPLEQ_HEAD_INITIAL&#8208;
       IZER,  GG_SIMPLEQ_ENTRY, GG_SIMPLEQ_INIT, GG_SIMPLEQ_INSERT_HEAD, GG_SIM&#8208;
       PLEQ_INSERT_TAIL,    GG_SIMPLEQ_INSERT_AFTER,     GG_SIMPLEQ_REMOVE_HEAD,
       GG_SIMPLEQ_REMOVE,    GG_SIMPLEQ_FOREACH,    GG_SIMPLEQ_EMPTY,    GG_SIM&#8208;
       PLEQ_FIRST,  GG_SIMPLEQ_NEXT,   GG_LIST_HEAD,   GG_LIST_HEAD_INITIALIZER,
       GG_LIST_ENTRY, GG_LIST_INIT, GG_LIST_INSERT_AFTER, GG_LIST_INSERT_BEFORE,
       GG_LIST_INSERT_HEAD,  GG_LIST_REMOVE,   GG_LIST_FOREACH,   GG_LIST_EMPTY,
       GG_LIST_FIRST,  GG_LIST_NEXT,  GG_TAILQ_HEAD,  GG_TAILQ_HEAD_INITIALIZER,
       GG_TAILQ_ENTRY,           GG_TAILQ_INIT,            GG_TAILQ_INSERT_HEAD,
       GG_TAILQ_INSERT_TAIL,    GG_TAILQ_INSERT_AFTER,   GG_TAILQ_INSERT_BEFORE,
       GG_TAILQ_REMOVE,       GG_TAILQ_FOREACH,        GG_TAILQ_FOREACH_REVERSE,
       GG_TAILQ_EMPTY,     GG_TAILQ_FIRST,     GG_TAILQ_NEXT,     GG_TAILQ_LAST,
       GG_TAILQ_PREV,  GG_CIRCLEQ_HEAD,   GG_CIRCLEQ_HEAD_INITIALIZER,   GG_CIR&#8208;
       CLEQ_ENTRY,     GG_CIRCLEQ_INIT,     GG_CIRCLEQ_INSERT_AFTER,     GG_CIR&#8208;
       CLEQ_INSERT_BEFORE,    GG_CIRCLEQ_INSERT_HEAD,    GG_CIRCLEQ_INSERT_TAIL,
       GG_CIRCLEQ_REMOVE,     GG_CIRCLEQ_FOREACH,    GG_CIRCLEQ_FOREACH_REVERSE,
       GG_CIRCLEQ_EMPTY,  GG_CIRCLEQ_FIRST,  GG_CIRCLEQ_LAST,   GG_CIRCLEQ_NEXT,
       GG_CIRCLEQ_PREV  - implementations of singly-linked lists, simple queues,
       lists, tail queues, and circular queues

SYNOPSIS
       #include &lt;ggi/gg-queue.h&gt;

       GG_SLIST_HEAD(HEADNAME, TYPE);

       GG_SLIST_HEAD_INITIALIZER(head);

       GG_SLIST_ENTRY(TYPE);

       GG_SLIST_INIT(GG_SLIST_HEAD *head);

       GG_SLIST_INSERT_AFTER(TYPE *listelm, TYPE *elm, GG_SLIST_ENTRY NAME);

       GG_SLIST_INSERT_HEAD(GG_SLIST_HEAD *head, TYPE *elm, GG_SLIST_ENTRY NAME);

       GG_SLIST_REMOVE_HEAD(GG_SLIST_HEAD *head, GG_SLIST_ENTRY NAME);

       GG_SLIST_REMOVE(GG_SLIST_HEAD *head, TYPE *elm, TYPE, GG_SLIST_ENTRY NAME);

       GG_SLIST_FOREACH(TYPE *var, GG_SLIST_HEAD *head, GG_SLIST_ENTRY NAME);

       int
       GG_SLIST_EMPTY(GG_SLIST_HEAD *head);

       TYPE *
       GG_SLIST_FIRST(GG_SLIST_HEAD *head);

       TYPE *
       GG_SLIST_NEXT(TYPE *elm, GG_SLIST_ENTRY NAME);

       GG_SIMPLEQ_HEAD(HEADNAME, TYPE);

       GG_SIMPLEQ_HEAD_INITIALIZER(head);

       GG_SIMPLEQ_ENTRY(TYPE);

       GG_SIMPLEQ_INIT(GG_SIMPLEQ_HEAD *head);
&#12;       GG_SIMPLEQ_INSERT_HEAD(GG_SIMPLEQ_HEAD *head, TYPE *elm, GG_SIMPLEQ_ENTRY NAME);

       GG_SIMPLEQ_INSERT_TAIL(GG_SIMPLEQ_HEAD *head, TYPE *elm, GG_SIMPLEQ_ENTRY NAME);

       GG_SIMPLEQ_INSERT_AFTER(GG_SIMPLEQ_HEAD *head, TYPE *listelm, TYPE *elm,
                  GG_SIMPLEQ_ENTRY NAME);

       GG_SIMPLEQ_REMOVE_HEAD(GG_SIMPLEQ_HEAD *head, GG_SIMPLEQ_ENTRY NAME);

       GG_SIMPLEQ_REMOVE(GG_SIMPLEQ_HEAD *head, TYPE *elm, TYPE, GG_SIMPLEQ_ENTRY NAME);

       GG_SIMPLEQ_FOREACH(TYPE *var, GG_SIMPLEQ_HEAD *head, GG_SIMPLEQ_ENTRY NAME);

       int
       GG_SIMPLEQ_EMPTY(GG_SIMPLEQ_HEAD *head);

       TYPE *
       GG_SIMPLEQ_FIRST(GG_SIMPLEQ_HEAD *head);

       TYPE *
       GG_SIMPLEQ_NEXT(TYPE *elm, GG_SIMPLEQ_ENTRY NAME);

       GG_LIST_HEAD(HEADNAME, TYPE);

       GG_LIST_HEAD_INITIALIZER(head);

       GG_LIST_ENTRY(TYPE);

       GG_LIST_INIT(GG_LIST_HEAD *head);

       GG_LIST_INSERT_AFTER(TYPE *listelm, TYPE *elm, GG_LIST_ENTRY NAME);

       GG_LIST_INSERT_BEFORE(TYPE *listelm, TYPE *elm, GG_LIST_ENTRY NAME);

       GG_LIST_INSERT_HEAD(GG_LIST_HEAD *head, TYPE *elm, GG_LIST_ENTRY NAME);

       GG_LIST_REMOVE(TYPE *elm, GG_LIST_ENTRY NAME);

       GG_LIST_FOREACH(TYPE *var, GG_LIST_HEAD *head, GG_LIST_ENTRY NAME);

       int
       GG_LIST_EMPTY(GG_LIST_HEAD *head);

       TYPE *
       GG_LIST_FIRST(GG_LIST_HEAD *head);

       TYPE *
       GG_LIST_NEXT(TYPE *elm, GG_LIST_ENTRY NAME);

       GG_TAILQ_HEAD(HEADNAME, TYPE);

       GG_TAILQ_HEAD_INITIALIZER(head);

       GG_TAILQ_ENTRY(TYPE);

       GG_TAILQ_INIT(GG_TAILQ_HEAD *head);

       GG_TAILQ_INSERT_HEAD(GG_TAILQ_HEAD *head, TYPE *elm, GG_TAILQ_ENTRY NAME);

       GG_TAILQ_INSERT_TAIL(GG_TAILQ_HEAD *head, TYPE *elm, GG_TAILQ_ENTRY NAME);

       GG_TAILQ_INSERT_AFTER(GG_TAILQ_HEAD *head, TYPE *listelm, TYPE *elm,
                  GG_TAILQ_ENTRY NAME);

       GG_TAILQ_INSERT_BEFORE(TYPE *listelm, TYPE *elm, GG_TAILQ_ENTRY NAME);
&#12;       GG_TAILQ_REMOVE(GG_TAILQ_HEAD *head, TYPE *elm, GG_TAILQ_ENTRY NAME);

       GG_TAILQ_FOREACH(TYPE *var, GG_TAILQ_HEAD *head, GG_TAILQ_ENTRY NAME);

       GG_TAILQ_FOREACH_REVERSE(TYPE *var, GG_TAILQ_HEAD *head, HEADNAME,
                  GG_TAILQ_ENTRY NAME);

       int
       GG_TAILQ_EMPTY(GG_TAILQ_HEAD *head);

       TYPE *
       GG_TAILQ_FIRST(GG_TAILQ_HEAD *head);

       TYPE *
       GG_TAILQ_NEXT(TYPE *elm, GG_TAILQ_ENTRY NAME);

       TYPE *
       GG_TAILQ_LAST(GG_TAILQ_HEAD *head, HEADNAME);

       TYPE *
       GG_TAILQ_PREV(TYPE *elm, HEADNAME, GG_TAILQ_ENTRY NAME);

       GG_CIRCLEQ_HEAD(HEADNAME, TYPE);

       GG_CIRCLEQ_HEAD_INITIALIZER(head);

       GG_CIRCLEQ_ENTRY(TYPE);

       GG_CIRCLEQ_INIT(GG_CIRCLEQ_HEAD *head);

       GG_CIRCLEQ_INSERT_AFTER(GG_CIRCLEQ_HEAD *head, TYPE *listelm, TYPE *elm,
                  GG_CIRCLEQ_ENTRY NAME);

       GG_CIRCLEQ_INSERT_BEFORE(GG_CIRCLEQ_HEAD *head, TYPE *listelm, TYPE *elm,
                  GG_CIRCLEQ_ENTRY NAME);

       GG_CIRCLEQ_INSERT_HEAD(GG_CIRCLEQ_HEAD *head, TYPE *elm, GG_CIRCLEQ_ENTRY NAME);

       GG_CIRCLEQ_INSERT_TAIL(GG_CIRCLEQ_HEAD *head, TYPE *elm, GG_CIRCLEQ_ENTRY NAME);

       GG_CIRCLEQ_REMOVE(GG_CIRCLEQ_HEAD *head, TYPE *elm, GG_CIRCLEQ_ENTRY NAME);

       GG_CIRCLEQ_FOREACH(TYPE *var, GG_CIRCLEQ_HEAD *head, GG_CIRCLEQ_ENTRY NAME);

       GG_CIRCLEQ_FOREACH_REVERSE(TYPE *var, GG_CIRCLEQ_HEAD *head,
                  GG_CIRCLEQ_ENTRY NAME);

       int
       GG_CIRCLEQ_EMPTY(GG_CIRCLEQ_HEAD *head);

       TYPE *
       GG_CIRCLEQ_FIRST(GG_CIRCLEQ_HEAD *head);

       TYPE *
       GG_CIRCLEQ_LAST(GG_CIRCLEQ_HEAD *head);

       TYPE *
       GG_CIRCLEQ_NEXT(TYPE *elm, GG_CIRCLEQ_ENTRY NAME);

       TYPE *
       GG_CIRCLEQ_PREV(TYPE *elm, GG_CIRCLEQ_ENTRY NAME);


DESCRIPTION
       These macros define and operate on five types of data structures: singly-
       linked  lists,  simple  queues,  lists, tail queues, and circular queues.
       All five structures support the following functionality:

       1   Insertion of a new entry at the head of the list.

       2   Insertion of a new entry before or after any element in the list.

       3   Removal of any entry in the list.

       4   Forward traversal through the list.

       Singly-linked lists are the simplest of the five data structures and sup&#8208;
       port  only  the  above  functionality.  Singly-linked lists are ideal for
       applications with large datasets and few or no removals,  or  for  imple&#8208;
       menting a LIFO queue.

       Simple queues add the following functionality:

       1   Entries can be added at the end of a list.

       However:

       1   Entries may not be added before any element in the list.

       2   All list insertions and removals must specify the head of the list.

       3   Each head entry requires two pointers rather than one.

       Simple  queues  are ideal for applications with large datasets and few or
       no removals, or for implementing a FIFO  queue.

       All doubly linked types of data structures (lists, tail queues, and  cir&#8208;
       cle queues) additionally allow:

       1   Insertion of a new entry before any element in the list.

       2   O(1) removal of any entry in the list.

       However:

       1   Each element requires two pointers rather than one.

       2   Code  size  and  execution time of operations (except for removal) is
           about twice that of the singly-linked data-structures.

       Linked lists are the simplest of the doubly linked  data  structures  and
       support only the above functionality over singly-linked lists.

       Tail queues add the following functionality:

       1   Entries can be added at the end of a list.

       However:

       1   All  list  insertions  and  removals, except insertion before another
           element, must specify the head of the list.

       2   Each head entry requires two pointers rather than one.

       3   Code size is about 15% greater and operations run  about  20%  slower
           than lists.

       Circular queues add the following functionality:

       1   Entries can be added at the end of a list.

       2   They may be traversed backwards, from tail to head.
&#12;       However:

       1   All list insertions and removals must specify the head of the list.

       2   Each head entry requires two pointers rather than one.

       3   The termination condition for traversal is more complex.

       4   Code  size  is  about 40% greater and operations run about 45% slower
           than lists.

       In the macro definitions, TYPE is the name of a user  defined  structure,
       that  must  contain  a  field  of  type  GG_LIST_ENTRY, GG_SIMPLEQ_ENTRY,
       GG_SLIST_ENTRY, GG_TAILQ_ENTRY,  or  GG_CIRCLEQ_ENTRY,  named  NAME.  The
       argument  HEADNAME  is  the name of a user defined structure that must be
       declared using the macros GG_LIST_HEAD,  GG_SIMPLEQ_HEAD,  GG_SLIST_HEAD,
       GG_TAILQ_HEAD,  or  GG_CIRCLEQ_HEAD.  See  the examples below for further
       explanation of how these macros are used.

SINGLY-LINKED LISTS
       A singly-linked list is headed by a structure defined by  the  SLIST_HEAD
       macro.  This  structure contains a single pointer to the first element on
       the list. The elements are singly linked for minimum  space  and  pointer
       manipulation  overhead  at the expense of O(n) removal for arbitrary ele&#8208;
       ments.  New elements can be added to the list after an  existing  element
       or  at  the  head of the list.  An GG_SLIST_HEAD structure is declared as
       follows:

       GG_SLIST_HEAD(HEADNAME, TYPE) head;

       where HEADNAME is the name of the structure to be defined,  and  TYPE  is
       the  type  of  the elements to be linked into the list.  A pointer to the
       head of the list can later be declared as:

       struct HEADNAME *headp;

       (The names head and headp are user selectable.)

       The macro GG_SLIST_HEAD_INITIALIZER evaluates to an initializer  for  the
       list head.

       The  macro  GG_SLIST_EMPTY  evaluates to true if there are no elements in
       the list.

       The macro GG_SLIST_ENTRY declares a structure that connects the  elements
       in the list.

       The macro GG_SLIST_FIRST returns the first element in the list or NULL if
       the list is empty.

       The macro GG_SLIST_FOREACH traverses the list referenced by head  in  the
       forward direction, assigning each element in turn to var.

       The macro GG_SLIST_INIT initializes the list referenced by head.

       The macro GG_SLIST_INSERT_HEAD inserts the new element elm at the head of
       the list.

       The macro GG_SLIST_INSERT_AFTER inserts the new  element  elm  after  the
       element listelm.

       The macro GG_SLIST_NEXT returns the next element in the list.

       The macro GG_SLIST_REMOVE removes the element elm from the list.

       The macro GG_SLIST_REMOVE_HEAD removes the first element from the head of
       the list.  For optimum efficiency, elements being removed from  the  head
       of  the  list  should  explicitly  use  this macro instead of the generic
       GG_SLIST_REMOVE macro.

SINGLY-LINKED LIST EXAMPLE
       GG_SLIST_HEAD(slisthead, entry) head =
           GG_SLIST_HEAD_INITIALIZER(head);
       struct slisthead *headp;                /* Singly-linked List head. */
       struct entry {
               ...
               GG_SLIST_ENTRY(entry) entries;  /* Singly-linked List. */
               ...
       } *n1, *n2, *n3, *np;

       GG_SLIST_INIT(&amp;head);                   /* Initialize the list. */

       n1 = malloc(sizeof(struct entry));      /* Insert at the head. */
       GG_SLIST_INSERT_HEAD(&amp;head, n1, entries);

       n2 = malloc(sizeof(struct entry));      /* Insert after. */
       GG_SLIST_INSERT_AFTER(n1, n2, entries);

       GG_SLIST_REMOVE(&amp;head, n2, entry, entries);/* Deletion. */
       free(n2);

       n3 = GG_SLIST_FIRST(&amp;head);
       GG_SLIST_REMOVE_HEAD(&amp;head, entries);   /* Deletion from the head. */
       free(n3);
                                               /* Forward traversal. */
       GG_SLIST_FOREACH(np, &amp;head, entries)
               np-&gt; ...

       while (!GG_SLIST_EMPTY(&amp;head)) {        /* List Deletion. */
               n1 = GG_SLIST_FIRST(&amp;head);
               GG_SLIST_REMOVE_HEAD(&amp;head, entries);
               free(n1);
       }


SIMPLE QUEUES
       A simple queue is headed by a structure defined  by  the  GG_SIMPLEQ_HEAD
       macro.  This structure contains a pair of pointers, one to the first ele&#8208;
       ment in the simple queue and the other to the last element in the  simple
       queue.   The  elements  are  singly  linked for minimum space and pointer
       manipulation overhead at the expense of O(n) removal for  arbitrary  ele&#8208;
       ments.  New elements can be added to the queue after an existing element,
       at the head of the queue, or at the end of the queue.  A  GG_SIMPLEQ_HEAD
       structure is declared as follows:

       GG_SIMPLEQ_HEAD(HEADNAME, TYPE) head;

       where  HEADNAME  is  the name of the structure to be defined, and TYPE is
       the type of the elements to be linked into the simple queue.   A  pointer
       to the head of the simple queue can later be declared as:

       struct HEADNAME *headp;

       (The names head and headp are user selectable.)

       The  macro  GG_SIMPLEQ_ENTRYk declares a structure that connects the ele&#8208;
       ments in the simple queue.

       The macro GG_SIMPLEQ_HEAD_INITIALIZER provides a value which can be  used
       to  initialize  a  simple  queue head at compile time, and is used at the
       point that the simple queue head variable is declared, like:

       struct HEADNAME head = GG_SIMPLEQ_HEAD_INITIALIZER(head);
&#12;       The macro GG_SIMPLEQ_INIT initializes  the  simple  queue  referenced  by
       head.

       The  macro GG_SIMPLEQ_INSERT_HEAD inserts the new element elm at the head
       of the simple queue.

       The macro GG_SIMPLEQ_INSERT_TAIL inserts the new element elm at  the  end
       of the simple queue.

       The  macro  GG_SIMPLEQ_INSERT_AFTER inserts the new element elm after the
       ele- ment listelm.

       The macro GG_SIMPLEQ_REMOVE removes elm from the simple queue.

       The macro GG_SIMPLEQ_REMOVE_HEAD removes the first element from the  head
       of the simple queue.  For optimum efficiency, elements being removed from
       the head of the queue should explicitly use this  macro  instead  of  the
       generic GG_SIMPLQ_REMOVE macro.

       The  macro  GG_SIMPLEQ_EMPTY  return true if the simple queue head has no
       elements.

       The macro GG_SIMPLEQ_FIRST returns the first element of the simple  queue
       head.

       The  macro GG_SIMPLEQ_FOREACH traverses the tail queue referenced by head
       in the forward direction, assigning each element in turn to var.

       The macro GG_SIMPLEQ_NEXT returns the element after the element elm.

SIMPLE QUEUE EXAMPLE
       GG_SIMPLEQ_HEAD(simplehead, entry) head;
       struct simplehead *headp;               /* Simple queue head. */
       struct entry {
               ...
               GG_SIMPLEQ_ENTRY(entry) entries;/* Simple queue. */
               ...
       } *n1, *n2, *np;

       GG_SIMPLEQ_INIT(&amp;head);                 /* Initialize the queue. */

       n1 = malloc(sizeof(struct entry));      /* Insert at the head. */
       GG_SIMPLEQ_INSERT_HEAD(&amp;head, n1, entries);

       n1 = malloc(sizeof(struct entry));      /* Insert at the tail. */
       GG_SIMPLEQ_INSERT_TAIL(&amp;head, n1, entries);

       n2 = malloc(sizeof(struct entry));      /* Insert after. */
       GG_SIMPLEQ_INSERT_AFTER(&amp;head, n1, n2, entries);
                                               /* Forward traversal. */
       GG_SIMPLEQ_FOREACH(np, &amp;head, entries)
               np-&gt; ...
                                               /* Delete. */
       while (GG_SIMPLEQ_FIRST(&amp;head) != NULL)
               GG_SIMPLEQ_REMOVE_HEAD(&amp;head, entries);
       if (GG_SIMPLEQ_EMPTY(&amp;head))            /* Test for emptiness. */
               printf(&quot;nothing to do\n&quot;);


LISTS
       A list is headed by a structure defined by the GG_LIST_HEAD macro.   This
       structure  contains  a  single  pointer to the first element on the list.
       The elements are doubly linked  so  that  an  arbitrary  element  can  be
       removed  without  traversing  the list.  New elements can be added to the
       list after an existing element, before an existing  element,  or  at  the
       head of the list. A LIST_HEAD structure is declared as follows:
&#12;       GG_LIST_HEAD(HEADNAME, TYPE) head;

       where  HEADNAME  is  the name of the structure to be defined, and TYPE is
       the type of the elements to be linked into the list.  A  pointer  to  the
       head of the list can later be declared as:

       struct HEADNAME *headp;

       (The names head and headp are user selectable.)

       The  macro  GG_LIST_ENTRY declares a structure that connects the elements
       in the list.

       The macro GG_LIST_HEAD_INITIALIZER provides a value which can be used  to
       initialize a list head at compile time, and is used at the point that the
       list head variable is declared, like:

       struct HEADNAME head = GG_LIST_HEAD_INITIALIZER(head);

       The macro GG_LIST_INIT initializes the list referenced by head.

       The macro GG_LIST_INSERT_HEAD inserts the new element elm at the head  of
       the list.

       The macro GG_LIST_INSERT_AFTER inserts the new element elm after the ele&#8208;
       ment listelm.

       The macro GG_LIST_INSERT_BEFORE inserts the new element  elm  before  the
       element listelm.

       The macro GG_LIST_REMOVE removes the element elm from the list.

       The macro GG_LIST_EMPTY return true if the list head has no elements.

       The macro GG_LIST_FIRST returns the first element of the list head.

       The  macro  GG_LIST_FOREACH  traverses the list referenced by head in the
       forward direction, assigning each element in turn to var.

       The macro GG_LIST_NEXT returns the element after the element elm.

LIST EXAMPLE
       GG_LIST_HEAD(listhead, entry) head;
       struct listhead *headp;                 /* List head. */
       struct entry {
               ...
               GG_LIST_ENTRY(entry) entries;   /* List. */
               ...
       } *n1, *n2, *np;

       GG_LIST_INIT(&amp;head);                    /* Initialize the list. */

       n1 = malloc(sizeof(struct entry));      /* Insert at the head. */
       GG_LIST_INSERT_HEAD(&amp;head, n1, entries);

       n2 = malloc(sizeof(struct entry));      /* Insert after. */
       GG_LIST_INSERT_AFTER(n1, n2, entries);

       n2 = malloc(sizeof(struct entry));      /* Insert before. */
       GG_LIST_INSERT_BEFORE(n1, n2, entries);
                                               /* Forward traversal. */
       GG_LIST_FOREACH(np, &amp;head, entries)
               np-&gt; ...
                                               /* Delete. */
       while (GG_LIST_FIRST(&amp;head) != NULL)
               GG_LIST_REMOVE(LIST_FIRST(&amp;head), entries);
       if (GG_LIST_EMPTY(&amp;head))               /* Test for emptiness. */
               printf(&quot;nothing to do\n&quot;);


TAIL QUEUES
       A tail queue is headed by a structure defined by the GG_TAILQ_HEAD macro.
       This  structure  contains a pair of pointers, one to the first element in
       the tail queue and the other to the last element in the tail  queue.  The
       elements  are  doubly  linked so that an arbitrary element can be removed
       without traversing the tail queue. New elements can be added to the queue
       after an existing element, before an existing element, at the head of the
       queue, or at the end the queue. A GG_TAILQ_HEAD structure is declared  as
       follows:

       TAILQ_HEAD(HEADNAME, TYPE) head;

       where  HEADNAME  is  the name of the structure to be defined, and TYPE is
       the type of the elements to be linked into the tail queue.  A pointer  to
       the head of the tail queue can later be declared as:

       struct HEADNAME *headp;

       (The names head and headp are user selectable.)

       The  macro GG_TAILQ_ENTRY declares a structure that connects the elements
       in the tail queue.

       The macro GG_TAILQ_HEAD_INITIALIZER provides a value which can be used to
       initialize  a  tail  queue head at compile time, and is used at the point
       that the tail queue head variable is declared, like:

       struct HEADNAME head = GG_TAILQ_HEAD_INITIALIZER(head);

       The macro GG_TAILQ_INIT initializes the tail queue referenced by head.

       The macro GG_TAILQ_INSERT_HEAD inserts the new element elm at the head of
       the tail queue.

       The  macro GG_TAILQ_INSERT_TAIL inserts the new element elm at the end of
       the tail queue.

       The macro GG_TAILQ_INSERT_AFTER inserts the new  element  elm  after  the
       element listelm.

       The  macro  GG_TAILQ_INSERT_BEFORE inserts the new element elm before the
       element listelm.

       The macro GG_TAILQ_REMOVE removes the element elm from the tail queue.

       The macro GG_TAILQ_EMPTY return true if the tail queue head has  no  ele&#8208;
       ments.

       The  macro  GG_TAILQ_FIRST  returns  the  first element of the tail queue
       head.

       The macro GG_TAILQ_FOREACH traverses the tail queue referenced by head in
       the forward direction, assigning each element in turn to var.

       The macro GG_TAILQ_FOREACH_REVERSE traverses the tail queue referenced by
       head in the reverse direction, assigning each element in turn to var.

       The macro GG_TAILQ_NEXT returns the element after the element elm

TAIL QUEUE EXAMPLE
       GG_TAILQ_HEAD(tailhead, entry) head;
       struct tailhead *headp;                 /* Tail queue head. */
       struct entry {
               ...
               GG_TAILQ_ENTRY(entry) entries;  /* Tail queue. */
               ...
       } *n1, *n2, *np;

       GG_TAILQ_INIT(&amp;head);                   /* Initialize the queue. */

       n1 = malloc(sizeof(struct entry));      /* Insert at the head. */
       GG_TAILQ_INSERT_HEAD(&amp;head, n1, entries);

       n1 = malloc(sizeof(struct entry));      /* Insert at the tail. */
       GG_TAILQ_INSERT_TAIL(&amp;head, n1, entries);

       n2 = malloc(sizeof(struct entry));      /* Insert after. */
       GG_TAILQ_INSERT_AFTER(&amp;head, n1, n2, entries);

       n2 = malloc(sizeof(struct entry));      /* Insert before. */
       GG_TAILQ_INSERT_BEFORE(n1, n2, entries);
                                               /* Forward traversal. */
       GG_TAILQ_FOREACH(np, &amp;head, entries)
               np-&gt; ...
                                               /* Reverse traversal. */
       GG_TAILQ_FOREACH_REVERSE(np, &amp;head, tailhead, entries)
               np-&gt; ...
                                               /* Delete. */
       while (GG_TAILQ_FIRST(&amp;head) != NULL)
               GG_TAILQ_REMOVE(&amp;head, GG_TAILQ_FIRST(&amp;head), entries);
       if (GG_TAILQ_EMPTY(&amp;head))              /* Test for emptiness. */
               printf(&quot;nothing to do\n&quot;);


CIRCULAR QUEUES
       A circular queue is headed by a structure defined by the  GG_CIRCLEQ_HEAD
       macro.  This structure contains a pair of pointers, one to the first ele&#8208;
       ment in the circular queue and the other to the last element in the  cir&#8208;
       cular queue.  The elements are doubly linked so that an arbitrary element
       can be removed without traversing the queue.  New elements can  be  added
       to  the  queue  after an existing element, before an existing element, at
       the head of the queue, or at the end of  the  queue.   A  GG_CIRCLEQ_HEAD
       structure is declared as follows:

       GG_CIRCLEQ_HEAD(HEADNAME, TYPE) head;

       where  HEADNAME  is  the name of the structure to be defined, and TYPE is
       the type of the elements to be linked into the circular queue.  A pointer
       to the head of the circular queue can later be declared as:

       struct HEADNAME *headp;

       (The names head and headp are user selectable.)

       The  macro  GG_CIRCLEQ_ENTRY  declares a structure that connects the ele&#8208;
       ments in the circular queue.

       The macro GG_CIRCLEQ_HEAD_INITIALIZER provides a value which can be  used
       to  initialize  a circular queue head at compile time, and is used at the
       point that the circular queue head variable is declared, like:

       struct HEADNAME head = GG_CIRCLEQ_HEAD_INITIALIZER(head);

       The macro GG_CIRCLEQ_INIT initializes the circular  queue  referenced  by
       head.

       The  macro GG_CIRCLEQ_INSERT_HEAD inserts the new element elm at the head
       of the circular queue.

       The macro GG_CIRCLEQ_INSERT_TAIL inserts the new element elm at  the  end
       of the circular queue.

       The  macro  GG_CIRCLEQ_INSERT_AFTER inserts the new element elm after the
       element listelm.

       The macro GG_CIRCLEQ_INSERT_BEFORE inserts the new element elm before the
       element listelm.

       The  macro  GG_CIRCLEQ_REMOVE  removes  the element elm from the circular
       queue.

       The macro GG_CIRCLEQ_EMPTY return true if the circular queue head has  no
       elements.

       The  macro  GG_CIRCLEQ_FIRST  returns  the  first element of the circular
       queue head.

       The macro GG_CICRLEQ_FOREACH traverses the  circle  queue  referenced  by
       head in the forward direction, assigning each element in turn to var.

       The  macro  GG_CICRLEQ_FOREACH_REVERSE  traverses the circle queue refer&#8208;
       enced by head in the reverse direction, assigning each element in turn to
       var.

       The  macro GG_CIRCLEQ_LAST returns the last element of the circular queue
       head.

       The macro GG_CIRCLEQ_NEXT returns the element after the element elm.

       The macro GG_CIRCLEQ_PREV returns the element before the element elm.

CIRCULAR QUEUE EXAMPLE
       GG_CIRCLEQ_HEAD(circleq, entry) head;
       struct circleq *headp;                  /* Circular queue head. */
       struct entry {
              ...
              GG_CIRCLEQ_ENTRY(entry) entries; /* Circular queue. */
              ...
       } *n1, *n2, *np;

       GG_CIRCLEQ_INIT(&amp;head);                 /* Initialize the circular queue. */

       n1 = malloc(sizeof(struct entry));      /* Insert at the head. */
       GG_CIRCLEQ_INSERT_HEAD(&amp;head, n1, entries);

       n1 = malloc(sizeof(struct entry));      /* Insert at the tail. */
       GG_CIRCLEQ_INSERT_TAIL(&amp;head, n1, entries);

       n2 = malloc(sizeof(struct entry));      /* Insert after. */
       GG_CIRCLEQ_INSERT_AFTER(&amp;head, n1, n2, entries);

       n2 = malloc(sizeof(struct entry));      /* Insert before. */
       GG_CIRCLEQ_INSERT_BEFORE(&amp;head, n1, n2, entries);
                                               /* Forward traversal. */
       GG_CIRCLEQ_FOREACH(np, &amp;head, entries)
               np-&gt; ...
                                               /* Reverse traversal. */
       GG_CIRCLEQ_FOREACH_REVERSE(np, &amp;head, entries)
               np-&gt; ...
                                               /* Delete. */
       while (GG_CIRCLEQ_FIRST(&amp;head) != (void *)&amp;head)
               GG_CIRCLEQ_REMOVE(&amp;head, GG_CIRCLEQ_FIRST(&amp;head), entries);
       if (GG_CIRCLEQ_EMPTY(&amp;head))            /* Test for emptiness. */
               printf(&quot;nothing to do\n&quot;);


SEE ALSO
       gg-tree(3)



libgg-1.0.x                        2005-08-26                        gg-queue(3)

</pre></body></html>
