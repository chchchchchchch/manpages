<html>
<head><meta charset=utf-8/>
<title>Git - Perl interface to the Git version control system</title></head>
<body><pre>

Git(3pm)               User Contributed Perl Documentation              Git(3pm)



NAME
       Git - Perl interface to the Git version control system

SYNOPSIS
         use Git;

         my $version = Git::command_oneline(&apos;version&apos;);

         git_cmd_try { Git::command_noisy(&apos;update-server-info&apos;) }
                     &apos;%s failed w/ code %d&apos;;

         my $repo = Git-&gt;repository (Directory =&gt; &apos;/srv/git/cogito.git&apos;);


         my @revs = $repo-&gt;command(&apos;rev-list&apos;, &apos;--since=last monday&apos;, &apos;--all&apos;);

         my ($fh, $c) = $repo-&gt;command_output_pipe(&apos;rev-list&apos;, &apos;--since=last monday&apos;, &apos;--all&apos;);
         my $lastrev = &lt;$fh&gt;; chomp $lastrev;
         $repo-&gt;command_close_pipe($fh, $c);

         my $lastrev = $repo-&gt;command_oneline( [ &apos;rev-list&apos;, &apos;--all&apos; ],
                                               STDERR =&gt; 0 );

         my $sha1 = $repo-&gt;hash_and_insert_object(&apos;file.txt&apos;);
         my $tempfile = tempfile();
         my $size = $repo-&gt;cat_blob($sha1, $tempfile);

DESCRIPTION
       This module provides Perl scripts easy way to interface the Git version
       control system. The modules have an easy and well-tested way to call
       arbitrary Git commands; in the future, the interface will also provide
       specialized methods for doing easily operations which are not totally
       trivial to do over the generic command interface.

       While some commands can be executed outside of any context (e.g.
       &apos;version&apos; or &apos;init&apos;), most operations require a repository context, which
       in practice means getting an instance of the Git object using the
       repository() constructor.  (In the future, we will also get a
       new_repository() constructor.) All commands called as methods of the
       object are then executed in the context of the repository.

       Part of the &quot;repository state&quot; is also information about path to the
       attached working copy (unless you work with a bare repository). You can
       also navigate inside of the working copy using the &quot;wc_chdir()&quot; method.
       (Note that the repository object is self-contained and will not change
       working directory of your process.)

       TODO: In the future, we might also do

               my $remoterepo = $repo-&gt;remote_repository (Name =&gt; &apos;cogito&apos;, Branch =&gt; &apos;master&apos;);
               $remoterepo ||= Git-&gt;remote_repository (&apos;http://git.or.cz/cogito.git/&apos;);
               my @refs = $remoterepo-&gt;refs();

       Currently, the module merely wraps calls to external Git tools. In the
       future, it will provide a much faster way to interact with Git by linking
       directly to libgit. This should be completely opaque to the user, though
       (performance increase notwithstanding).

CONSTRUCTORS
       repository ( OPTIONS )
       repository ( DIRECTORY )
       repository ()
           Construct a new repository object.  &quot;OPTIONS&quot; are passed in a hash
           like fashion, using key and value pairs.  Possible options are:

           Repository - Path to the Git repository.

           WorkingCopy - Path to the associated working copy; not strictly
           required as many commands will happily crunch on a bare repository.

           WorkingSubdir - Subdirectory in the working copy to work inside.
           Just left undefined if you do not want to limit the scope of
           operations.

           Directory - Path to the Git working directory in its usual setup.
           The &quot;.git&quot; directory is searched in the directory and all the parent
           directories; if found, &quot;WorkingCopy&quot; is set to the directory
           containing it and &quot;Repository&quot; to the &quot;.git&quot; directory itself. If no
           &quot;.git&quot; directory was found, the &quot;Directory&quot; is assumed to be a bare
           repository, &quot;Repository&quot; is set to point at it and &quot;WorkingCopy&quot; is
           left undefined.  If the $GIT_DIR environment variable is set, things
           behave as expected as well.

           You should not use both &quot;Directory&quot; and either of &quot;Repository&quot; and
           &quot;WorkingCopy&quot; - the results of that are undefined.

           Alternatively, a directory path may be passed as a single scalar
           argument to the constructor; it is equivalent to setting only the
           &quot;Directory&quot; option field.

           Calling the constructor with no options whatsoever is equivalent to
           calling it with &quot;Directory =&gt; &apos;.&apos;&quot;. In general, if you are building a
           standard porcelain command, simply doing &quot;Git-&gt;repository()&quot; should
           do the right thing and setup the object to reflect exactly where the
           user is right now.

METHODS
       command ( COMMAND [, ARGUMENTS... ] )
       command ( [ COMMAND, ARGUMENTS... ], { Opt =&gt; Val ... } )
           Execute the given Git &quot;COMMAND&quot; (specify it without the &apos;git-&apos;
           prefix), optionally with the specified extra &quot;ARGUMENTS&quot;.

           The second more elaborate form can be used if you want to further
           adjust the command execution. Currently, only one option is
           supported:

           STDERR - How to deal with the command&apos;s error output. By default
           (&quot;undef&quot;) it is delivered to the caller&apos;s &quot;STDERR&quot;. A false value (0
           or &apos;&apos;) will cause it to be thrown away. If you want to process it,
           you can get it in a filehandle you specify, but you must be extremely
           careful; if the error output is not very short and you want to read
           it in the same process as where you called &quot;command()&quot;, you are set
           up for a nice deadlock!

           The method can be called without any instance or on a specified Git
           repository (in that case the command will be run in the repository
           context).

           In scalar context, it returns all the command output in a single
           string (verbatim).

           In array context, it returns an array containing lines printed to the
           command&apos;s stdout (without trailing newlines).

           In both cases, the command&apos;s stdin and stderr are the same as the
           caller&apos;s.

       command_oneline ( COMMAND [, ARGUMENTS... ] )
       command_oneline ( [ COMMAND, ARGUMENTS... ], { Opt =&gt; Val ... } )
           Execute the given &quot;COMMAND&quot; in the same way as command() does but
           always return a scalar string containing the first line of the
           command&apos;s standard output.

       command_output_pipe ( COMMAND [, ARGUMENTS... ] )
       command_output_pipe ( [ COMMAND, ARGUMENTS... ], { Opt =&gt; Val ... } )
           Execute the given &quot;COMMAND&quot; in the same way as command() does but
           return a pipe filehandle from which the command output can be read.

           The function can return &quot;($pipe, $ctx)&quot; in array context.  See
           &quot;command_close_pipe()&quot; for details.

       command_input_pipe ( COMMAND [, ARGUMENTS... ] )
       command_input_pipe ( [ COMMAND, ARGUMENTS... ], { Opt =&gt; Val ... } )
           Execute the given &quot;COMMAND&quot; in the same way as command_output_pipe()
           does but return an input pipe filehandle instead; the command output
           is not captured.

           The function can return &quot;($pipe, $ctx)&quot; in array context.  See
           &quot;command_close_pipe()&quot; for details.

       command_close_pipe ( PIPE [, CTX ] )
           Close the &quot;PIPE&quot; as returned from &quot;command_*_pipe()&quot;, checking
           whether the command finished successfully. The optional &quot;CTX&quot;
           argument is required if you want to see the command name in the error
           message, and it is the second value returned by &quot;command_*_pipe()&quot;
           when called in array context. The call idiom is:

                   my ($fh, $ctx) = $r-&gt;command_output_pipe(&apos;status&apos;);
                   while (&lt;$fh&gt;) { ... }
                   $r-&gt;command_close_pipe($fh, $ctx);

           Note that you should not rely on whatever actually is in &quot;CTX&quot;;
           currently it is simply the command name but in future the context
           might have more complicated structure.

       command_bidi_pipe ( COMMAND [, ARGUMENTS... ] )
           Execute the given &quot;COMMAND&quot; in the same way as command_output_pipe()
           does but return both an input pipe filehandle and an output pipe
           filehandle.

           The function will return return &quot;($pid, $pipe_in, $pipe_out, $ctx)&quot;.
           See &quot;command_close_bidi_pipe()&quot; for details.

       command_close_bidi_pipe ( PID, PIPE_IN, PIPE_OUT [, CTX] )
           Close the &quot;PIPE_IN&quot; and &quot;PIPE_OUT&quot; as returned from
           &quot;command_bidi_pipe()&quot;, checking whether the command finished
           successfully. The optional &quot;CTX&quot; argument is required if you want to
           see the command name in the error message, and it is the fourth value
           returned by &quot;command_bidi_pipe()&quot;.  The call idiom is:

                   my ($pid, $in, $out, $ctx) = $r-&gt;command_bidi_pipe(&apos;cat-file --batch-check&apos;);
                   print &quot;000000000\n&quot; $out;
                   while (&lt;$in&gt;) { ... }
                   $r-&gt;command_close_bidi_pipe($pid, $in, $out, $ctx);

           Note that you should not rely on whatever actually is in &quot;CTX&quot;;
           currently it is simply the command name but in future the context
           might have more complicated structure.

       command_noisy ( COMMAND [, ARGUMENTS... ] )
           Execute the given &quot;COMMAND&quot; in the same way as command() does but do
           not capture the command output - the standard output is not
           redirected and goes to the standard output of the caller application.

           While the method is called command_noisy(), you might want to as well
           use it for the most silent Git commands which you know will never
           pollute your stdout but you want to avoid the overhead of the pipe
           setup when calling them.

           The function returns only after the command has finished running.

       version ()
           Return the Git version in use.

       exec_path ()
           Return path to the Git sub-command executables (the same as &quot;git
           --exec-path&quot;). Useful mostly only internally.

       html_path ()
           Return path to the Git html documentation (the same as &quot;git
           --html-path&quot;). Useful mostly only internally.

       repo_path ()
           Return path to the git repository. Must be called on a repository
           instance.

       wc_path ()
           Return path to the working copy. Must be called on a repository
           instance.

       wc_subdir ()
           Return path to the subdirectory inside of a working copy. Must be
           called on a repository instance.

       wc_chdir ( SUBDIR )
           Change the working copy subdirectory to work within. The &quot;SUBDIR&quot; is
           relative to the working copy root directory (not the current
           subdirectory).  Must be called on a repository instance attached to a
           working copy and the directory must exist.

       config ( VARIABLE )
           Retrieve the configuration &quot;VARIABLE&quot; in the same manner as &quot;config&quot;
           does. In scalar context requires the variable to be set only one time
           (exception is thrown otherwise), in array context returns allows the
           variable to be set multiple times and returns all the values.

       config_bool ( VARIABLE )
           Retrieve the bool configuration &quot;VARIABLE&quot;. The return value is
           usable as a boolean in perl (and &quot;undef&quot; if it&apos;s not defined, of
           course).

       config_path ( VARIABLE )
           Retrieve the path configuration &quot;VARIABLE&quot;. The return value is an
           expanded path or &quot;undef&quot; if it&apos;s not defined.

       config_int ( VARIABLE )
           Retrieve the integer configuration &quot;VARIABLE&quot;. The return value is
           simple decimal number.  An optional value suffix of &apos;k&apos;, &apos;m&apos;, or &apos;g&apos;
           in the config file will cause the value to be multiplied by 1024,
           1048576 (1024^2), or 1073741824 (1024^3) prior to output.  It would
           return &quot;undef&quot; if configuration variable is not defined,

       get_colorbool ( NAME )
           Finds if color should be used for NAMEd operation from the
           configuration, and returns boolean (true for &quot;use color&quot;, false for
           &quot;do not use color&quot;).

       get_color ( SLOT, COLOR )
           Finds color for SLOT from the configuration, while defaulting to
           COLOR, and returns the ANSI color escape sequence:

                   print $repo-&gt;get_color(&quot;color.interactive.prompt&quot;, &quot;underline blue white&quot;);
                   print &quot;some text&quot;;
                   print $repo-&gt;get_color(&quot;&quot;, &quot;normal&quot;);

       remote_refs ( REPOSITORY [, GROUPS [, REFGLOBS ] ] )
           This function returns a hashref of refs stored in a given remote
           repository.  The hash is in the format &quot;refname =\&quot; hash&gt;. For tags,
           the &quot;refname&quot; entry contains the tag object while a &quot;refname^{}&quot;
           entry gives the tagged objects.

           &quot;REPOSITORY&quot; has the same meaning as the appropriate &quot;git-ls-remote&quot;
           argument; either a URL or a remote name (if called on a repository
           instance).  &quot;GROUPS&quot; is an optional arrayref that can contain &apos;tags&apos;
           to return all the tags and/or &apos;heads&apos; to return all the heads.
           &quot;REFGLOB&quot; is an optional array of strings containing a shell-like
           glob to further limit the refs returned in the hash; the meaning is
           again the same as the appropriate &quot;git-ls-remote&quot; argument.

           This function may or may not be called on a repository instance. In
           the former case, remote names as defined in the repository are
           recognized as repository specifiers.

       ident ( TYPE | IDENTSTR )
       ident_person ( TYPE | IDENTSTR | IDENTARRAY )
           This suite of functions retrieves and parses ident information, as
           stored in the commit and tag objects or produced by &quot;var
           GIT_type_IDENT&quot; (thus &quot;TYPE&quot; can be either author or committer; case
           is insignificant).

           The &quot;ident&quot; method retrieves the ident information from &quot;git var&quot; and
           either returns it as a scalar string or as an array with the fields
           parsed.  Alternatively, it can take a prepared ident string (e.g.
           from the commit object) and just parse it.

           &quot;ident_person&quot; returns the person part of the ident - name and email;
           it can take the same arguments as &quot;ident&quot; or the array returned by
           &quot;ident&quot;.

           The synopsis is like:

                   my ($name, $email, $time_tz) = ident(&apos;author&apos;);
                   &quot;$name &lt;$email&gt;&quot; eq ident_person(&apos;author&apos;);
                   &quot;$name &lt;$email&gt;&quot; eq ident_person($name);
                   $time_tz =~ /^\d+ [+-]\d{4}$/;

       hash_object ( TYPE, FILENAME )
           Compute the SHA1 object id of the given &quot;FILENAME&quot; considering it is
           of the &quot;TYPE&quot; object type (&quot;blob&quot;, &quot;commit&quot;, &quot;tree&quot;).

           The method can be called without any instance or on a specified Git
           repository, it makes zero difference.

           The function returns the SHA1 hash.

       hash_and_insert_object ( FILENAME )
           Compute the SHA1 object id of the given &quot;FILENAME&quot; and add the object
           to the object database.

           The function returns the SHA1 hash.

       cat_blob ( SHA1, FILEHANDLE )
           Prints the contents of the blob identified by &quot;SHA1&quot; to &quot;FILEHANDLE&quot;
           and returns the number of bytes printed.

       temp_acquire ( NAME )
           Attempts to retreive the temporary file mapped to the string &quot;NAME&quot;.
           If an associated temp file has not been created this session or was
           closed, it is created, cached, and set for autoflush and binmode.

           Internally locks the file mapped to &quot;NAME&quot;. This lock must be
           released with &quot;temp_release()&quot; when the temp file is no longer
           needed. Subsequent attempts to retrieve temporary files mapped to the
           same &quot;NAME&quot; while still locked will cause an error. This locking
           mechanism provides a weak guarantee and is not threadsafe. It does
           provide some error checking to help prevent temp file refs writing
           over one another.

           In general, the File::Handle returned should not be closed by
           consumers as it defeats the purpose of this caching mechanism. If you
           need to close the temp file handle, then you should use File::Temp or
           another temp file faculty directly. If a handle is closed and then
           requested again, then a warning will issue.

       temp_release ( NAME )
       temp_release ( FILEHANDLE )
           Releases a lock acquired through &quot;temp_acquire()&quot;. Can be called
           either with the &quot;NAME&quot; mapping used when acquiring the temp file or
           with the &quot;FILEHANDLE&quot; referencing a locked temp file.

           Warns if an attempt is made to release a file that is not locked.

           The temp file will be truncated before being released. This can help
           to reduce disk I/O where the system is smart enough to detect the
           truncation while data is in the output buffers. Beware that after the
           temp file is released and truncated, any operations on that file may
           fail miserably until it is re-acquired. All contents are lost between
           each release and acquire mapped to the same string.

       temp_reset ( FILEHANDLE )
           Truncates and resets the position of the &quot;FILEHANDLE&quot;.

       temp_path ( NAME )
       temp_path ( FILEHANDLE )
           Returns the filename associated with the given tempfile.

ERROR HANDLING
       All functions are supposed to throw Perl exceptions in case of errors.
       See the Error module on how to catch those. Most exceptions are mere
       Error::Simple instances.

       However, the &quot;command()&quot;, &quot;command_oneline()&quot; and &quot;command_noisy()&quot;
       functions suite can throw &quot;Git::Error::Command&quot; exceptions as well: those
       are thrown when the external command returns an error code and contain
       the error code as well as access to the captured command&apos;s output. The
       exception class provides the usual &quot;stringify&quot; and &quot;value&quot; (command&apos;s
       exit code) methods and in addition also a &quot;cmd_output&quot; method that
       returns either an array or a string with the captured command output
       (depending on the original function call context; &quot;command_noisy()&quot;
       returns &quot;undef&quot;) and $&lt;cmdline&gt; which returns the command and its
       arguments (but without proper quoting).

       Note that the &quot;command_*_pipe()&quot; functions cannot throw this exception
       since it has no idea whether the command failed or not. You will only
       find out at the time you &quot;close&quot; the pipe; if you want to have that
       automated, use &quot;command_close_pipe()&quot;, which can throw the exception.

       git_cmd_try { CODE } ERRMSG
           This magical statement will automatically catch any
           &quot;Git::Error::Command&quot; exceptions thrown by &quot;CODE&quot; and make your
           program die with &quot;ERRMSG&quot; on its lips; the message will have %s
           substituted for the command line and %d for the exit status. This
           statement is useful mostly for producing more user-friendly error
           messages.

           In case of no exception caught the statement returns &quot;CODE&quot;&apos;s return
           value.

           Note that this is the only auto-exported function.

COPYRIGHT
       Copyright 2006 by Petr Baudis &lt;pasky@suse.cz&gt;.

       This module is free software; it may be used, copied, modified and
       distributed under the terms of the GNU General Public Licence, either
       version 2, or (at your option) any later version.



perl v5.14.2                       2012-06-03                           Git(3pm)

</pre></body></html>
