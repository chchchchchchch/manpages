<html>
<head><meta charset=utf-8/>
<title>HTML::Element - Class for objects that represent HTML elements</title></head>
<body><pre>

HTML::Element(3pm)     User Contributed Perl Documentation    HTML::Element(3pm)



NAME
       HTML::Element - Class for objects that represent HTML elements

VERSION
       This document describes version 5.02 of HTML::Element, released June 27,
       2012 as part of HTML-Tree.

SYNOPSIS
           use HTML::Element;
           $a = HTML::Element-&gt;new(&apos;a&apos;, href =&gt; &apos;http://www.perl.com/&apos;);
           $a-&gt;push_content(&quot;The Perl Homepage&quot;);

           $tag = $a-&gt;tag;
           print &quot;$tag starts out as:&quot;,  $a-&gt;starttag, &quot;\n&quot;;
           print &quot;$tag ends as:&quot;,  $a-&gt;endtag, &quot;\n&quot;;
           print &quot;$tag\&apos;s href attribute is: &quot;, $a-&gt;attr(&apos;href&apos;), &quot;\n&quot;;

           $links_r = $a-&gt;extract_links();
           print &quot;Hey, I found &quot;, scalar(@$links_r), &quot; links.\n&quot;;

           print &quot;And that, as HTML, is: &quot;, $a-&gt;as_HTML, &quot;\n&quot;;
           $a = $a-&gt;delete;

DESCRIPTION
       (This class is part of the HTML::Tree dist.)

       Objects of the HTML::Element class can be used to represent elements of
       HTML document trees.  These objects have attributes, notably attributes
       that designates each element&apos;s parent and content.  The content is an
       array of text segments and other HTML::Element objects.  A tree with
       HTML::Element objects as nodes can represent the syntax tree for a HTML
       document.

HOW WE REPRESENT TREES
       Consider this HTML document:

         &lt;html lang=&apos;en-US&apos;&gt;
           &lt;head&gt;
             &lt;title&gt;Stuff&lt;/title&gt;
             &lt;meta name=&apos;author&apos; content=&apos;Jojo&apos;&gt;
           &lt;/head&gt;
           &lt;body&gt;
            &lt;h1&gt;I like potatoes!&lt;/h1&gt;
           &lt;/body&gt;
         &lt;/html&gt;

       Building a syntax tree out of it makes a tree-structure in memory that
       could be diagrammed as:

                            html (lang=&apos;en-US&apos;)
                             / \
                           /     \
                         /         \
                       head        body
                      /\               \
                    /    \               \
                  /        \               \
                title     meta              h1
                 |       (name=&apos;author&apos;,     |
              &quot;Stuff&quot;    content=&apos;Jojo&apos;)    &quot;I like potatoes&quot;

       This is the traditional way to diagram a tree, with the &quot;root&quot; at the
       top, and it&apos;s this kind of diagram that people have in mind when they
       say, for example, that &quot;the meta element is under the head element
       instead of under the body element&quot;.  (The same is also said with &quot;inside&quot;
       instead of &quot;under&quot; -- the use of &quot;inside&quot; makes more sense when you&apos;re
       looking at the HTML source.)

       Another way to represent the above tree is with indenting:

         html (attributes: lang=&apos;en-US&apos;)
           head
             title
               &quot;Stuff&quot;
             meta (attributes: name=&apos;author&apos; content=&apos;Jojo&apos;)
           body
             h1
               &quot;I like potatoes&quot;

       Incidentally, diagramming with indenting works much better for very large
       trees, and is easier for a program to generate.  The &quot;$tree-&gt;dump&quot; method
       uses indentation just that way.

       However you diagram the tree, it&apos;s stored the same in memory -- it&apos;s a
       network of objects, each of which has attributes like so:

         element #1:  _tag: &apos;html&apos;
                      _parent: none
                      _content: [element #2, element #5]
                      lang: &apos;en-US&apos;

         element #2:  _tag: &apos;head&apos;
                      _parent: element #1
                      _content: [element #3, element #4]

         element #3:  _tag: &apos;title&apos;
                      _parent: element #2
                      _content: [text segment &quot;Stuff&quot;]

         element #4   _tag: &apos;meta&apos;
                      _parent: element #2
                      _content: none
                      name: author
                      content: Jojo

         element #5   _tag: &apos;body&apos;
                      _parent: element #1
                      _content: [element #6]

         element #6   _tag: &apos;h1&apos;
                      _parent: element #5
                      _content: [text segment &quot;I like potatoes&quot;]

       The &quot;treeness&quot; of the tree-structure that these elements comprise is not
       an aspect of any particular object, but is emergent from the relatedness
       attributes (_parent and _content) of these element-objects and from how
       you use them to get from element to element.

       While you could access the content of a tree by writing code that says
       &quot;access the &apos;src&apos; attribute of the root&apos;s first child&apos;s seventh child&apos;s
       third child&quot;, you&apos;re more likely to have to scan the contents of a tree,
       looking for whatever nodes, or kinds of nodes, you want to do something
       with.  The most straightforward way to look over a tree is to &quot;traverse&quot;
       it; an HTML::Element method (&quot;$h-&gt;traverse&quot;) is provided for this
       purpose; and several other HTML::Element methods are based on it.

       (For everything you ever wanted to know about trees, and then some, see
       Niklaus Wirth&apos;s Algorithms + Data Structures = Programs or Donald Knuth&apos;s
       The Art of Computer Programming, Volume 1.)

   Weak References
       TL;DR summary: &quot;use HTML::TreeBuilder 5 -weak;&quot; and forget about the
       &quot;delete&quot; method (except for pruning a node from a tree).

       Because HTML::Element stores a reference to the parent element, Perl&apos;s
       reference-count garbage collection doesn&apos;t work properly with
       HTML::Element trees.  Starting with version 5.00, HTML::Element uses weak
       references (if available) to prevent that problem.  Weak references were
       introduced in Perl 5.6.0, but you also need a version of Scalar::Util
       that provides the &quot;weaken&quot; function.

       Weak references are enabled by default.  If you want to be certain
       they&apos;re in use, you can say &quot;use HTML::Element 5 -weak;&quot;.  You must
       include the version number; previous versions of HTML::Element ignored
       the import list entirely.

       To disable weak references, you can say &quot;use HTML::Element -noweak;&quot;.
       This is a global setting.  This feature is deprecated and is provided
       only as a quick fix for broken code.  If your code does not work properly
       with weak references, you should fix it immediately, as weak references
       may become mandatory in a future version.  Generally, all you need to do
       is keep a reference to the root of the tree until you&apos;re done working
       with it.

       Because HTML::TreeBuilder is a subclass of HTML::Element, you can also
       import &quot;-weak&quot; or &quot;-noweak&quot; from HTML::TreeBuilder: e.g.
       &quot;use HTML::TreeBuilder: 5 -weak;&quot;.

BASIC METHODS
   new
         $h = HTML::Element-&gt;new(&apos;tag&apos;, &apos;attrname&apos; =&gt; &apos;value&apos;, ... );

       This constructor method returns a new HTML::Element object.  The tag name
       is a required argument; it will be forced to lowercase.  Optionally, you
       can specify other initial attributes at object creation time.

   attr
         $value = $h-&gt;attr(&apos;attr&apos;);
         $old_value = $h-&gt;attr(&apos;attr&apos;, $new_value);

       Returns (optionally sets) the value of the given attribute of $h.  The
       attribute name (but not the value, if provided) is forced to lowercase.
       If trying to read the value of an attribute not present for this element,
       the return value is undef.  If setting a new value, the old value of that
       attribute is returned.

       If methods are provided for accessing an attribute (like &quot;$h-&gt;tag&quot; for
       &quot;_tag&quot;, &quot;$h-&gt;content_list&quot;, etc. below), use those instead of calling
       attr &quot;$h-&gt;attr&quot;, whether for reading or setting.

       Note that setting an attribute to &quot;undef&quot; (as opposed to &quot;&quot;, the empty
       string) actually deletes the attribute.

   tag
         $tagname = $h-&gt;tag();
         $h-&gt;tag(&apos;tagname&apos;);

       Returns (optionally sets) the tag name (also known as the generic
       identifier) for the element $h.  In setting, the tag name is always
       converted to lower case.

       There are four kinds of &quot;pseudo-elements&quot; that show up as HTML::Element
       objects:
&#12;       Comment pseudo-elements
           These are element objects with a &quot;$h-&gt;tag&quot; value of &quot;~comment&quot;, and
           the content of the comment is stored in the &quot;text&quot; attribute
           (&quot;$h-&gt;attr(&quot;text&quot;)&quot;).  For example, parsing this code with
           HTML::TreeBuilder...

             &lt;!-- I like Pie.
                Pie is good
             --&gt;

           produces an HTML::Element object with these attributes:

             &quot;_tag&quot;,
             &quot;~comment&quot;,
             &quot;text&quot;,
             &quot; I like Pie.\n     Pie is good\n  &quot;

       Declaration pseudo-elements
           Declarations (rarely encountered) are represented as HTML::Element
           objects with a tag name of &quot;~declaration&quot;, and content in the &quot;text&quot;
           attribute.  For example, this:

             &lt;!DOCTYPE foo&gt;

           produces an element whose attributes include:

             &quot;_tag&quot;, &quot;~declaration&quot;, &quot;text&quot;, &quot;DOCTYPE foo&quot;

       Processing instruction pseudo-elements
           PIs (rarely encountered) are represented as HTML::Element objects
           with a tag name of &quot;~pi&quot;, and content in the &quot;text&quot; attribute.  For
           example, this:

             &lt;?stuff foo?&gt;

           produces an element whose attributes include:

             &quot;_tag&quot;, &quot;~pi&quot;, &quot;text&quot;, &quot;stuff foo?&quot;

           (assuming a recent version of HTML::Parser)

       ~literal pseudo-elements
           These objects are not currently produced by HTML::TreeBuilder, but
           can be used to represent a &quot;super-literal&quot; -- i.e., a literal you
           want to be immune from escaping.  (Yes, I just made that term up.)

           That is, this is useful if you want to insert code into a tree that
           you plan to dump out with &quot;as_HTML&quot;, where you want, for some reason,
           to suppress &quot;as_HTML&quot;&apos;s normal behavior of amp-quoting text segments.

           For example, this:

             my $literal = HTML::Element-&gt;new(&apos;~literal&apos;,
               &apos;text&apos; =&gt; &apos;x &lt; 4 &amp; y &gt; 7&apos;
             );
             my $span = HTML::Element-&gt;new(&apos;span&apos;);
             $span-&gt;push_content($literal);
             print $span-&gt;as_HTML;

           prints this:

             &lt;span&gt;x &lt; 4 &amp; y &gt; 7&lt;/span&gt;

           Whereas this:

             my $span = HTML::Element-&gt;new(&apos;span&apos;);
             $span-&gt;push_content(&apos;x &lt; 4 &amp; y &gt; 7&apos;);
               # normal text segment
             print $span-&gt;as_HTML;
&#12;           prints this:

             &lt;span&gt;x &amp;lt; 4 &amp;amp; y &amp;gt; 7&lt;/span&gt;

           Unless you&apos;re inserting lots of pre-cooked code into existing trees,
           and dumping them out again, it&apos;s not likely that you&apos;ll find
           &quot;~literal&quot; pseudo-elements useful.

   parent
         $parent = $h-&gt;parent();
         $h-&gt;parent($new_parent);

       Returns (optionally sets) the parent (aka &quot;container&quot;) for this element.
       The parent should either be undef, or should be another element.

       You should not use this to directly set the parent of an element.
       Instead use any of the other methods under &quot;Structure-Modifying Methods&quot;,
       below.

       Note that &quot;not($h-&gt;parent)&quot; is a simple test for whether $h is the root
       of its subtree.

   content_list
         @content = $h-&gt;content_list();
         $num_children = $h-&gt;content_list();

       Returns a list of the child nodes of this element -- i.e., what nodes
       (elements or text segments) are inside/under this element. (Note that
       this may be an empty list.)

       In a scalar context, this returns the count of the items, as you may
       expect.

   content
         $content_array_ref = $h-&gt;content(); # may return undef

       This somewhat deprecated method returns the content of this element; but
       unlike content_list, this returns either undef (which you should
       understand to mean no content), or a reference to the array of content
       items, each of which is either a text segment (a string, i.e., a defined
       non-reference scalar value), or an HTML::Element object.  Note that even
       if an arrayref is returned, it may be a reference to an empty array.

       While older code should feel free to continue to use &quot;$h-&gt;content&quot;, new
       code should use &quot;$h-&gt;content_list&quot; in almost all conceivable cases.  It
       is my experience that in most cases this leads to simpler code anyway,
       since it means one can say:

           @children = $h-&gt;content_list;

       instead of the inelegant:

           @children = @{$h-&gt;content || []};

       If you do use &quot;$h-&gt;content&quot; (or &quot;$h-&gt;content_array_ref&quot;), you should not
       use the reference returned by it (assuming it returned a reference, and
       not undef) to directly set or change the content of an element or text
       segment!  Instead use content_refs_list or any of the other methods under
       &quot;Structure-Modifying Methods&quot;, below.

   content_array_ref
         $content_array_ref = $h-&gt;content_array_ref(); # never undef

       This is like &quot;content&quot; (with all its caveats and deprecations) except
       that it is guaranteed to return an array reference.  That is, if the
       given node has no &quot;_content&quot; attribute, the &quot;content&quot; method would return
       that undef, but &quot;content_array_ref&quot; would set the given node&apos;s &quot;_content&quot;
       value to &quot;[]&quot; (a reference to a new, empty array), and return that.

   content_refs_list
         @content_refs = $h-&gt;content_refs_list;
&#12;       This returns a list of scalar references to each element of $h&apos;s content
       list.  This is useful in case you want to in-place edit any large text
       segments without having to get a copy of the current value of that
       segment value, modify that copy, then use the &quot;splice_content&quot; to replace
       the old with the new.  Instead, here you can in-place edit:

           foreach my $item_r ($h-&gt;content_refs_list) {
               next if ref $$item_r;
               $$item_r =~ s/honour/honor/g;
           }

       You could currently achieve the same affect with:

           foreach my $item (@{ $h-&gt;content_array_ref }) {
               # deprecated!
               next if ref $item;
               $item =~ s/honour/honor/g;
           }

       ...except that using the return value of &quot;$h-&gt;content&quot; or
       &quot;$h-&gt;content_array_ref&quot; to do that is deprecated, and just might stop
       working in the future.

   implicit
         $is_implicit = $h-&gt;implicit();
         $h-&gt;implicit($make_implicit);

       Returns (optionally sets) the &quot;_implicit&quot; attribute.  This attribute is a
       flag that&apos;s used for indicating that the element was not originally
       present in the source, but was added to the parse tree (by
       HTML::TreeBuilder, for example) in order to conform to the rules of HTML
       structure.

   pos
         $pos = $h-&gt;pos();
         $h-&gt;pos($element);

       Returns (and optionally sets) the &quot;_pos&quot; (for &quot;current position&quot;) pointer
       of $h.  This attribute is a pointer used during some parsing operations,
       whose value is whatever HTML::Element element at or under $h is currently
       &quot;open&quot;, where &quot;$h-&gt;insert_element(NEW)&quot; will actually insert a new
       element.

       (This has nothing to do with the Perl function called &quot;pos&quot;, for
       controlling where regular expression matching starts.)

       If you set &quot;$h-&gt;pos($element)&quot;, be sure that $element is either $h, or an
       element under $h.

       If you&apos;ve been modifying the tree under $h and are no longer sure
       &quot;$h-&gt;pos&quot; is valid, you can enforce validity with:

           $h-&gt;pos(undef) unless $h-&gt;pos-&gt;is_inside($h);

   all_attr
         %attr = $h-&gt;all_attr();

       Returns all this element&apos;s attributes and values, as key-value pairs.
       This will include any &quot;internal&quot; attributes (i.e., ones not present in
       the original element, and which will not be represented if/when you call
       &quot;$h-&gt;as_HTML&quot;).  Internal attributes are distinguished by the fact that
       the first character of their key (not value! key!) is an underscore
       (&quot;_&quot;).

       Example output of &quot;$h-&gt;all_attr()&quot; : &quot;&apos;_parent&apos;, &quot;[object_value]&quot; ,
       &apos;_tag&apos;, &apos;em&apos;, &apos;lang&apos;, &apos;en-US&apos;, &apos;_content&apos;, &quot;[array-ref value].

   all_attr_names
         @names = $h-&gt;all_attr_names();
         $num_attrs = $h-&gt;all_attr_names();

       Like &quot;all_attr&quot;, but only returns the names of the attributes.  In scalar
       context, returns the number of attributes.

       Example output of &quot;$h-&gt;all_attr_names()&quot; : &quot;&apos;_parent&apos;, &apos;_tag&apos;, &apos;lang&apos;,
       &apos;_content&apos;, &quot;.

   all_external_attr
         %attr = $h-&gt;all_external_attr();

       Like &quot;all_attr&quot;, except that internal attributes are not present.

   all_external_attr_names
         @names = $h-&gt;all_external_attr_names();
         $num_attrs = $h-&gt;all_external_attr_names();

       Like &quot;all_attr_names&quot;, except that internal attributes&apos; names are not
       present (or counted).

   id
         $id = $h-&gt;id();
         $h-&gt;id($string);

       Returns (optionally sets to $string) the &quot;id&quot; attribute.  &quot;$h-&gt;id(undef)&quot;
       deletes the &quot;id&quot; attribute.

       &quot;$h-&gt;id(...)&quot; is basically equivalent to &quot;$h-&gt;attr(&apos;id&apos;, ...)&quot;, except
       that when setting the attribute, this method returns the new value, not
       the old value.

   idf
         $id = $h-&gt;idf();
         $h-&gt;idf($string);

       Just like the &quot;id&quot; method, except that if you call &quot;$h-&gt;idf()&quot; and no
       &quot;id&quot; attribute is defined for this element, then it&apos;s set to a likely-to-
       be-unique value, and returned.  (The &quot;f&quot; is for &quot;force&quot;.)

STRUCTURE-MODIFYING METHODS
       These methods are provided for modifying the content of trees by adding
       or changing nodes as parents or children of other nodes.

   push_content
         $h-&gt;push_content($element_or_text, ...);

       Adds the specified items to the end of the content list of the element
       $h.  The items of content to be added should each be either a text
       segment (a string), an HTML::Element object, or an arrayref.  Arrayrefs
       are fed thru &quot;$h-&gt;new_from_lol(that_arrayref)&quot; to convert them into
       elements, before being added to the content list of $h.  This means you
       can say things concise things like:

         $body-&gt;push_content(
           [&apos;br&apos;],
           [&apos;ul&apos;,
             map [&apos;li&apos;, $_], qw(Peaches Apples Pears Mangos)
           ]
         );

       See the &quot;new_from_lol&quot; method&apos;s documentation, far below, for more
       explanation.

       Returns $h (the element itself).

       The push_content method will try to consolidate adjacent text segments
       while adding to the content list.  That&apos;s to say, if $h&apos;s &quot;content_list&quot;
       is

         (&apos;foo bar &apos;, $some_node, &apos;baz!&apos;)

       and you call

          $h-&gt;push_content(&apos;quack?&apos;);
&#12;       then the resulting content list will be this:

         (&apos;foo bar &apos;, $some_node, &apos;baz!quack?&apos;)

       and not this:

         (&apos;foo bar &apos;, $some_node, &apos;baz!&apos;, &apos;quack?&apos;)

       If that latter is what you want, you&apos;ll have to override the feature of
       consolidating text by using splice_content, as in:

         $h-&gt;splice_content(scalar($h-&gt;content_list),0,&apos;quack?&apos;);

       Similarly, if you wanted to add &apos;Skronk&apos; to the beginning of the content
       list, calling this:

          $h-&gt;unshift_content(&apos;Skronk&apos;);

       then the resulting content list will be this:

         (&apos;Skronkfoo bar &apos;, $some_node, &apos;baz!&apos;)

       and not this:

         (&apos;Skronk&apos;, &apos;foo bar &apos;, $some_node, &apos;baz!&apos;)

       What you&apos;d to do get the latter is:

         $h-&gt;splice_content(0,0,&apos;Skronk&apos;);

   unshift_content
         $h-&gt;unshift_content($element_or_text, ...)

       Just like &quot;push_content&quot;, but adds to the beginning of the $h element&apos;s
       content list.

       The items of content to be added should each be either a text segment (a
       string), an HTML::Element object, or an arrayref (which is fed thru
       &quot;new_from_lol&quot;).

       The unshift_content method will try to consolidate adjacent text segments
       while adding to the content list.  See above for a discussion of this.

       Returns $h (the element itself).

   splice_content
         @removed = $h-&gt;splice_content($offset, $length,
                                       $element_or_text, ...);

       Detaches the elements from $h&apos;s list of content-nodes, starting at
       $offset and continuing for $length items, replacing them with the
       elements of the following list, if any.  Returns the elements (if any)
       removed from the content-list.  If $offset is negative, then it starts
       that far from the end of the array, just like Perl&apos;s normal &quot;splice&quot;
       function.  If $length and the following list is omitted, removes
       everything from $offset onward.

       The items of content to be added (if any) should each be either a text
       segment (a string), an arrayref (which is fed thru &quot;new_from_lol&quot;), or an
       HTML::Element object that&apos;s not already a child of $h.

   detach
         $old_parent = $h-&gt;detach();

       This unlinks $h from its parent, by setting its &apos;parent&apos; attribute to
       undef, and by removing it from the content list of its parent (if it had
       one).  The return value is the parent that was detached from (or undef,
       if $h had no parent to start with).  Note that neither $h nor its parent
       are explicitly destroyed.

   detach_content
         @old_content = $h-&gt;detach_content();
&#12;       This unlinks all of $h&apos;s children from $h, and returns them.  Note that
       these are not explicitly destroyed; for that, you can just use
       &quot;$h-&gt;delete_content&quot;.

   replace_with
         $h-&gt;replace_with( $element_or_text, ... )

       This replaces $h in its parent&apos;s content list with the nodes specified.
       The element $h (which by then may have no parent) is returned.  This
       causes a fatal error if $h has no parent.  The list of nodes to insert
       may contain $h, but at most once.  Aside from that possible exception,
       the nodes to insert should not already be children of $h&apos;s parent.

       Also, note that this method does not destroy $h if weak references are
       turned off -- use &quot;$h-&gt;replace_with(...)-&gt;delete&quot; if you need that.

   preinsert
         $h-&gt;preinsert($element_or_text...);

       Inserts the given nodes right BEFORE $h in $h&apos;s parent&apos;s content list.
       This causes a fatal error if $h has no parent.  None of the given nodes
       should be $h or other children of $h.  Returns $h.

   postinsert
         $h-&gt;postinsert($element_or_text...)

       Inserts the given nodes right AFTER $h in $h&apos;s parent&apos;s content list.
       This causes a fatal error if $h has no parent.  None of the given nodes
       should be $h or other children of $h.  Returns $h.

   replace_with_content
         $h-&gt;replace_with_content();

       This replaces $h in its parent&apos;s content list with its own content.  The
       element $h (which by then has no parent or content of its own) is
       returned.  This causes a fatal error if $h has no parent.  Also, note
       that this does not destroy $h if weak references are turned off -- use
       &quot;$h-&gt;replace_with_content-&gt;delete&quot; if you need that.

   delete_content
         $h-&gt;delete_content();
         $h-&gt;destroy_content(); # alias

       Clears the content of $h, calling &quot;$h-&gt;delete&quot; for each content element.
       Compare with &quot;$h-&gt;detach_content&quot;.

       Returns $h.

       &quot;destroy_content&quot; is an alias for this method.

   delete
         $h-&gt;delete();
         $h-&gt;destroy(); # alias

       Detaches this element from its parent (if it has one) and explicitly
       destroys the element and all its descendants.  The return value is the
       empty list (or &quot;undef&quot; in scalar context).

       Before version 5.00 of HTML::Element, you had to call &quot;delete&quot; when you
       were finished with the tree, or your program would leak memory.  This is
       no longer necessary if weak references are enabled, see &quot;Weak
       References&quot;.

   destroy
       An alias for &quot;delete&quot;.

   destroy_content
       An alias for &quot;delete_content&quot;.

   clone
         $copy = $h-&gt;clone();

       Returns a copy of the element (whose children are clones (recursively) of
       the original&apos;s children, if any).

       The returned element is parentless.  Any &apos;_pos&apos; attributes present in the
       source element/tree will be absent in the copy.  For that and other
       reasons, the clone of an HTML::TreeBuilder object that&apos;s in mid-parse
       (i.e, the head of a tree that HTML::TreeBuilder is elaborating) cannot
       (currently) be used to continue the parse.

       You are free to clone HTML::TreeBuilder trees, just as long as: 1)
       they&apos;re done being parsed, or 2) you don&apos;t expect to resume parsing into
       the clone.  (You can continue parsing into the original; it is never
       affected.)

   clone_list
         @copies = HTML::Element-&gt;clone_list(...nodes...);

       Returns a list consisting of a copy of each node given.  Text segments
       are simply copied; elements are cloned by calling &quot;$it-&gt;clone&quot; on each of
       them.

       Note that this must be called as a class method, not as an instance
       method.  &quot;clone_list&quot; will croak if called as an instance method.  You
       can also call it like so:

           ref($h)-&gt;clone_list(...nodes...)

   normalize_content
         $h-&gt;normalize_content

       Normalizes the content of $h -- i.e., concatenates any adjacent text
       nodes.  (Any undefined text segments are turned into empty-strings.)
       Note that this does not recurse into $h&apos;s descendants.

   delete_ignorable_whitespace
         $h-&gt;delete_ignorable_whitespace()

       This traverses under $h and deletes any text segments that are ignorable
       whitespace.  You should not use this if $h is under a &quot;&lt;pre&gt;&quot; element.

   insert_element
         $h-&gt;insert_element($element, $implicit);

       Inserts (via push_content) a new element under the element at
       &quot;$h-&gt;pos()&quot;.  Then updates &quot;$h-&gt;pos()&quot; to point to the inserted element,
       unless $element is a prototypically empty element like &quot;&lt;br&gt;&quot;, &quot;&lt;hr&gt;&quot;,
       &quot;&lt;img&gt;&quot;, etc.  The new &quot;$h-&gt;pos()&quot; is returned.  This method is useful
       only if your particular tree task involves setting &quot;$h-&gt;pos()&quot;.

DUMPING METHODS
   dump
         $h-&gt;dump()
         $h-&gt;dump(*FH)  ; # or *FH{IO} or $fh_obj

       Prints the element and all its children to STDOUT (or to a specified
       filehandle), in a format useful only for debugging.  The structure of the
       document is shown by indentation (no end tags).

   as_HTML
         $s = $h-&gt;as_HTML();
         $s = $h-&gt;as_HTML($entities);
         $s = $h-&gt;as_HTML($entities, $indent_char);
         $s = $h-&gt;as_HTML($entities, $indent_char, \%optional_end_tags);

       Returns a string representing in HTML the element and its descendants.
       The optional argument $entities specifies a string of the entities to
       encode.  For compatibility with previous versions, specify &apos;&lt;&gt;&amp;&apos; here.
       If omitted or undef, all unsafe characters are encoded as HTML entities.
       See HTML::Entities for details.  If passed an empty string, no entities
       are encoded.

       If $indent_char is specified and defined, the HTML to be output is
       intented, using the string you specify (which you probably should set to
       &quot;\t&quot;, or some number of spaces, if you specify it).

       If &quot;\%optional_end_tags&quot; is specified and defined, it should be a
       reference to a hash that holds a true value for every tag name whose end
       tag is optional.  Defaults to &quot;\%HTML::Element::optionalEndTag&quot;, which is
       an alias to %HTML::Tagset::optionalEndTag, which, at time of writing,
       contains true values for &quot;p, li, dt, dd&quot;.  A useful value to pass is an
       empty hashref, &quot;{}&quot;, which means that no end-tags are optional for this
       dump.  Otherwise, possibly consider copying %HTML::Tagset::optionalEndTag
       to a hash of your own, adding or deleting values as you like, and passing
       a reference to that hash.

   as_text
         $s = $h-&gt;as_text();
         $s = $h-&gt;as_text(skip_dels =&gt; 1, extra_chars =&gt; &apos;\xA0&apos;);

       Returns a string consisting of only the text parts of the element&apos;s
       descendants.

       Text under &quot;&lt;script&gt;&quot; or &quot;&lt;style&gt;&quot; elements is never included in what&apos;s
       returned.  If &quot;skip_dels&quot; is true, then text content under &quot;&lt;del&gt;&quot; nodes
       is not included in what&apos;s returned.

   as_trimmed_text
         $s = $h-&gt;as_trimmed_text(...);
         $s = $h-&gt;as_text_trimmed(...); # alias

       This is just like &quot;as_text(...)&quot; except that leading and trailing
       whitespace is deleted, and any internal whitespace is collapsed.

       This will not remove non-breaking spaces, Unicode spaces, or any other
       non-ASCII whitespace unless you supply the extra characters as a string
       argument. e.g. &quot;$h-&gt;as_trimmed_text(extra_chars =&gt; &apos;\xA0&apos;)&quot;

   as_XML
         $s = $h-&gt;as_XML()

       Returns a string representing in XML the element and its descendants.

       The XML is not indented.

   as_Lisp_form
         $s = $h-&gt;as_Lisp_form();

       Returns a string representing the element and its descendants as a Lisp
       form.  Unsafe characters are encoded as octal escapes.

       The Lisp form is indented, and contains external (&quot;href&quot;, etc.)  as well
       as internal attributes (&quot;_tag&quot;, &quot;_content&quot;, &quot;_implicit&quot;, etc.), except
       for &quot;_parent&quot;, which is omitted.

       Current example output for a given element:

         (&quot;_tag&quot; &quot;img&quot; &quot;border&quot; &quot;0&quot; &quot;src&quot; &quot;pie.png&quot; &quot;usemap&quot; &quot;#main.map&quot;)

   format
         $s = $h-&gt;format; # use HTML::FormatText
         $s = $h-&gt;format($formatter);

       Formats text output. Defaults to HTML::FormatText.

       Takes a second argument that is a reference to a formatter.

   starttag
         $start = $h-&gt;starttag();
         $start = $h-&gt;starttag($entities);

       Returns a string representing the complete start tag for the element.
       I.e., leading &quot;&lt;&quot;, tag name, attributes, and trailing &quot;&gt;&quot;.  All values
       are surrounded with double-quotes, and appropriate characters are
       encoded.  If $entities is omitted or undef, all unsafe characters are
       encoded as HTML entities.  See HTML::Entities for details.  If you
       specify some value for $entities, remember to include the double-quote
       character in it.  (Previous versions of this module would basically
       behave as if &apos;&amp;&quot;&gt;&apos; were specified for $entities.)  If $entities is an
       empty string, no entity is escaped.

   starttag_XML
         $start = $h-&gt;starttag_XML();

       Returns a string representing the complete start tag for the element.

   endtag
         $end = $h-&gt;endtag();

       Returns a string representing the complete end tag for this element.
       I.e., &quot;&lt;/&quot;, tag name, and &quot;&gt;&quot;.

   endtag_XML
         $end = $h-&gt;endtag_XML();

       Returns a string representing the complete end tag for this element.
       I.e., &quot;&lt;/&quot;, tag name, and &quot;&gt;&quot;.

SECONDARY STRUCTURAL METHODS
       These methods all involve some structural aspect of the tree; either they
       report some aspect of the tree&apos;s structure, or they involve traversal
       down the tree, or walking up the tree.

   is_inside
         $inside = $h-&gt;is_inside(&apos;tag&apos;, $element, ...);

       Returns true if the $h element is, or is contained anywhere inside an
       element that is any of the ones listed, or whose tag name is any of the
       tag names listed.  You can use any mix of elements and tag names.

   is_empty
         $empty = $h-&gt;is_empty();

       Returns true if $h has no content, i.e., has no elements or text segments
       under it.  In other words, this returns true if $h is a leaf node, AKA a
       terminal node.  Do not confuse this sense of &quot;empty&quot; with another sense
       that it can have in SGML/HTML/XML terminology, which means that the
       element in question is of the type (like HTML&apos;s &quot;&lt;hr&gt;&quot;, &quot;&lt;br&gt;&quot;, &quot;&lt;img&gt;&quot;,
       etc.) that can&apos;t have any content.

       That is, a particular &quot;&lt;p&gt;&quot; element may happen to have no content, so
       $that_p_element-&gt;is_empty will be true -- even though the prototypical
       &quot;&lt;p&gt;&quot; element isn&apos;t &quot;empty&quot; (not in the way that the prototypical &quot;&lt;hr&gt;&quot;
       element is).

       If you think this might make for potentially confusing code, consider
       simply using the clearer exact equivalent:  &quot;not($h-&gt;content_list)&quot;.

   pindex
         $index = $h-&gt;pindex();

       Return the index of the element in its parent&apos;s contents array, such that
       $h would equal

         $h-&gt;parent-&gt;content-&gt;[$h-&gt;pindex]
         # or
         ($h-&gt;parent-&gt;content_list)[$h-&gt;pindex]

       assuming $h isn&apos;t root.  If the element $h is root, then &quot;$h-&gt;pindex&quot;
       returns &quot;undef&quot;.

   left
         $element = $h-&gt;left();
         @elements = $h-&gt;left();

       In scalar context: returns the node that&apos;s the immediate left sibling of
       $h.  If $h is the leftmost (or only) child of its parent (or has no
       parent), then this returns undef.

       In list context: returns all the nodes that&apos;re the left siblings of $h
       (starting with the leftmost).  If $h is the leftmost (or only) child of
       its parent (or has no parent), then this returns an empty list.

       (See also &quot;$h-&gt;preinsert(LIST)&quot;.)

   right
         $element = $h-&gt;right();
         @elements = $h-&gt;right();

       In scalar context: returns the node that&apos;s the immediate right sibling of
       $h.  If $h is the rightmost (or only) child of its parent (or has no
       parent), then this returns &quot;undef&quot;.

       In list context: returns all the nodes that&apos;re the right siblings of $h,
       starting with the leftmost.  If $h is the rightmost (or only) child of
       its parent (or has no parent), then this returns an empty list.

       (See also &quot;$h-&gt;postinsert(LIST)&quot;.)

   address
         $address = $h-&gt;address();
         $element_or_text = $h-&gt;address($address);

       The first form (with no parameter) returns a string representing the
       location of $h in the tree it is a member of.  The address consists of
       numbers joined by a &apos;.&apos;, starting with &apos;0&apos;, and followed by the pindexes
       of the nodes in the tree that are ancestors of $h, starting from the top.

       So if the way to get to a node starting at the root is to go to child 2
       of the root, then child 10 of that, and then child 0 of that, and then
       you&apos;re there -- then that node&apos;s address is &quot;0.2.10.0&quot;.

       As a bit of a special case, the address of the root is simply &quot;0&quot;.

       I forsee this being used mainly for debugging, but you may find your own
       uses for it.

         $element_or_text = $h-&gt;address($address);

       This form returns the node (whether element or text-segment) at the given
       address in the tree that $h is a part of.  (That is, the address is
       resolved starting from &quot;$h-&gt;root&quot;.)

       If there is no node at the given address, this returns &quot;undef&quot;.

       You can specify &quot;relative addressing&quot; (i.e., that indexing is supposed to
       start from $h and not from &quot;$h-&gt;root&quot;) by having the address start with a
       period -- e.g., &quot;$h-&gt;address(&quot;.3.2&quot;)&quot; will look at child 3 of $h, and
       child 2 of that.

   depth
         $depth = $h-&gt;depth();

       Returns a number expressing $h&apos;s depth within its tree, i.e., how many
       steps away it is from the root.  If $h has no parent (i.e., is root), its
       depth is 0.

   root
         $root = $h-&gt;root();

       Returns the element that&apos;s the top of $h&apos;s tree.  If $h is root, this
       just returns $h.  (If you want to test whether $h is the root, instead of
       asking what its root is, just test &quot;not($h-&gt;parent)&quot;.)

   lineage
         @lineage = $h-&gt;lineage();

       Returns the list of $h&apos;s ancestors, starting with its parent, and then
       that parent&apos;s parent, and so on, up to the root.  If $h is root, this
       returns an empty list.

       If you simply want a count of the number of elements in $h&apos;s lineage, use
       &quot;$h-&gt;depth&quot;.
&#12;   lineage_tag_names
         @names = $h-&gt;lineage_tag_names();

       Returns the list of the tag names of $h&apos;s ancestors, starting with its
       parent, and that parent&apos;s parent, and so on, up to the root.  If $h is
       root, this returns an empty list.  Example output: &quot;(&apos;em&apos;, &apos;td&apos;, &apos;tr&apos;,
       &apos;table&apos;, &apos;body&apos;, &apos;html&apos;)&quot;

       Equivalent to:

         map { $_-&gt;tag } $h-&gt;lineage;

   descendants
         @descendants = $h-&gt;descendants();

       In list context, returns the list of all $h&apos;s descendant elements, listed
       in pre-order (i.e., an element appears before its content-elements).
       Text segments DO NOT appear in the list.  In scalar context, returns a
       count of all such elements.

   descendents
       This is just an alias to the &quot;descendants&quot; method, for people who can&apos;t
       spell.

   find_by_tag_name
         @elements = $h-&gt;find_by_tag_name(&apos;tag&apos;, ...);
         $first_match = $h-&gt;find_by_tag_name(&apos;tag&apos;, ...);

       In list context, returns a list of elements at or under $h that have any
       of the specified tag names.  In scalar context, returns the first (in
       pre-order traversal of the tree) such element found, or undef if none.

   find
       This is just an alias to &quot;find_by_tag_name&quot;.  (There was once going to be
       a whole find_* family of methods, but then &quot;look_down&quot; filled that niche,
       so there turned out not to be much reason for the verboseness of the name
       &quot;find_by_tag_name&quot;.)

   find_by_attribute
         @elements = $h-&gt;find_by_attribute(&apos;attribute&apos;, &apos;value&apos;);
         $first_match = $h-&gt;find_by_attribute(&apos;attribute&apos;, &apos;value&apos;);

       In a list context, returns a list of elements at or under $h that have
       the specified attribute, and have the given value for that attribute.  In
       a scalar context, returns the first (in pre-order traversal of the tree)
       such element found, or undef if none.

       This method is deprecated in favor of the more expressive &quot;look_down&quot;
       method, which new code should use instead.

   look_down
         @elements = $h-&gt;look_down( ...criteria... );
         $first_match = $h-&gt;look_down( ...criteria... );

       This starts at $h and looks thru its element descendants (in pre-order),
       looking for elements matching the criteria you specify.  In list context,
       returns all elements that match all the given criteria; in scalar
       context, returns the first such element (or undef, if nothing matched).

       There are three kinds of criteria you can specify:

       (attr_name, attr_value)
           This means you&apos;re looking for an element with that value for that
           attribute.  Example: &quot;alt&quot;, &quot;pix!&quot;.  Consider that you can search on
           internal attribute values too: &quot;_tag&quot;, &quot;p&quot;.

       (attr_name, qr/.../)
           This means you&apos;re looking for an element whose value for that
           attribute matches the specified Regexp object.

       a coderef
           This means you&apos;re looking for elements where coderef-&gt;(each_element)
           returns true.  Example:

             my @wide_pix_images = $h-&gt;look_down(
               _tag =&gt; &quot;img&quot;,
               alt  =&gt; &quot;pix!&quot;,
               sub { $_[0]-&gt;attr(&apos;width&apos;) &gt; 350 }
             );

       Note that &quot;(attr_name, attr_value)&quot; and &quot;(attr_name, qr/.../)&quot; criteria
       are almost always faster than coderef criteria, so should presumably be
       put before them in your list of criteria.  That is, in the example above,
       the sub ref is called only for elements that have already passed the
       criteria of having a &quot;_tag&quot; attribute with value &quot;img&quot;, and an &quot;alt&quot;
       attribute with value &quot;pix!&quot;.  If the coderef were first, it would be
       called on every element, and then what elements pass that criterion
       (i.e., elements for which the coderef returned true) would be checked for
       their &quot;_tag&quot; and &quot;alt&quot; attributes.

       Note that comparison of string attribute-values against the string value
       in &quot;(attr_name, attr_value)&quot; is case-INsensitive!  A criterion of
       &quot;(&apos;align&apos;, &apos;right&apos;)&quot; will match an element whose &quot;align&quot; value is
       &quot;RIGHT&quot;, or &quot;right&quot; or &quot;rIGhT&quot;, etc.

       Note also that &quot;look_down&quot; considers &quot;&quot; (empty-string) and undef to be
       different things, in attribute values.  So this:

         $h-&gt;look_down(&quot;alt&quot;, &quot;&quot;)

       will find elements with an &quot;alt&quot; attribute, but where the value for the
       &quot;alt&quot; attribute is &quot;&quot;.  But this:

         $h-&gt;look_down(&quot;alt&quot;, undef)

       is the same as:

         $h-&gt;look_down(sub { !defined($_[0]-&gt;attr(&apos;alt&apos;)) } )

       That is, it finds elements that do not have an &quot;alt&quot; attribute at all (or
       that do have an &quot;alt&quot; attribute, but with a value of undef -- which is
       not normally possible).

       Note that when you give several criteria, this is taken to mean you&apos;re
       looking for elements that match all your criterion, not just any of them.
       In other words, there is an implicit &quot;and&quot;, not an &quot;or&quot;.  So if you
       wanted to express that you wanted to find elements with a &quot;name&quot;
       attribute with the value &quot;foo&quot; or with an &quot;id&quot; attribute with the value
       &quot;baz&quot;, you&apos;d have to do it like:

         @them = $h-&gt;look_down(
           sub {
             # the lcs are to fold case
             lc($_[0]-&gt;attr(&apos;name&apos;)) eq &apos;foo&apos;
             or lc($_[0]-&gt;attr(&apos;id&apos;)) eq &apos;baz&apos;
           }
         );

       Coderef criteria are more expressive than &quot;(attr_name, attr_value)&quot; and
       &quot;(attr_name, qr/.../)&quot; criteria, and all &quot;(attr_name, attr_value)&quot; and
       &quot;(attr_name, qr/.../)&quot; criteria could be expressed in terms of coderefs.
       However, &quot;(attr_name, attr_value)&quot; and &quot;(attr_name, qr/.../)&quot; criteria
       are a convenient shorthand.  (In fact, &quot;look_down&quot; itself is basically
       &quot;shorthand&quot; too, since anything you can do with &quot;look_down&quot; you could do
       by traversing the tree, either with the &quot;traverse&quot; method or with a
       routine of your own.  However, &quot;look_down&quot; often makes for very concise
       and clear code.)

   look_up
         @elements = $h-&gt;look_up( ...criteria... );
         $first_match = $h-&gt;look_up( ...criteria... );

       This is identical to &quot;$h-&gt;look_down&quot;, except that whereas &quot;$h-&gt;look_down&quot;
       basically scans over the list:

          ($h, $h-&gt;descendants)
&#12;       &quot;$h-&gt;look_up&quot; instead scans over the list

          ($h, $h-&gt;lineage)

       So, for example, this returns all ancestors of $h (possibly including $h
       itself) that are &quot;&lt;td&gt;&quot; elements with an &quot;align&quot; attribute with a value
       of &quot;right&quot; (or &quot;RIGHT&quot;, etc.):

          $h-&gt;look_up(&quot;_tag&quot;, &quot;td&quot;, &quot;align&quot;, &quot;right&quot;);

   traverse
         $h-&gt;traverse(...options...)

       Lengthy discussion of HTML::Element&apos;s unnecessary and confusing
       &quot;traverse&quot; method has been moved to a separate file:
       HTML::Element::traverse

   attr_get_i
         @values = $h-&gt;attr_get_i(&apos;attribute&apos;);
         $first_value = $h-&gt;attr_get_i(&apos;attribute&apos;);

       In list context, returns a list consisting of the values of the given
       attribute for $h and for all its ancestors starting from $h and working
       its way up.  Nodes with no such attribute are skipped.  (&quot;attr_get_i&quot;
       stands for &quot;attribute get, with inheritance&quot;.)  In scalar context,
       returns the first such value, or undef if none.

       Consider a document consisting of:

          &lt;html lang=&apos;i-klingon&apos;&gt;
            &lt;head&gt;&lt;title&gt;Pati Pata&lt;/title&gt;&lt;/head&gt;
            &lt;body&gt;
              &lt;h1 lang=&apos;la&apos;&gt;Stuff&lt;/h1&gt;
              &lt;p lang=&apos;es-MX&apos; align=&apos;center&apos;&gt;
                Foo bar baz &lt;cite&gt;Quux&lt;/cite&gt;.
              &lt;/p&gt;
              &lt;p&gt;Hooboy.&lt;/p&gt;
            &lt;/body&gt;
          &lt;/html&gt;

       If $h is the &quot;&lt;cite&gt;&quot; element, &quot;$h-&gt;attr_get_i(&quot;lang&quot;)&quot; in list context
       will return the list &quot;(&apos;es-MX&apos;, &apos;i-klingon&apos;)&quot;.  In scalar context, it
       will return the value &apos;es-MX&apos;.

       If you call with multiple attribute names...

         @values = $h-&gt;attr_get_i(&apos;a1&apos;, &apos;a2&apos;, &apos;a3&apos;);
         $first_value = $h-&gt;attr_get_i(&apos;a1&apos;, &apos;a2&apos;, &apos;a3&apos;);

       ...in list context, this will return a list consisting of the values of
       these attributes which exist in $h and its ancestors.  In scalar context,
       this returns the first value (i.e., the value of the first existing
       attribute from the first element that has any of the attributes listed).
       So, in the above example,

         $h-&gt;attr_get_i(&apos;lang&apos;, &apos;align&apos;);

       will return:

          (&apos;es-MX&apos;, &apos;center&apos;, &apos;i-klingon&apos;) # in list context
         or
          &apos;es-MX&apos; # in scalar context.

       But note that this:

        $h-&gt;attr_get_i(&apos;align&apos;, &apos;lang&apos;);

       will return:

          (&apos;center&apos;, &apos;es-MX&apos;, &apos;i-klingon&apos;) # in list context
         or
          &apos;center&apos; # in scalar context.

   tagname_map
         $hash_ref = $h-&gt;tagname_map();
&#12;       Scans across $h and all its descendants, and makes a hash (a reference to
       which is returned) where each entry consists of a key that&apos;s a tag name,
       and a value that&apos;s a reference to a list to all elements that have that
       tag name.  I.e., this method returns:

          {
            # Across $h and all descendants...
            &apos;a&apos;   =&gt; [ ...list of all &lt;a&gt;   elements... ],
            &apos;em&apos;  =&gt; [ ...list of all &lt;em&gt;  elements... ],
            &apos;img&apos; =&gt; [ ...list of all &lt;img&gt; elements... ],
          }

       (There are entries in the hash for only those tagnames that occur
       at/under $h -- so if there&apos;s no &quot;&lt;img&gt;&quot; elements, there&apos;ll be no &quot;img&quot;
       entry in the returned hashref.)

       Example usage:

           my $map_r = $h-&gt;tagname_map();
           my @heading_tags = sort grep m/^h\d$/s, keys %$map_r;
           if(@heading_tags) {
             print &quot;Heading levels used: @heading_tags\n&quot;;
           } else {
             print &quot;No headings.\n&quot;
           }

   extract_links
         $links_array_ref = $h-&gt;extract_links();
         $links_array_ref = $h-&gt;extract_links(@wantedTypes);

       Returns links found by traversing the element and all of its children and
       looking for attributes (like &quot;href&quot; in an &quot;&lt;a&gt;&quot; element, or &quot;src&quot; in an
       &quot;&lt;img&gt;&quot; element) whose values represent links.  The return value is a
       reference to an array.  Each element of the array is reference to an
       array with four items: the link-value, the element that has the attribute
       with that link-value, and the name of that attribute, and the tagname of
       that element.  (Example: &quot;[&apos;http://www.suck.com/&apos;,&quot; $elem_obj &quot;, &apos;href&apos;,
       &apos;a&apos;]&quot;.)  You may or may not end up using the element itself -- for some
       purposes, you may use only the link value.

       You might specify that you want to extract links from just some kinds of
       elements (instead of the default, which is to extract links from all the
       kinds of elements known to have attributes whose values represent links).
       For instance, if you want to extract links from only &quot;&lt;a&gt;&quot; and &quot;&lt;img&gt;&quot;
       elements, you could code it like this:

         for (@{  $e-&gt;extract_links(&apos;a&apos;, &apos;img&apos;)  }) {
             my($link, $element, $attr, $tag) = @$_;
             print
               &quot;Hey, there&apos;s a $tag that links to &quot;,
               $link, &quot;, in its $attr attribute, at &quot;,
               $element-&gt;address(), &quot;.\n&quot;;
         }

   simplify_pres
         $h-&gt;simplify_pres();

       In text bits under PRE elements that are at/under $h, this routine
       nativizes all newlines, and expands all tabs.

       That is, if you read a file with lines delimited by &quot;\cm\cj&quot;&apos;s, the text
       under PRE areas will have &quot;\cm\cj&quot;&apos;s instead of &quot;\n&quot;&apos;s. Calling
       &quot;$h-&gt;simplify_pres&quot; on such a tree will turn &quot;\cm\cj&quot;&apos;s into &quot;\n&quot;&apos;s.

       Tabs are expanded to however many spaces it takes to get to the next 8th
       column -- the usual way of expanding them.

   same_as
         $equal = $h-&gt;same_as($i)

       Returns true if $h and $i are both elements representing the same tree of
       elements, each with the same tag name, with the same explicit attributes
       (i.e., not counting attributes whose names start with &quot;_&quot;), and with the
       same content (textual, comments, etc.).

       Sameness of descendant elements is tested, recursively, with
       &quot;$child1-&gt;same_as($child_2)&quot;, and sameness of text segments is tested
       with &quot;$segment1 eq $segment2&quot;.

   new_from_lol
         $h = HTML::Element-&gt;new_from_lol($array_ref);
         @elements = HTML::Element-&gt;new_from_lol($array_ref, ...);

       Resursively constructs a tree of nodes, based on the (non-cyclic) data
       structure represented by each $array_ref, where that is a reference to an
       array of arrays (of arrays (of arrays (etc.))).

       In each arrayref in that structure, different kinds of values are treated
       as follows:

       &#183;   Arrayrefs

           Arrayrefs are considered to designate a sub-tree representing
           children for the node constructed from the current arrayref.

       &#183;   Hashrefs

           Hashrefs are considered to contain attribute-value pairs to add to
           the element to be constructed from the current arrayref

       &#183;   Text segments

           Text segments at the start of any arrayref will be considered to
           specify the name of the element to be constructed from the current
           arrayref; all other text segments will be considered to specify text
           segments as children for the current arrayref.

       &#183;   Elements

           Existing element objects are either inserted into the treelet
           constructed, or clones of them are.  That is, when the lol-tree is
           being traversed and elements constructed based what&apos;s in it, if an
           existing element object is found, if it has no parent, then it is
           added directly to the treelet constructed; but if it has a parent,
           then &quot;$that_node-&gt;clone&quot; is added to the treelet at the appropriate
           place.

       An example will hopefully make this more obvious:

         my $h = HTML::Element-&gt;new_from_lol(
           [&apos;html&apos;,
             [&apos;head&apos;,
               [ &apos;title&apos;, &apos;I like stuff!&apos; ],
             ],
             [&apos;body&apos;,
               {&apos;lang&apos;, &apos;en-JP&apos;, _implicit =&gt; 1},
               &apos;stuff&apos;,
               [&apos;p&apos;, &apos;um, p &lt; 4!&apos;, {&apos;class&apos; =&gt; &apos;par123&apos;}],
               [&apos;div&apos;, {foo =&gt; &apos;bar&apos;}, &apos;123&apos;],
             ]
           ]
         );
         $h-&gt;dump;

       Will print this:

         &lt;html&gt; @0
           &lt;head&gt; @0.0
             &lt;title&gt; @0.0.0
               &quot;I like stuff!&quot;
           &lt;body lang=&quot;en-JP&quot;&gt; @0.1 (IMPLICIT)
             &quot;stuff&quot;
             &lt;p class=&quot;par123&quot;&gt; @0.1.1
               &quot;um, p &lt; 4!&quot;
             &lt;div foo=&quot;bar&quot;&gt; @0.1.2
               &quot;123&quot;

       And printing $h-&gt;as_HTML will give something like:

         &lt;html&gt;&lt;head&gt;&lt;title&gt;I like stuff!&lt;/title&gt;&lt;/head&gt;
         &lt;body lang=&quot;en-JP&quot;&gt;stuff&lt;p class=&quot;par123&quot;&gt;um, p &amp;lt; 4!
         &lt;div foo=&quot;bar&quot;&gt;123&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;
&#12;       You can even do fancy things with &quot;map&quot;:

         $body-&gt;push_content(
           # push_content implicitly calls new_from_lol on arrayrefs...
           [&apos;br&apos;],
           [&apos;blockquote&apos;,
             [&apos;h2&apos;, &apos;Pictures!&apos;],
             map [&apos;p&apos;, $_],
             $body2-&gt;look_down(&quot;_tag&quot;, &quot;img&quot;),
               # images, to be copied from that other tree.
           ],
           # and more stuff:
           [&apos;ul&apos;,
             map [&apos;li&apos;, [&apos;a&apos;, {&apos;href&apos;=&gt;&quot;$_.png&quot;}, $_ ] ],
             qw(Peaches Apples Pears Mangos)
           ],
         );

       In scalar context, you must supply exactly one arrayref.  In list
       context, you can pass a list of arrayrefs, and new_from_lol will return a
       list of elements, one for each arrayref.

         @elements = HTML::Element-&gt;new_from_lol(
           [&apos;hr&apos;],
           [&apos;p&apos;, &apos;And there, on the door, was a hook!&apos;],
         );
          # constructs two elements.

   objectify_text
         $h-&gt;objectify_text();

       This turns any text nodes under $h from mere text segments (strings) into
       real objects, pseudo-elements with a tag-name of &quot;~text&quot;, and the actual
       text content in an attribute called &quot;text&quot;.  (For a discussion of pseudo-
       elements, see the &quot;tag&quot; method, far above.)  This method is provided
       because, for some purposes, it is convenient or necessary to be able, for
       a given text node, to ask what element is its parent; and clearly this is
       not possible if a node is just a text string.

       Note that these &quot;~text&quot; objects are not recognized as text nodes by
       methods like &quot;as_text&quot;.  Presumably you will want to call
       &quot;$h-&gt;objectify_text&quot;, perform whatever task that you needed that for, and
       then call &quot;$h-&gt;deobjectify_text&quot; before calling anything like
       &quot;$h-&gt;as_text&quot;.

   deobjectify_text
         $h-&gt;deobjectify_text();

       This undoes the effect of &quot;$h-&gt;objectify_text&quot;.  That is, it takes any
       &quot;~text&quot; pseudo-elements in the tree at/under $h, and deletes each one,
       replacing each with the content of its &quot;text&quot; attribute.

       Note that if $h itself is a &quot;~text&quot; pseudo-element, it will be destroyed
       -- a condition you may need to treat specially in your calling code
       (since it means you can&apos;t very well do anything with $h after that).  So
       that you can detect that condition, if $h is itself a &quot;~text&quot; pseudo-
       element, then this method returns the value of the &quot;text&quot; attribute,
       which should be a defined value; in all other cases, it returns undef.

       (This method assumes that no &quot;~text&quot; pseudo-element has any children.)

   number_lists
         $h-&gt;number_lists();

       For every UL, OL, DIR, and MENU element at/under $h, this sets a
       &quot;_bullet&quot; attribute for every child LI element.  For LI children of an
       OL, the &quot;_bullet&quot; attribute&apos;s value will be something like &quot;4.&quot;, &quot;d.&quot;,
       &quot;D.&quot;, &quot;IV.&quot;, or &quot;iv.&quot;, depending on the OL element&apos;s &quot;type&quot; attribute.
       LI children of a UL, DIR, or MENU get their &quot;_bullet&quot; attribute set to
       &quot;*&quot;.  There should be no other LIs (i.e., except as children of OL, UL,
       DIR, or MENU elements), and if there are, they are unaffected.

   has_insane_linkage
         $h-&gt;has_insane_linkage

       This method is for testing whether this element or the elements under it
       have linkage attributes (_parent and _content) whose values are deeply
       aberrant: if there are undefs in a content list; if an element appears in
       the content lists of more than one element; if the _parent attribute of
       an element doesn&apos;t match its actual parent; or if an element appears as
       its own descendant (i.e., if there is a cyclicity in the tree).

       This returns empty list (or false, in scalar context) if the subtree&apos;s
       linkage methods are sane; otherwise it returns two items (or true, in
       scalar context): the element where the error occurred, and a string
       describing the error.

       This method is provided is mainly for debugging and troubleshooting -- it
       should be quite impossible for any document constructed via
       HTML::TreeBuilder to parse into a non-sane tree (since it&apos;s not the
       content of the tree per se that&apos;s in question, but whether the tree in
       memory was properly constructed); and it should be impossible for you to
       produce an insane tree just thru reasonable use of normal documented
       structure-modifying methods.  But if you&apos;re constructing your own trees,
       and your program is going into infinite loops as during calls to
       traverse() or any of the secondary structural methods, as part of
       debugging, consider calling &quot;has_insane_linkage&quot; on the tree.

   element_class
         $classname = $h-&gt;element_class();

       This method returns the class which will be used for new elements.  It
       defaults to HTML::Element, but can be overridden by subclassing or
       esoteric means best left to those will will read the source and then not
       complain when those esoteric means change.  (Just subclass.)

CLASS METHODS
   Use_Weak_Refs
         $enabled = HTML::Element-&gt;Use_Weak_Refs;
         HTML::Element-&gt;Use_Weak_Refs( $enabled );

       This method allows you to check whether weak reference support is
       enabled, and to enable or disable it. For details, see &quot;Weak References&quot;.
       $enabled is true if weak references are enabled.

       You should not switch this in the middle of your program, and you
       probably shouldn&apos;t use it at all.  Existing trees are not affected by
       this method (until you start modifying nodes in them).

       Throws an exception if you attempt to enable weak references and your
       Perl or Scalar::Util does not support them.

       Disabling weak reference support is deprecated.

SUBROUTINES
   Version
       This subroutine is deprecated.  Please use the standard VERSION method
       (e.g. &quot;HTML::Element-&gt;VERSION&quot;) instead.

   ABORT OK PRUNE PRUNE_SOFTLY PRUNE_UP
       Constants for signalling back to the traverser

BUGS
       * If you want to free the memory associated with a tree built of
       HTML::Element nodes, and you have disabled weak references, then you will
       have to delete it explicitly using the &quot;delete&quot; method.  See &quot;Weak
       References&quot;.

       * There&apos;s almost nothing to stop you from making a &quot;tree&quot; with
       cyclicities (loops) in it, which could, for example, make the traverse
       method go into an infinite loop.  So don&apos;t make cyclicities!  (If all
       you&apos;re doing is parsing HTML files, and looking at the resulting trees,
       this will never be a problem for you.)

       * There&apos;s no way to represent comments or processing directives in a tree
       with HTML::Elements.  Not yet, at least.

       * There&apos;s (currently) nothing to stop you from using an undefined value
       as a text segment.  If you&apos;re running under &quot;perl -w&quot;, however, this may
       make HTML::Element&apos;s code produce a slew of warnings.

NOTES ON SUBCLASSING
       You are welcome to derive subclasses from HTML::Element, but you should
       be aware that the code in HTML::Element makes certain assumptions about
       elements (and I&apos;m using &quot;element&quot; to mean ONLY an object of class
       HTML::Element, or of a subclass of HTML::Element):

       * The value of an element&apos;s _parent attribute must either be undef or
       otherwise false, or must be an element.

       * The value of an element&apos;s _content attribute must either be undef or
       otherwise false, or a reference to an (unblessed) array.  The array may
       be empty; but if it has items, they must ALL be either mere strings (text
       segments), or elements.

       * The value of an element&apos;s _tag attribute should, at least, be a string
       of printable characters.

       Moreover, bear these rules in mind:

       * Do not break encapsulation on objects.  That is, access their contents
       only thru $obj-&gt;attr or more specific methods.

       * You should think twice before completely overriding any of the methods
       that HTML::Element provides.  (Overriding with a method that calls the
       superclass method is not so bad, though.)

SEE ALSO
       HTML::Tree; HTML::TreeBuilder; HTML::AsSubs; HTML::Tagset; and, for the
       morbidly curious, HTML::Element::traverse.

ACKNOWLEDGEMENTS
       Thanks to Mark-Jason Dominus for a POD suggestion.

AUTHOR
       Current maintainers:

       &#183;   Christopher J. Madsen &quot;&lt;perl AT cjmweb.net&gt;&quot;

       &#183;   Jeff Fearn &quot;&lt;jfearn AT cpan.org&gt;&quot;

       Original HTML-Tree author:

       &#183;   Gisle Aas

       Former maintainers:

       &#183;   Sean M. Burke

       &#183;   Andy Lester

       &#183;   Pete Krawczyk &quot;&lt;petek AT cpan.org&gt;&quot;

       You can follow or contribute to HTML-Tree&apos;s development at
       http://github.com/madsen/HTML-Tree &lt;http://github.com/madsen/HTML-Tree&gt;.

COPYRIGHT AND LICENSE
       Copyright 1995-1998 Gisle Aas, 1999-2004 Sean M. Burke, 2005 Andy Lester,
       2006 Pete Krawczyk, 2010 Jeff Fearn, 2012 Christopher J. Madsen.

       This library is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.

       The programs in this library are distributed in the hope that they will
       be useful, but without any warranty; without even the implied warranty of
       merchantability or fitness for a particular purpose.



perl v5.14.2                       2012-06-30                 HTML::Element(3pm)

</pre></body></html>
