<html>
<head><meta charset=utf-8/>
<title>HTML::Parser - HTML parser class</title></head>
<body><pre>

Parser(3pm)            User Contributed Perl Documentation           Parser(3pm)



NAME
       HTML::Parser - HTML parser class

SYNOPSIS
        use HTML::Parser ();

        # Create parser object
        $p = HTML::Parser-&gt;new( api_version =&gt; 3,
                                start_h =&gt; [\&amp;start, &quot;tagname, attr&quot;],
                                end_h   =&gt; [\&amp;end,   &quot;tagname&quot;],
                                marked_sections =&gt; 1,
                              );

        # Parse document text chunk by chunk
        $p-&gt;parse($chunk1);
        $p-&gt;parse($chunk2);
        #...
        $p-&gt;eof;                 # signal end of document

        # Parse directly from file
        $p-&gt;parse_file(&quot;foo.html&quot;);
        # or
        open(my $fh, &quot;&lt;:utf8&quot;, &quot;foo.html&quot;) || die;
        $p-&gt;parse_file($fh);

DESCRIPTION
       Objects of the &quot;HTML::Parser&quot; class will recognize markup and separate it
       from plain text (alias data content) in HTML documents.  As different
       kinds of markup and text are recognized, the corresponding event handlers
       are invoked.

       &quot;HTML::Parser&quot; is not a generic SGML parser.  We have tried to make it
       able to deal with the HTML that is actually &quot;out there&quot;, and it normally
       parses as closely as possible to the way the popular web browsers do it
       instead of strictly following one of the many HTML specifications from
       W3C.  Where there is disagreement, there is often an option that you can
       enable to get the official behaviour.

       The document to be parsed may be supplied in arbitrary chunks.  This
       makes on-the-fly parsing as documents are received from the network
       possible.

       If event driven parsing does not feel right for your application, you
       might want to use &quot;HTML::PullParser&quot;.  This is an &quot;HTML::Parser&quot; subclass
       that allows a more conventional program structure.

METHODS
       The following method is used to construct a new &quot;HTML::Parser&quot; object:

       $p = HTML::Parser-&gt;new( %options_and_handlers )
           This class method creates a new &quot;HTML::Parser&quot; object and returns it.
           Key/value argument pairs may be provided to assign event handlers or
           initialize parser options.  The handlers and parser options can also
           be set or modified later by the method calls described below.

           If a top level key is in the form &quot;&lt;event&gt;_h&quot; (e.g., &quot;text_h&quot;) then
           it assigns a handler to that event, otherwise it initializes a parser
           option. The event handler specification value must be an array
           reference.  Multiple handlers may also be assigned with the &apos;handlers
           =&gt; [%handlers]&apos; option.  See examples below.

           If new() is called without any arguments, it will create a parser
           that uses callback methods compatible with version 2 of
           &quot;HTML::Parser&quot;.  See the section on &quot;version 2 compatibility&quot; below
           for details.

           The special constructor option &apos;api_version =&gt; 2&apos; can be used to
           initialize version 2 callbacks while still setting other options and
           handlers.  The &apos;api_version =&gt; 3&apos; option can be used if you don&apos;t
           want to set any options and don&apos;t want to fall back to v2 compatible
           mode.

           Examples:

            $p = HTML::Parser-&gt;new(api_version =&gt; 3,
                                   text_h =&gt; [ sub {...}, &quot;dtext&quot; ]);

           This creates a new parser object with a text event handler subroutine
           that receives the original text with general entities decoded.

            $p = HTML::Parser-&gt;new(api_version =&gt; 3,
                                   start_h =&gt; [ &apos;my_start&apos;, &quot;self,tokens&quot; ]);

           This creates a new parser object with a start event handler method
           that receives the $p and the tokens array.

            $p = HTML::Parser-&gt;new(api_version =&gt; 3,
                                   handlers =&gt; { text =&gt; [\@array, &quot;event,text&quot;],
                                                 comment =&gt; [\@array, &quot;event,text&quot;],
                                               });

           This creates a new parser object that stores the event type and the
           original text in @array for text and comment events.

       The following methods feed the HTML document to the &quot;HTML::Parser&quot;
       object:

       $p-&gt;parse( $string )
           Parse $string as the next chunk of the HTML document.  Handlers
           invoked should not attempt to modify the $string in-place until
           $p-&gt;parse returns.

           If an invoked event handler aborts parsing by calling $p-&gt;eof, then
           $p-&gt;parse() will return a FALSE value.  Otherwise the return value is
           a reference to the parser object ($p).

       $p-&gt;parse( $code_ref )
           If a code reference is passed as the argument to be parsed, then the
           chunks to be parsed are obtained by invoking this function
           repeatedly.  Parsing continues until the function returns an empty
           (or undefined) result.  When this happens $p-&gt;eof is automatically
           signaled.

           Parsing will also abort if one of the event handlers calls $p-&gt;eof.

           The effect of this is the same as:

            while (1) {
               my $chunk = &amp;$code_ref();
               if (!defined($chunk) || !length($chunk)) {
                   $p-&gt;eof;
                   return $p;
               }
               $p-&gt;parse($chunk) || return undef;
            }

           But it is more efficient as this loop runs internally in XS code.
&#12;       $p-&gt;parse_file( $file )
           Parse text directly from a file.  The $file argument can be a
           filename, an open file handle, or a reference to an open file handle.

           If $file contains a filename and the file can&apos;t be opened, then the
           method returns an undefined value and $! tells why it failed.
           Otherwise the return value is a reference to the parser object.

           If a file handle is passed as the $file argument, then the file will
           normally be read until EOF, but not closed.

           If an invoked event handler aborts parsing by calling $p-&gt;eof, then
           $p-&gt;parse_file() may not have read the entire file.

           On systems with multi-byte line terminators, the values passed for
           the offset and length argspecs may be too low if parse_file() is
           called on a file handle that is not in binary mode.

           If a filename is passed in, then parse_file() will open the file in
           binary mode.

       $p-&gt;eof
           Signals the end of the HTML document.  Calling the $p-&gt;eof method
           outside a handler callback will flush any remaining buffered text
           (which triggers the &quot;text&quot; event if there is any remaining text).

           Calling $p-&gt;eof inside a handler will terminate parsing at that point
           and cause $p-&gt;parse to return a FALSE value.  This also terminates
           parsing by $p-&gt;parse_file().

           After $p-&gt;eof has been called, the parse() and parse_file() methods
           can be invoked to feed new documents with the parser object.

           The return value from eof() is a reference to the parser object.

       Most parser options are controlled by boolean attributes.  Each boolean
       attribute is enabled by calling the corresponding method with a TRUE
       argument and disabled with a FALSE argument.  The attribute value is left
       unchanged if no argument is given.  The return value from each method is
       the old attribute value.

       Methods that can be used to get and/or set parser options are:

       $p-&gt;attr_encoded
       $p-&gt;attr_encoded( $bool )
           By default, the &quot;attr&quot; and @attr argspecs will have general entities
           for attribute values decoded.  Enabling this attribute leaves
           entities alone.

       $p-&gt;backquote
       $p-&gt;backquote( $bool )
           By default, only &apos; and &quot; are recognized as quote characters around
           attribute values.  MSIE also recognizes backquotes for some reason.
           Enabling this attribute provides compatibility with this behaviour.

       $p-&gt;boolean_attribute_value( $val )
           This method sets the value reported for boolean attributes inside
           HTML start tags.  By default, the name of the attribute is also used
           as its value.  This affects the values reported for &quot;tokens&quot; and
           &quot;attr&quot; argspecs.

       $p-&gt;case_sensitive
       $p-&gt;case_sensitive( $bool )
           By default, tagnames and attribute names are down-cased.  Enabling
           this attribute leaves them as found in the HTML source document.
&#12;       $p-&gt;closing_plaintext
       $p-&gt;closing_plaintext( $bool )
           By default, &quot;plaintext&quot; element can never be closed. Everything up to
           the end of the document is parsed in CDATA mode.  This historical
           behaviour is what at least MSIE does.  Enabling this attribute makes
           closing &quot;&lt;/plaintext&gt;&quot; tag effective and the parsing process will
           resume after seeing this tag.  This emulates early gecko-based
           browsers.

       $p-&gt;empty_element_tags
       $p-&gt;empty_element_tags( $bool )
           By default, empty element tags are not recognized as such and the &quot;/&quot;
           before &quot;&gt;&quot; is just treated like a normal name character (unless
           &quot;strict_names&quot; is enabled).  Enabling this attribute make
           &quot;HTML::Parser&quot; recognize these tags.

           Empty element tags look like start tags, but end with the character
           sequence &quot;/&gt;&quot; instead of &quot;&gt;&quot;.  When recognized by &quot;HTML::Parser&quot; they
           cause an artificial end event in addition to the start event.  The
           &quot;text&quot; for the artificial end event will be empty and the &quot;tokenpos&quot;
           array will be undefined even though the the token array will have one
           element containing the tag name.

       $p-&gt;marked_sections
       $p-&gt;marked_sections( $bool )
           By default, section markings like &lt;![CDATA[...]]&gt; are treated like
           ordinary text.  When this attribute is enabled section markings are
           honoured.

           There are currently no events associated with the marked section
           markup, but the text can be returned as &quot;skipped_text&quot;.

       $p-&gt;strict_comment
       $p-&gt;strict_comment( $bool )
           By default, comments are terminated by the first occurrence of &quot;--&gt;&quot;.
           This is the behaviour of most popular browsers (like Mozilla, Opera
           and MSIE), but it is not correct according to the official HTML
           standard.  Officially, you need an even number of &quot;--&quot; tokens before
           the closing &quot;&gt;&quot; is recognized and there may not be anything but
           whitespace between an even and an odd &quot;--&quot;.

           The official behaviour is enabled by enabling this attribute.

           Enabling of &apos;strict_comment&apos; also disables recognizing these forms as
           comments:

             &lt;/ comment&gt;
             &lt;! comment&gt;

       $p-&gt;strict_end
       $p-&gt;strict_end( $bool )
           By default, attributes and other junk are allowed to be present on
           end tags in a manner that emulates MSIE&apos;s behaviour.

           The official behaviour is enabled with this attribute.  If enabled,
           only whitespace is allowed between the tagname and the final &quot;&gt;&quot;.

       $p-&gt;strict_names
       $p-&gt;strict_names( $bool )
           By default, almost anything is allowed in tag and attribute names.
           This is the behaviour of most popular browsers and allows us to parse
           some broken tags with invalid attribute values like:

              &lt;IMG SRC=newprevlstGr.gif ALT=[PREV LIST] BORDER=0&gt;

           By default, &quot;LIST]&quot; is parsed as a boolean attribute, not as part of
           the ALT value as was clearly intended.  This is also what Mozilla
           sees.

           The official behaviour is enabled by enabling this attribute.  If
           enabled, it will cause the tag above to be reported as text since
           &quot;LIST]&quot; is not a legal attribute name.

       $p-&gt;unbroken_text
       $p-&gt;unbroken_text( $bool )
           By default, blocks of text are given to the text handler as soon as
           possible (but the parser takes care always to break text at a
           boundary between whitespace and non-whitespace so single words and
           entities can always be decoded safely).  This might create breaks
           that make it hard to do transformations on the text. When this
           attribute is enabled, blocks of text are always reported in one
           piece.  This will delay the text event until the following (non-text)
           event has been recognized by the parser.

           Note that the &quot;offset&quot; argspec will give you the offset of the first
           segment of text and &quot;length&quot; is the combined length of the segments.
           Since there might be ignored tags in between, these numbers can&apos;t be
           used to directly index in the original document file.

       $p-&gt;utf8_mode
       $p-&gt;utf8_mode( $bool )
           Enable this option when parsing raw undecoded UTF-8.  This tells the
           parser that the entities expanded for strings reported by &quot;attr&quot;,
           @attr and &quot;dtext&quot; should be expanded as decoded UTF-8 so they end up
           compatible with the surrounding text.

           If &quot;utf8_mode&quot; is enabled then it is an error to pass strings
           containing characters with code above 255 to the parse() method, and
           the parse() method will croak if you try.

           Example: The Unicode character &quot;\x{2665}&quot; is &quot;\xE2\x99\xA5&quot; when
           UTF-8 encoded.  The character can also be represented by the entity
           &quot;&amp;hearts;&quot; or &quot;&amp;#x2665&quot;.  If we feed the parser:

             $p-&gt;parse(&quot;\xE2\x99\xA5&amp;hearts;&quot;);

           then &quot;dtext&quot; will be reported as &quot;\xE2\x99\xA5\x{2665}&quot; without
           &quot;utf8_mode&quot; enabled, but as &quot;\xE2\x99\xA5\xE2\x99\xA5&quot; when enabled.
           The later string is what you want.

           This option is only available with perl-5.8 or better.

       $p-&gt;xml_mode
       $p-&gt;xml_mode( $bool )
           Enabling this attribute changes the parser to allow some XML
           constructs.  This enables the behaviour controlled by individually by
           the &quot;case_sensitive&quot;, &quot;empty_element_tags&quot;, &quot;strict_names&quot; and
           &quot;xml_pic&quot; attributes and also suppresses special treatment of
           elements that are parsed as CDATA for HTML.

       $p-&gt;xml_pic
       $p-&gt;xml_pic( $bool )
           By default, processing instructions are terminated by &quot;&gt;&quot;. When this
           attribute is enabled, processing instructions are terminated by &quot;?&gt;&quot;
           instead.

       As markup and text is recognized, handlers are invoked.  The following
       method is used to set up handlers for different events:

       $p-&gt;handler( event =&gt; \&amp;subroutine, $argspec )
       $p-&gt;handler( event =&gt; $method_name, $argspec )
       $p-&gt;handler( event =&gt; \@accum, $argspec )
       $p-&gt;handler( event =&gt; &quot;&quot; );
       $p-&gt;handler( event =&gt; undef );
       $p-&gt;handler( event );
           This method assigns a subroutine, method, or array to handle an
           event.

           Event is one of &quot;text&quot;, &quot;start&quot;, &quot;end&quot;, &quot;declaration&quot;, &quot;comment&quot;,
           &quot;process&quot;, &quot;start_document&quot;, &quot;end_document&quot; or &quot;default&quot;.

           The &quot;\&amp;subroutine&quot; is a reference to a subroutine which is called to
           handle the event.

           The $method_name is the name of a method of $p which is called to
           handle the event.

           The @accum is an array that will hold the event information as sub-
           arrays.

           If the second argument is &quot;&quot;, the event is ignored.  If it is undef,
           the default handler is invoked for the event.

           The $argspec is a string that describes the information to be
           reported for the event.  Any requested information that does not
           apply to a specific event is passed as &quot;undef&quot;.  If argspec is
           omitted, then it is left unchanged.

           The return value from $p-&gt;handler is the old callback routine or a
           reference to the accumulator array.

           Any return values from handler callback routines/methods are always
           ignored.  A handler callback can request parsing to be aborted by
           invoking the $p-&gt;eof method.  A handler callback is not allowed to
           invoke the $p-&gt;parse() or $p-&gt;parse_file() method.  An exception will
           be raised if it tries.

           Examples:

               $p-&gt;handler(start =&gt;  &quot;start&quot;, &apos;self, attr, attrseq, text&apos; );

           This causes the &quot;start&quot; method of object $p to be called for &apos;start&apos;
           events.  The callback signature is $p-&gt;start(\%attr, \@attr_seq,
           $text).

               $p-&gt;handler(start =&gt;  \&amp;start, &apos;attr, attrseq, text&apos; );

           This causes subroutine start() to be called for &apos;start&apos; events.  The
           callback signature is start(\%attr, \@attr_seq, $text).

               $p-&gt;handler(start =&gt;  \@accum, &apos;&quot;S&quot;, attr, attrseq, text&apos; );

           This causes &apos;start&apos; event information to be saved in @accum.  The
           array elements will be [&apos;S&apos;, \%attr, \@attr_seq, $text].

              $p-&gt;handler(start =&gt; &quot;&quot;);

           This causes &apos;start&apos; events to be ignored.  It also suppresses
           invocations of any default handler for start events.  It is in most
           cases equivalent to $p-&gt;handler(start =&gt; sub {}), but is more
           efficient.  It is different from the empty-sub-handler in that
           &quot;skipped_text&quot; is not reset by it.

              $p-&gt;handler(start =&gt; undef);

           This causes no handler to be associated with start events.  If there
           is a default handler it will be invoked.

       Filters based on tags can be set up to limit the number of events
       reported.  The main bottleneck during parsing is often the huge number of
       callbacks made from the parser.  Applying filters can improve performance
       significantly.

       The following methods control filters:

       $p-&gt;ignore_elements( @tags )
           Both the &quot;start&quot; event and the &quot;end&quot; event as well as any events that
           would be reported in between are suppressed.  The ignored elements
           can contain nested occurrences of itself.  Example:

              $p-&gt;ignore_elements(qw(script style));

           The &quot;script&quot; and &quot;style&quot; tags will always nest properly since their
           content is parsed in CDATA mode.  For most other tags
           &quot;ignore_elements&quot; must be used with caution since HTML is often not
           well formed.

       $p-&gt;ignore_tags( @tags )
           Any &quot;start&quot; and &quot;end&quot; events involving any of the tags given are
           suppressed.  To reset the filter (i.e. don&apos;t suppress any &quot;start&quot; and
           &quot;end&quot; events), call &quot;ignore_tags&quot; without an argument.

       $p-&gt;report_tags( @tags )
           Any &quot;start&quot; and &quot;end&quot; events involving any of the tags not given are
           suppressed.  To reset the filter (i.e. report all &quot;start&quot; and &quot;end&quot;
           events), call &quot;report_tags&quot; without an argument.

       Internally, the system has two filter lists, one for &quot;report_tags&quot; and
       one for &quot;ignore_tags&quot;, and both filters are applied.  This effectively
       gives &quot;ignore_tags&quot; precedence over &quot;report_tags&quot;.

       Examples:

          $p-&gt;ignore_tags(qw(style));
          $p-&gt;report_tags(qw(script style));

       results in only &quot;script&quot; events being reported.

   Argspec
       Argspec is a string containing a comma-separated list that describes the
       information reported by the event.  The following argspec identifier
       names can be used:

       &quot;attr&quot;
           Attr causes a reference to a hash of attribute name/value pairs to be
           passed.

           Boolean attributes&apos; values are either the value set by
           $p-&gt;boolean_attribute_value, or the attribute name if no value has
           been set by $p-&gt;boolean_attribute_value.

           This passes undef except for &quot;start&quot; events.

           Unless &quot;xml_mode&quot; or &quot;case_sensitive&quot; is enabled, the attribute names
           are forced to lower case.

           General entities are decoded in the attribute values and one layer of
           matching quotes enclosing the attribute values is removed.

           The Unicode character set is assumed for entity decoding.

       @attr
           Basically the same as &quot;attr&quot;, but keys and values are passed as
           individual arguments and the original sequence of the attributes is
           kept.  The parameters passed will be the same as the @attr calculated
           here:

              @attr = map { $_ =&gt; $attr-&gt;{$_} } @$attrseq;

           assuming $attr and $attrseq here are the hash and array passed as the
           result of &quot;attr&quot; and &quot;attrseq&quot; argspecs.

           This passes no values for events besides &quot;start&quot;.

       &quot;attrseq&quot;
           Attrseq causes a reference to an array of attribute names to be
           passed.  This can be useful if you want to walk the &quot;attr&quot; hash in
           the original sequence.
&#12;           This passes undef except for &quot;start&quot; events.

           Unless &quot;xml_mode&quot; or &quot;case_sensitive&quot; is enabled, the attribute names
           are forced to lower case.

       &quot;column&quot;
           Column causes the column number of the start of the event to be
           passed.  The first column on a line is 0.

       &quot;dtext&quot;
           Dtext causes the decoded text to be passed.  General entities are
           automatically decoded unless the event was inside a CDATA section or
           was between literal start and end tags (&quot;script&quot;, &quot;style&quot;, &quot;xmp&quot;,
           &quot;iframe&quot;, &quot;title&quot;, &quot;textarea&quot; and &quot;plaintext&quot;).

           The Unicode character set is assumed for entity decoding.  With Perl
           version 5.6 or earlier only the Latin-1 range is supported, and
           entities for characters outside the range 0..255 are left unchanged.

           This passes undef except for &quot;text&quot; events.

       &quot;event&quot;
           Event causes the event name to be passed.

           The event name is one of &quot;text&quot;, &quot;start&quot;, &quot;end&quot;, &quot;declaration&quot;,
           &quot;comment&quot;, &quot;process&quot;, &quot;start_document&quot; or &quot;end_document&quot;.

       &quot;is_cdata&quot;
           Is_cdata causes a TRUE value to be passed if the event is inside a
           CDATA section or between literal start and end tags (&quot;script&quot;,
           &quot;style&quot;, &quot;xmp&quot;, &quot;iframe&quot;, &quot;title&quot;, &quot;textarea&quot; and &quot;plaintext&quot;).

           if the flag is FALSE for a text event, then you should normally
           either use &quot;dtext&quot; or decode the entities yourself before the text is
           processed further.

       &quot;length&quot;
           Length causes the number of bytes of the source text of the event to
           be passed.

       &quot;line&quot;
           Line causes the line number of the start of the event to be passed.
           The first line in the document is 1.  Line counting doesn&apos;t start
           until at least one handler requests this value to be reported.

       &quot;offset&quot;
           Offset causes the byte position in the HTML document of the start of
           the event to be passed.  The first byte in the document has offset 0.

       &quot;offset_end&quot;
           Offset_end causes the byte position in the HTML document of the end
           of the event to be passed.  This is the same as &quot;offset&quot; + &quot;length&quot;.

       &quot;self&quot;
           Self causes the current object to be passed to the handler.  If the
           handler is a method, this must be the first element in the argspec.

           An alternative to passing self as an argspec is to register closures
           that capture $self by themselves as handlers.  Unfortunately this
           creates circular references which prevent the HTML::Parser object
           from being garbage collected.  Using the &quot;self&quot; argspec avoids this
           problem.

       &quot;skipped_text&quot;
           Skipped_text returns the concatenated text of all the events that
           have been skipped since the last time an event was reported.  Events
           might be skipped because no handler is registered for them or because
           some filter applies.  Skipped text also includes marked section
           markup, since there are no events that can catch it.

           If an &quot;&quot;-handler is registered for an event, then the text for this
           event is not included in &quot;skipped_text&quot;.  Skipped text both before
           and after the &quot;&quot;-event is included in the next reported
           &quot;skipped_text&quot;.

       &quot;tag&quot;
           Same as &quot;tagname&quot;, but prefixed with &quot;/&quot; if it belongs to an &quot;end&quot;
           event and &quot;!&quot; for a declaration.  The &quot;tag&quot; does not have any prefix
           for &quot;start&quot; events, and is in this case identical to &quot;tagname&quot;.

       &quot;tagname&quot;
           This is the element name (or generic identifier in SGML jargon) for
           start and end tags.  Since HTML is case insensitive, this name is
           forced to lower case to ease string matching.

           Since XML is case sensitive, the tagname case is not changed when
           &quot;xml_mode&quot; is enabled.  The same happens if the &quot;case_sensitive&quot;
           attribute is set.

           The declaration type of declaration elements is also passed as a
           tagname, even if that is a bit strange.  In fact, in the current
           implementation tagname is identical to &quot;token0&quot; except that the name
           may be forced to lower case.

       &quot;token0&quot;
           Token0 causes the original text of the first token string to be
           passed.  This should always be the same as $tokens-&gt;[0].

           For &quot;declaration&quot; events, this is the declaration type.

           For &quot;start&quot; and &quot;end&quot; events, this is the tag name.

           For &quot;process&quot; and non-strict &quot;comment&quot; events, this is everything
           inside the tag.

           This passes undef if there are no tokens in the event.

       &quot;tokenpos&quot;
           Tokenpos causes a reference to an array of token positions to be
           passed.  For each string that appears in &quot;tokens&quot;, this array
           contains two numbers.  The first number is the offset of the start of
           the token in the original &quot;text&quot; and the second number is the length
           of the token.

           Boolean attributes in a &quot;start&quot; event will have (0,0) for the
           attribute value offset and length.

           This passes undef if there are no tokens in the event (e.g., &quot;text&quot;)
           and for artificial &quot;end&quot; events triggered by empty element tags.

           If you are using these offsets and lengths to modify &quot;text&quot;, you
           should either work from right to left, or be very careful to
           calculate the changes to the offsets.

       &quot;tokens&quot;
           Tokens causes a reference to an array of token strings to be passed.
           The strings are exactly as they were found in the original text, no
           decoding or case changes are applied.

           For &quot;declaration&quot; events, the array contains each word, comment, and
           delimited string starting with the declaration type.

           For &quot;comment&quot; events, this contains each sub-comment.  If
           $p-&gt;strict_comments is disabled, there will be only one sub-comment.

           For &quot;start&quot; events, this contains the original tag name followed by
           the attribute name/value pairs.  The values of boolean attributes
           will be either the value set by $p-&gt;boolean_attribute_value, or the
           attribute name if no value has been set by
           $p-&gt;boolean_attribute_value.

           For &quot;end&quot; events, this contains the original tag name (always one
           token).

           For &quot;process&quot; events, this contains the process instructions (always
           one token).

           This passes &quot;undef&quot; for &quot;text&quot; events.

       &quot;text&quot;
           Text causes the source text (including markup element delimiters) to
           be passed.

       &quot;undef&quot;
           Pass an undefined value.  Useful as padding where the same handler
           routine is registered for multiple events.

       &apos;...&apos;
           A literal string of 0 to 255 characters enclosed in single (&apos;) or
           double (&quot;) quotes is passed as entered.

       The whole argspec string can be wrapped up in &apos;@{...}&apos; to signal that the
       resulting event array should be flattened.  This only makes a difference
       if an array reference is used as the handler target.  Consider this
       example:

          $p-&gt;handler(text =&gt; [], &apos;text&apos;);
          $p-&gt;handler(text =&gt; [], &apos;@{text}&apos;]);

       With two text events; &quot;foo&quot;, &quot;bar&quot;; then the first example will end up
       with [[&quot;foo&quot;], [&quot;bar&quot;]] and the second with [&quot;foo&quot;, &quot;bar&quot;] in the handler
       target array.

   Events
       Handlers for the following events can be registered:

       &quot;comment&quot;
           This event is triggered when a markup comment is recognized.

           Example:

             &lt;!-- This is a comment -- -- So is this --&gt;

       &quot;declaration&quot;
           This event is triggered when a markup declaration is recognized.

           For typical HTML documents, the only declaration you are likely to
           find is &lt;!DOCTYPE ...&gt;.

           Example:

             &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;
                 &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;

           DTDs inside &lt;!DOCTYPE ...&gt; will confuse HTML::Parser.

       &quot;default&quot;
           This event is triggered for events that do not have a specific
           handler.  You can set up a handler for this event to catch stuff you
           did not want to catch explicitly.

       &quot;end&quot;
           This event is triggered when an end tag is recognized.

           Example:

             &lt;/A&gt;

       &quot;end_document&quot;
           This event is triggered when $p-&gt;eof is called and after any
           remaining text is flushed.  There is no document text associated with
           this event.
&#12;       &quot;process&quot;
           This event is triggered when a processing instructions markup is
           recognized.

           The format and content of processing instructions are system and
           application dependent.

           Examples:

             &lt;? HTML processing instructions &gt;
             &lt;? XML processing instructions ?&gt;

       &quot;start&quot;
           This event is triggered when a start tag is recognized.

           Example:

             &lt;A HREF=&quot;http://www.perl.com/&quot;&gt;

       &quot;start_document&quot;
           This event is triggered before any other events for a new document.
           A handler for it can be used to initialize stuff.  There is no
           document text associated with this event.

       &quot;text&quot;
           This event is triggered when plain text (characters) is recognized.
           The text may contain multiple lines.  A sequence of text may be
           broken between several text events unless $p-&gt;unbroken_text is
           enabled.

           The parser will make sure that it does not break a word or a sequence
           of whitespace between two text events.

   Unicode
       &quot;HTML::Parser&quot; can parse Unicode strings when running under perl-5.8 or
       better.  If Unicode is passed to $p-&gt;parse() then chunks of Unicode will
       be reported to the handlers.  The offset and length argspecs will also
       report their position in terms of characters.

       It is safe to parse raw undecoded UTF-8 if you either avoid decoding
       entities and make sure to not use argspecs that do, or enable the
       &quot;utf8_mode&quot; for the parser.  Parsing of undecoded UTF-8 might be useful
       when parsing from a file where you need the reported offsets and lengths
       to match the byte offsets in the file.

       If a filename is passed to $p-&gt;parse_file() then the file will be read in
       binary mode.  This will be fine if the file contains only ASCII or
       Latin-1 characters.  If the file contains UTF-8 encoded text then care
       must be taken when decoding entities as described in the previous
       paragraph, but better is to open the file with the UTF-8 layer so that it
       is decoded properly:

          open(my $fh, &quot;&lt;:utf8&quot;, &quot;index.html&quot;) || die &quot;...: $!&quot;;
          $p-&gt;parse_file($fh);

       If the file contains text encoded in a charset besides ASCII, Latin-1 or
       UTF-8 then decoding will always be needed.

VERSION 2 COMPATIBILITY
       When an &quot;HTML::Parser&quot; object is constructed with no arguments, a set of
       handlers is automatically provided that is compatible with the old
       HTML::Parser version 2 callback methods.

       This is equivalent to the following method calls:

          $p-&gt;handler(start   =&gt; &quot;start&quot;,   &quot;self, tagname, attr, attrseq, text&quot;);
          $p-&gt;handler(end     =&gt; &quot;end&quot;,     &quot;self, tagname, text&quot;);
          $p-&gt;handler(text    =&gt; &quot;text&quot;,    &quot;self, text, is_cdata&quot;);
          $p-&gt;handler(process =&gt; &quot;process&quot;, &quot;self, token0, text&quot;);
          $p-&gt;handler(comment =&gt;
                    sub {
                        my($self, $tokens) = @_;
                        for (@$tokens) {$self-&gt;comment($_);}},
                    &quot;self, tokens&quot;);
          $p-&gt;handler(declaration =&gt;
                    sub {
                        my $self = shift;
                        $self-&gt;declaration(substr($_[0], 2, -1));},
                    &quot;self, text&quot;);

       Setting up these handlers can also be requested with the &quot;api_version =&gt;
       2&quot; constructor option.

SUBCLASSING
       The &quot;HTML::Parser&quot; class is subclassable.  Parser objects are plain
       hashes and &quot;HTML::Parser&quot; reserves only hash keys that start with
       &quot;_hparser&quot;.  The parser state can be set up by invoking the init()
       method, which takes the same arguments as new().

EXAMPLES
       The first simple example shows how you might strip out comments from an
       HTML document.  We achieve this by setting up a comment handler that does
       nothing and a default handler that will print out anything else:

         use HTML::Parser;
         HTML::Parser-&gt;new(default_h =&gt; [sub { print shift }, &apos;text&apos;],
                           comment_h =&gt; [&quot;&quot;],
                          )-&gt;parse_file(shift || die) || die $!;

       An alternative implementation is:

         use HTML::Parser;
         HTML::Parser-&gt;new(end_document_h =&gt; [sub { print shift },
                                              &apos;skipped_text&apos;],
                           comment_h      =&gt; [&quot;&quot;],
                          )-&gt;parse_file(shift || die) || die $!;

       This will in most cases be much more efficient since only a single
       callback will be made.

       The next example prints out the text that is inside the &lt;title&gt; element
       of an HTML document.  Here we start by setting up a start handler.  When
       it sees the title start tag it enables a text handler that prints any
       text found and an end handler that will terminate parsing as soon as the
       title end tag is seen:

         use HTML::Parser ();

         sub start_handler
         {
           return if shift ne &quot;title&quot;;
           my $self = shift;
           $self-&gt;handler(text =&gt; sub { print shift }, &quot;dtext&quot;);
           $self-&gt;handler(end  =&gt; sub { shift-&gt;eof if shift eq &quot;title&quot;; },
                                  &quot;tagname,self&quot;);
         }

         my $p = HTML::Parser-&gt;new(api_version =&gt; 3);
         $p-&gt;handler( start =&gt; \&amp;start_handler, &quot;tagname,self&quot;);
         $p-&gt;parse_file(shift || die) || die $!;
         print &quot;\n&quot;;

       On a Debian box, more examples can be found in the
       /usr/share/doc/libhtml-parser-perl/examples directory.  The program
       &quot;hrefsub&quot; shows how you can edit all links found in a document and
       &quot;htextsub&quot; how to edit the text only; the program &quot;hstrip&quot; shows how you
       can strip out certain tags/elements and/or attributes; and the program
       &quot;htext&quot; show how to obtain the plain text, but not any script/style
       content.

       You can browse the eg/ directory online from the [Browse] link on the
       http://search.cpan.org/~gaas/HTML-Parser/ page.

BUGS
       The &lt;style&gt; and &lt;script&gt; sections do not end with the first &quot;&lt;/&quot;, but
       need the complete corresponding end tag.  The standard behaviour is not
       really practical.

       When the strict_comment option is enabled, we still recognize comments
       where there is something other than whitespace between even and odd &quot;--&quot;
       markers.
&#12;       Once $p-&gt;boolean_attribute_value has been set, there is no way to restore
       the default behaviour.

       There is currently no way to get both quote characters into the same
       literal argspec.

       Empty tags, e.g. &quot;&lt;&gt;&quot; and &quot;&lt;/&gt;&quot;, are not recognized.  SGML allows them to
       repeat the previous start tag or close the previous start tag
       respectively.

       NET tags, e.g. &quot;code/.../&quot; are not recognized.  This is SGML shorthand
       for &quot;&lt;code&gt;...&lt;/code&gt;&quot;.

       Unclosed start or end tags, e.g. &quot;&lt;tt&lt;b&gt;...&lt;/b&lt;/tt&gt;&quot; are not recognized.

DIAGNOSTICS
       The following messages may be produced by HTML::Parser.  The notation in
       this listing is the same as used in perldiag:

       Not a reference to a hash
           (F) The object blessed into or subclassed from HTML::Parser is not a
           hash as required by the HTML::Parser methods.

       Bad signature in parser state object at %p
           (F) The _hparser_xs_state element does not refer to a valid state
           structure.  Something must have changed the internal value stored in
           this hash element, or the memory has been overwritten.

       _hparser_xs_state element is not a reference
           (F) The _hparser_xs_state element has been destroyed.

       Can&apos;t find &apos;_hparser_xs_state&apos; element in HTML::Parser hash
           (F) The _hparser_xs_state element is missing from the parser hash.
           It was either deleted, or not created when the object was created.

       API version %s not supported by HTML::Parser %s
           (F) The constructor option &apos;api_version&apos; with an argument greater
           than or equal to 4 is reserved for future extensions.

       Bad constructor option &apos;%s&apos;
           (F) An unknown constructor option key was passed to the new() or
           init() methods.

       Parse loop not allowed
           (F) A handler invoked the parse() or parse_file() method.  This is
           not permitted.

       marked sections not supported
           (F) The $p-&gt;marked_sections() method was invoked in a HTML::Parser
           module that was compiled without support for marked sections.

       Unknown boolean attribute (%d)
           (F) Something is wrong with the internal logic that set up aliases
           for boolean attributes.

       Only code or array references allowed as handler
           (F) The second argument for $p-&gt;handler must be either a subroutine
           reference, then name of a subroutine or method, or a reference to an
           array.

       No handler for %s events
           (F) The first argument to $p-&gt;handler must be a valid event name;
           i.e. one of &quot;start&quot;, &quot;end&quot;, &quot;text&quot;, &quot;process&quot;, &quot;declaration&quot; or
           &quot;comment&quot;.

       Unrecognized identifier %s in argspec
           (F) The identifier is not a known argspec name.  Use one of the names
           mentioned in the argspec section above.

       Literal string is longer than 255 chars in argspec
           (F) The current implementation limits the length of literals in an
           argspec to 255 characters.  Make the literal shorter.

       Backslash reserved for literal string in argspec
           (F) The backslash character &quot;\&quot; is not allowed in argspec literals.
           It is reserved to permit quoting inside a literal in a later version.

       Unterminated literal string in argspec
           (F) The terminating quote character for a literal was not found.

       Bad argspec (%s)
           (F) Only identifier names, literals, spaces and commas are allowed in
           argspecs.

       Missing comma separator in argspec
           (F) Identifiers in an argspec must be separated with &quot;,&quot;.

       Parsing of undecoded UTF-8 will give garbage when decoding entities
           (W) The first chunk parsed appears to contain undecoded UTF-8 and one
           or more argspecs that decode entities are used for the callback
           handlers.

           The result of decoding will be a mix of encoded and decoded
           characters for any entities that expand to characters with code above
           127.  This is not a good thing.

           The recommened solution is to apply Encode::decode_utf8() on the data
           before feeding it to the $p-&gt;parse().  For $p-&gt;parse_file() pass a
           file that has been opened in &quot;:utf8&quot; mode.

           The alternative solution is to enable the &quot;utf8_mode&quot; and not decode
           before passing strings to $p-&gt;parse().  The parser can process raw
           undecoded UTF-8 sanely if the &quot;utf8_mode&quot; is enabled, or if the
           &quot;attr&quot;, &quot;@attr&quot; or &quot;dtext&quot; argspecs are avoided.

       Parsing string decoded with wrong endianness
           (W) The first character in the document is U+FFFE.  This is not a
           legal Unicode character but a byte swapped BOM.  The result of
           parsing will likely be garbage.

       Parsing of undecoded UTF-32
           (W) The parser found the Unicode UTF-32 BOM signature at the start of
           the document.  The result of parsing will likely be garbage.

       Parsing of undecoded UTF-16
           (W) The parser found the Unicode UTF-16 BOM signature at the start of
           the document.  The result of parsing will likely be garbage.

SEE ALSO
       HTML::Entities, HTML::PullParser, HTML::TokeParser, HTML::HeadParser,
       HTML::LinkExtor, HTML::Form

       HTML::TreeBuilder (part of the HTML-Tree distribution)

       &lt;http://www.w3.org/TR/html4/&gt;

       More information about marked sections and processing instructions may be
       found at http://www.is-thought.co.uk/book/sgml-8.htm &lt;http://www.is-
       thought.co.uk/book/sgml-8.htm&gt;.

COPYRIGHT
        Copyright 1996-2008 Gisle Aas. All rights reserved.
        Copyright 1999-2000 Michael A. Chase.  All rights reserved.

       This library is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.



perl v5.14.2                       2012-04-01                        Parser(3pm)

</pre></body></html>
