<html>
<head><meta charset=utf-8/>
<title>HTTP::Request::Common - Construct common HTTP::Request objects</title></head>
<body><pre>

HTTP::Request::Common(3User Contributed Perl DocumentaHTTP::Request::Common(3pm)



NAME
       HTTP::Request::Common - Construct common HTTP::Request objects

SYNOPSIS
         use HTTP::Request::Common;
         $ua = LWP::UserAgent-&gt;new;
         $ua-&gt;request(GET &apos;http://www.sn.no/&apos;);
         $ua-&gt;request(POST &apos;http://somewhere/foo&apos;, [foo =&gt; bar, bar =&gt; foo]);

DESCRIPTION
       This module provide functions that return newly created &quot;HTTP::Request&quot;
       objects.  These functions are usually more convenient to use than the
       standard &quot;HTTP::Request&quot; constructor for the most common requests.  The
       following functions are provided:

       GET $url
       GET $url, Header =&gt; Value,...
           The GET() function returns an &quot;HTTP::Request&quot; object initialized with
           the &quot;GET&quot; method and the specified URL.  It is roughly equivalent to
           the following call

             HTTP::Request-&gt;new(
                GET =&gt; $url,
                HTTP::Headers-&gt;new(Header =&gt; Value,...),
             )

           but is less cluttered.  What is different is that a header named
           &quot;Content&quot; will initialize the content part of the request instead of
           setting a header field.  Note that GET requests should normally not
           have a content, so this hack makes more sense for the PUT() and
           POST() functions described below.

           The get(...) method of &quot;LWP::UserAgent&quot; exists as a shortcut for
           $ua-&gt;request(GET ...).

       HEAD $url
       HEAD $url, Header =&gt; Value,...
           Like GET() but the method in the request is &quot;HEAD&quot;.

           The head(...)  method of &quot;LWP::UserAgent&quot; exists as a shortcut for
           $ua-&gt;request(HEAD ...).

       PUT $url
       PUT $url, Header =&gt; Value,...
       PUT $url, Header =&gt; Value,..., Content =&gt; $content
           Like GET() but the method in the request is &quot;PUT&quot;.

           The content of the request can be specified using the &quot;Content&quot;
           pseudo-header.  This steals a bit of the header field namespace as
           there is no way to directly specify a header that is actually called
           &quot;Content&quot;.  If you really need this you must update the request
           returned in a separate statement.

       DELETE $url
       DELETE $url, Header =&gt; Value,...
           Like GET() but the method in the request is &quot;DELETE&quot;.  This function
           is not exported by default.

       POST $url
       POST $url, Header =&gt; Value,...
       POST $url, $form_ref, Header =&gt; Value,...
       POST $url, Header =&gt; Value,..., Content =&gt; $form_ref
       POST $url, Header =&gt; Value,..., Content =&gt; $content
           This works mostly like PUT() with &quot;POST&quot; as the method, but this
           function also takes a second optional array or hash reference
           parameter $form_ref.  As for PUT() the content can also be specified
           directly using the &quot;Content&quot; pseudo-header, and you may also provide
           the $form_ref this way.

           The $form_ref argument can be used to pass key/value pairs for the
           form content.  By default we will initialize a request using the
           &quot;application/x-www-form-urlencoded&quot; content type.  This means that
           you can emulate an HTML &lt;form&gt; POSTing like this:

             POST &apos;http://www.perl.org/survey.cgi&apos;,
                  [ name   =&gt; &apos;Gisle Aas&apos;,
                    email  =&gt; &apos;gisle@aas.no&apos;,
                    gender =&gt; &apos;M&apos;,
                    born   =&gt; &apos;1964&apos;,
                    perc   =&gt; &apos;3%&apos;,
                  ];

           This will create an HTTP::Request object that looks like this:

             POST http://www.perl.org/survey.cgi
             Content-Length: 66
             Content-Type: application/x-www-form-urlencoded

             name=Gisle%20Aas&amp;email=gisle%40aas.no&amp;gender=M&amp;born=1964&amp;perc=3%25

           Multivalued form fields can be specified by either repeating the
           field name or by passing the value as an array reference.

           The POST method also supports the &quot;multipart/form-data&quot; content used
           for Form-based File Upload as specified in RFC 1867.  You trigger
           this content format by specifying a content type of &apos;form-data&apos; as
           one of the request headers.  If one of the values in the $form_ref is
           an array reference, then it is treated as a file part specification
           with the following interpretation:

             [ $file, $filename, Header =&gt; Value... ]
             [ undef, $filename, Header =&gt; Value,..., Content =&gt; $content ]

           The first value in the array ($file) is the name of a file to open.
           This file will be read and its content placed in the request.  The
           routine will croak if the file can&apos;t be opened.  Use an &quot;undef&quot; as
           $file value if you want to specify the content directly with a
           &quot;Content&quot; header.  The $filename is the filename to report in the
           request.  If this value is undefined, then the basename of the $file
           will be used.  You can specify an empty string as $filename if you
           want to suppress sending the filename when you provide a $file value.

           If a $file is provided by no &quot;Content-Type&quot; header, then
           &quot;Content-Type&quot; and &quot;Content-Encoding&quot; will be filled in automatically
           with the values returned by LWP::MediaTypes::guess_media_type()

           Sending my ~/.profile to the survey used as example above can be
           achieved by this:

             POST &apos;http://www.perl.org/survey.cgi&apos;,
                  Content_Type =&gt; &apos;form-data&apos;,
                  Content      =&gt; [ name  =&gt; &apos;Gisle Aas&apos;,
                                    email =&gt; &apos;gisle@aas.no&apos;,
                                    gender =&gt; &apos;M&apos;,
                                    born   =&gt; &apos;1964&apos;,
                                    init   =&gt; [&quot;$ENV{HOME}/.profile&quot;],
                                  ]

           This will create an HTTP::Request object that almost looks this (the
           boundary and the content of your ~/.profile is likely to be
           different):

             POST http://www.perl.org/survey.cgi
             Content-Length: 388
             Content-Type: multipart/form-data; boundary=&quot;6G+f&quot;
&#12;             --6G+f
             Content-Disposition: form-data; name=&quot;name&quot;

             Gisle Aas
             --6G+f
             Content-Disposition: form-data; name=&quot;email&quot;

             gisle@aas.no
             --6G+f
             Content-Disposition: form-data; name=&quot;gender&quot;

             M
             --6G+f
             Content-Disposition: form-data; name=&quot;born&quot;

             1964
             --6G+f
             Content-Disposition: form-data; name=&quot;init&quot;; filename=&quot;.profile&quot;
             Content-Type: text/plain

             PATH=/local/perl/bin:$PATH
             export PATH

             --6G+f--

           If you set the $DYNAMIC_FILE_UPLOAD variable (exportable) to some
           TRUE value, then you get back a request object with a subroutine
           closure as the content attribute.  This subroutine will read the
           content of any files on demand and return it in suitable chunks.
           This allow you to upload arbitrary big files without using lots of
           memory.  You can even upload infinite files like /dev/audio if you
           wish; however, if the file is not a plain file, there will be no
           Content-Length header defined for the request.  Not all servers (or
           server applications) like this.  Also, if the file(s) change in size
           between the time the Content-Length is calculated and the time that
           the last chunk is delivered, the subroutine will &quot;Croak&quot;.

           The post(...)  method of &quot;LWP::UserAgent&quot; exists as a shortcut for
           $ua-&gt;request(POST ...).

SEE ALSO
       HTTP::Request, LWP::UserAgent

COPYRIGHT
       Copyright 1997-2004, Gisle Aas

       This library is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.



perl v5.14.2                       2012-02-16         HTTP::Request::Common(3pm)

</pre></body></html>
