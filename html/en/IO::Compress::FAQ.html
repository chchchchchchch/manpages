<html>
<head><meta charset=utf-8/>
<title>IO::Compress::FAQ -- Frequently Asked Questions about IO::Compress</title></head>
<body><pre>

IO::Compress::FAQ(3pm) User Contributed Perl DocumentationIO::Compress::FAQ(3pm)



NAME
       IO::Compress::FAQ -- Frequently Asked Questions about IO::Compress

DESCRIPTION
       Common questions answered.

GENERAL
   Compatibility with Unix compress/uncompress.
       Although &quot;Compress::Zlib&quot; has a pair of functions called &quot;compress&quot; and
       &quot;uncompress&quot;, they are not related to the Unix programs of the same name.
       The &quot;Compress::Zlib&quot; module is not compatible with Unix &quot;compress&quot;.

       If you have the &quot;uncompress&quot; program available, you can use this to read
       compressed files

           open F, &quot;uncompress -c $filename |&quot;;
           while (&lt;F&gt;)
           {
               ...

       Alternatively, if you have the &quot;gunzip&quot; program available, you can use
       this to read compressed files

           open F, &quot;gunzip -c $filename |&quot;;
           while (&lt;F&gt;)
           {
               ...

       and this to write compress files, if you have the &quot;compress&quot; program
       available

           open F, &quot;| compress -c $filename &quot;;
           print F &quot;data&quot;;
           ...
           close F ;

   Accessing .tar.Z files
       The &quot;Archive::Tar&quot; module can optionally use &quot;Compress::Zlib&quot; (via the
       &quot;IO::Zlib&quot; module) to access tar files that have been compressed with
       &quot;gzip&quot;. Unfortunately tar files compressed with the Unix &quot;compress&quot;
       utility cannot be read by &quot;Compress::Zlib&quot; and so cannot be directly
       accessed by &quot;Archive::Tar&quot;.

       If the &quot;uncompress&quot; or &quot;gunzip&quot; programs are available, you can use one
       of these workarounds to read &quot;.tar.Z&quot; files from &quot;Archive::Tar&quot;

       Firstly with &quot;uncompress&quot;

           use strict;
           use warnings;
           use Archive::Tar;

           open F, &quot;uncompress -c $filename |&quot;;
           my $tar = Archive::Tar-&gt;new(*F);
           ...

       and this with &quot;gunzip&quot;

           use strict;
           use warnings;
           use Archive::Tar;
&#12;           open F, &quot;gunzip -c $filename |&quot;;
           my $tar = Archive::Tar-&gt;new(*F);
           ...

       Similarly, if the &quot;compress&quot; program is available, you can use this to
       write a &quot;.tar.Z&quot; file

           use strict;
           use warnings;
           use Archive::Tar;
           use IO::File;

           my $fh = new IO::File &quot;| compress -c &gt;$filename&quot;;
           my $tar = Archive::Tar-&gt;new();
           ...
           $tar-&gt;write($fh);
           $fh-&gt;close ;

   How do I recompress using a different compression?
       This is easier that you might expect if you realise that all the
       &quot;IO::Compress::*&quot; objects are derived from &quot;IO::File&quot; and that all the
       &quot;IO::Uncompress::*&quot; modules can read from an &quot;IO::File&quot; filehandle.

       So, for example, say you have a file compressed with gzip that you want
       to recompress with bzip2. Here is all that is needed to carry out the
       recompression.

           use IO::Uncompress::Gunzip &apos;:all&apos;;
           use IO::Compress::Bzip2 &apos;:all&apos;;

           my $gzipFile = &quot;somefile.gz&quot;;
           my $bzipFile = &quot;somefile.bz2&quot;;

           my $gunzip = new IO::Uncompress::Gunzip $gzipFile
               or die &quot;Cannot gunzip $gzipFile: $GunzipError\n&quot; ;

           bzip2 $gunzip =&gt; $bzipFile
               or die &quot;Cannot bzip2 to $bzipFile: $Bzip2Error\n&quot; ;

       Note, there is a limitation of this technique. Some compression file
       formats store extra information along with the compressed data payload.
       For example, gzip can optionally store the original filename and Zip
       stores a lot of information about the original file. If the original
       compressed file contains any of this extra information, it will not be
       transferred to the new compressed file usign the technique above.

ZIP
   What Compression Types do IO::Compress::Zip &amp; IO::Uncompress::Unzip support?
       The following compression formats are supported by &quot;IO::Compress::Zip&quot;
       and &quot;IO::Uncompress::Unzip&quot;

       &#183;    Store (method 0)

            No compression at all.

       &#183;    Deflate (method 8)

            This is the default compression used when creating a zip file with
            &quot;IO::Compress::Zip&quot;.

       &#183;    Bzip2 (method 12)

            Only supported if the &quot;IO-Compress-Bzip2&quot; module is installed.

       &#183;    Lzma (method 14)
&#12;            Only supported if the &quot;IO-Compress-Lzma&quot; module is installed.

   Can I Read/Write Zip files larger the 4 Gig?
       Yes, both the &quot;IO-Compress-Zip&quot; and &quot;IO-Uncompress-Unzip&quot;  modules
       support the zip feature called Zip64. That allows them to read/write
       files/buffers larger than 4Gig.

       If you are creating a Zip file using the one-shot interface, and any of
       the input files is greater than 4Gig, a zip64 complaint zip file will be
       created.

           zip &quot;really-large-file&quot; =&gt; &quot;my.zip&quot;;

       Similarly with the one-shot interface, if the input is a buffer larger
       than 4 Gig, a zip64 complaint zip file will be created.

           zip \$really_large_buffer =&gt; &quot;my.zip&quot;;

       The one-shot interface allows you to force the creation of a zip64 zip
       file by including the &quot;Zip64&quot; option.

           zip $filehandle =&gt; &quot;my.zip&quot;, Zip64 =&gt; 1;

       If you want to create a zip64 zip file with the OO interface you must
       specify the &quot;Zip64&quot; option.

           my $zip = new IO::Compress::Zip &quot;whatever&quot;, Zip64 =&gt; 1;

       When uncompressing with &quot;IO-Uncompress-Unzip&quot;, it will automatically
       detect if the zip file is zip64.

       If you intend to manipulate the Zip64 zip files created with
       &quot;IO-Compress-Zip&quot; using an external zip/unzip, make sure that it supports
       Zip64.

       In particular, if you are using Info-Zip you need to have zip version 3.x
       or better to update a Zip64 archive and unzip version 6.x to read a zip64
       archive.

   Can I write more that 64K entries is a Zip files?
       Yes. Zip64 allows this. See previous question.

   Zip Resources
       The primary reference for zip files is the &quot;appnote&quot; document available
       at &lt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&gt;

       An alternatively is the Info-Zip appnote. This is available from
       ftp://ftp.info-zip.org/pub/infozip/doc/ &lt;ftp://ftp.info-
       zip.org/pub/infozip/doc/&gt;

GZIP
   Gzip Resources
       The primary reference for gzip files is RFC 1952
       &lt;http://www.faqs.org/rfcs/rfc1952.html&gt;

       The primary site for gzip is http://www.gzip.org.

ZLIB
   Zlib Resources
       The primary site for the zlib compression library is http://www.zlib.org.

HTTP &amp; NETWORK
   Apache::GZip Revisited
       Below is a mod_perl Apache compression module, called &quot;Apache::GZip&quot;,
       taken from
       http://perl.apache.org/docs/tutorials/tips/mod_perl_tricks/mod_perl_tricks.html#On_the_Fly_Compression

         package Apache::GZip;
         #File: Apache::GZip.pm

         use strict vars;
         use Apache::Constants &apos;:common&apos;;
         use Compress::Zlib;
         use IO::File;
         use constant GZIP_MAGIC =&gt; 0x1f8b;
         use constant OS_MAGIC =&gt; 0x03;

         sub handler {
             my $r = shift;
             my ($fh,$gz);
             my $file = $r-&gt;filename;
             return DECLINED unless $fh=IO::File-&gt;new($file);
             $r-&gt;header_out(&apos;Content-Encoding&apos;=&gt;&apos;gzip&apos;);
             $r-&gt;send_http_header;
             return OK if $r-&gt;header_only;

             tie *STDOUT,&apos;Apache::GZip&apos;,$r;
             print($_) while &lt;$fh&gt;;
             untie *STDOUT;
             return OK;
         }

         sub TIEHANDLE {
             my($class,$r) = @_;
             # initialize a deflation stream
             my $d = deflateInit(-WindowBits=&gt;-MAX_WBITS()) || return undef;

             # gzip header -- don&apos;t ask how I found out
             $r-&gt;print(pack(&quot;nccVcc&quot;,GZIP_MAGIC,Z_DEFLATED,0,time(),0,OS_MAGIC));

             return bless { r   =&gt; $r,
                            crc =&gt;  crc32(undef),
                            d   =&gt; $d,
                            l   =&gt;  0
                          },$class;
         }

         sub PRINT {
             my $self = shift;
             foreach (@_) {
               # deflate the data
               my $data = $self-&gt;{d}-&gt;deflate($_);
               $self-&gt;{r}-&gt;print($data);
               # keep track of its length and crc
               $self-&gt;{l} += length($_);
               $self-&gt;{crc} = crc32($_,$self-&gt;{crc});
             }
         }

         sub DESTROY {
            my $self = shift;

            # flush the output buffers
            my $data = $self-&gt;{d}-&gt;flush;
            $self-&gt;{r}-&gt;print($data);

            # print the CRC and the total length (uncompressed)
            $self-&gt;{r}-&gt;print(pack(&quot;LL&quot;,@{$self}{qw/crc l/}));
         }

         1;
&#12;       Here&apos;s the Apache configuration entry you&apos;ll need to make use of it.
       Once set it will result in everything in the /compressed directory will
       be compressed automagically.

         &lt;Location /compressed&gt;
            SetHandler  perl-script
            PerlHandler Apache::GZip
         &lt;/Location&gt;

       Although at first sight there seems to be quite a lot going on in
       &quot;Apache::GZip&quot;, you could sum up what the code was doing as follows --
       read the contents of the file in &quot;$r-&gt;filename&quot;, compress it and write
       the compressed data to standard output. That&apos;s all.

       This code has to jump through a few hoops to achieve this because

       1.  The gzip support in &quot;Compress::Zlib&quot; version 1.x can only work with a
           real filesystem filehandle. The filehandles used by Apache modules
           are not associated with the filesystem.

       2.  That means all the gzip support has to be done by hand - in this case
           by creating a tied filehandle to deal with creating the gzip header
           and trailer.

       &quot;IO::Compress::Gzip&quot; doesn&apos;t have that filehandle limitation (this was
       one of the reasons for writing it in the first place). So if
       &quot;IO::Compress::Gzip&quot; is used instead of &quot;Compress::Zlib&quot; the whole tied
       filehandle code can be removed. Here is the rewritten code.

         package Apache::GZip;

         use strict vars;
         use Apache::Constants &apos;:common&apos;;
         use IO::Compress::Gzip;
         use IO::File;

         sub handler {
             my $r = shift;
             my ($fh,$gz);
             my $file = $r-&gt;filename;
             return DECLINED unless $fh=IO::File-&gt;new($file);
             $r-&gt;header_out(&apos;Content-Encoding&apos;=&gt;&apos;gzip&apos;);
             $r-&gt;send_http_header;
             return OK if $r-&gt;header_only;

             my $gz = new IO::Compress::Gzip &apos;-&apos;, Minimal =&gt; 1
                 or return DECLINED ;

             print $gz $_ while &lt;$fh&gt;;

             return OK;
         }

       or even more succinctly, like this, using a one-shot gzip

         package Apache::GZip;

         use strict vars;
         use Apache::Constants &apos;:common&apos;;
         use IO::Compress::Gzip qw(gzip);

         sub handler {
             my $r = shift;
             $r-&gt;header_out(&apos;Content-Encoding&apos;=&gt;&apos;gzip&apos;);
             $r-&gt;send_http_header;
             return OK if $r-&gt;header_only;

             gzip $r-&gt;filename =&gt; &apos;-&apos;, Minimal =&gt; 1
               or return DECLINED ;

             return OK;
         }

         1;

       The use of one-shot &quot;gzip&quot; above just reads from &quot;$r-&gt;filename&quot; and
       writes the compressed data to standard output.

       Note the use of the &quot;Minimal&quot; option in the code above. When using gzip
       for Content-Encoding you should always use this option. In the example
       above it will prevent the filename being included in the gzip header and
       make the size of the gzip data stream a slight bit smaller.

   Compressed files and Net::FTP
       The &quot;Net::FTP&quot; module provides two low-level methods called &quot;stor&quot; and
       &quot;retr&quot; that both return filehandles. These filehandles can used with the
       &quot;IO::Compress/Uncompress&quot; modules to compress or uncompress files read
       from or written to an FTP Server on the fly, without having to create a
       temporary file.

       Firstly, here is code that uses &quot;retr&quot; to uncompressed a file as it is
       read from the FTP Server.

           use Net::FTP;
           use IO::Uncompress::Gunzip qw(:all);

           my $ftp = new Net::FTP ...

           my $retr_fh = $ftp-&gt;retr($compressed_filename);
           gunzip $retr_fh =&gt; $outFilename, AutoClose =&gt; 1
               or die &quot;Cannot uncompress &apos;$compressed_file&apos;: $GunzipError\n&quot;;

       and this to compress a file as it is written to the FTP Server

           use Net::FTP;
           use IO::Compress::Gzip qw(:all);

           my $stor_fh = $ftp-&gt;stor($filename);
           gzip &quot;filename&quot; =&gt; $stor_fh, AutoClose =&gt; 1
               or die &quot;Cannot compress &apos;$filename&apos;: $GzipError\n&quot;;

MISC
   Using &quot;InputLength&quot; to uncompress data embedded in a larger file/buffer.
       A fairly common use-case is where compressed data is embedded in a larger
       file/buffer and you want to read both.

       As an example consider the structure of a zip file. This is a well-
       defined file format that mixes both compressed and uncompressed sections
       of data in a single file.

       For the purposes of this discussion you can think of a zip file as
       sequence of compressed data streams, each of which is prefixed by an
       uncompressed local header. The local header contains information about
       the compressed data stream, including the name of the compressed file
       and, in particular, the length of the compressed data stream.

       To illustrate how to use &quot;InputLength&quot; here is a script that walks a zip
       file and prints out how many lines are in each compressed file (if you
       intend write code to walking through a zip file for real see &quot;Walking
       through a zip file&quot; in IO::Uncompress::Unzip ). Also, although this
       example uses the zlib-based compression, the technique can be used by the
       other &quot;IO::Uncompress::*&quot; modules.

           use strict;
           use warnings;

           use IO::File;
           use IO::Uncompress::RawInflate qw(:all);

           use constant ZIP_LOCAL_HDR_SIG  =&gt; 0x04034b50;
           use constant ZIP_LOCAL_HDR_LENGTH =&gt; 30;

           my $file = $ARGV[0] ;

           my $fh = new IO::File &quot;&lt;$file&quot;
                       or die &quot;Cannot open &apos;$file&apos;: $!\n&quot;;

           while (1)
           {
               my $sig;
               my $buffer;

               my $x ;
               ($x = $fh-&gt;read($buffer, ZIP_LOCAL_HDR_LENGTH)) == ZIP_LOCAL_HDR_LENGTH
                   or die &quot;Truncated file: $!\n&quot;;

               my $signature = unpack (&quot;V&quot;, substr($buffer, 0, 4));

               last unless $signature == ZIP_LOCAL_HDR_SIG;

               # Read Local Header
               my $gpFlag             = unpack (&quot;v&quot;, substr($buffer, 6, 2));
               my $compressedMethod   = unpack (&quot;v&quot;, substr($buffer, 8, 2));
               my $compressedLength   = unpack (&quot;V&quot;, substr($buffer, 18, 4));
               my $uncompressedLength = unpack (&quot;V&quot;, substr($buffer, 22, 4));
               my $filename_length    = unpack (&quot;v&quot;, substr($buffer, 26, 2));
               my $extra_length       = unpack (&quot;v&quot;, substr($buffer, 28, 2));

               my $filename ;
               $fh-&gt;read($filename, $filename_length) == $filename_length
                   or die &quot;Truncated file\n&quot;;

               $fh-&gt;read($buffer, $extra_length) == $extra_length
                   or die &quot;Truncated file\n&quot;;

               if ($compressedMethod != 8 &amp;&amp; $compressedMethod != 0)
               {
                   warn &quot;Skipping file &apos;$filename&apos; - not deflated $compressedMethod\n&quot;;
                   $fh-&gt;read($buffer, $compressedLength) == $compressedLength
                       or die &quot;Truncated file\n&quot;;
                   next;
               }

               if ($compressedMethod == 0 &amp;&amp; $gpFlag &amp; 8 == 8)
               {
                   die &quot;Streamed Stored not supported for &apos;$filename&apos;\n&quot;;
               }

               next if $compressedLength == 0;

               # Done reading the Local Header

               my $inf = new IO::Uncompress::RawInflate $fh,
                                   Transparent =&gt; 1,
                                   InputLength =&gt; $compressedLength
                 or die &quot;Cannot uncompress $file [$filename]: $RawInflateError\n&quot;  ;

               my $line_count = 0;

               while (&lt;$inf&gt;)
               {
                   ++ $line_count;
               }

               print &quot;$filename: $line_count\n&quot;;
           }

       The majority of the code above is concerned with reading the zip local
       header data. The code that I want to focus on is at the bottom.

           while (1) {

               # read local zip header data
               # get $filename
               # get $compressedLength

               my $inf = new IO::Uncompress::RawInflate $fh,
                                   Transparent =&gt; 1,
                                   InputLength =&gt; $compressedLength
                 or die &quot;Cannot uncompress $file [$filename]: $RawInflateError\n&quot;  ;

               my $line_count = 0;

               while (&lt;$inf&gt;)
               {
                   ++ $line_count;
               }

               print &quot;$filename: $line_count\n&quot;;
           }

       The call to &quot;IO::Uncompress::RawInflate&quot; creates a new filehandle $inf
       that can be used to read from the parent filehandle $fh, uncompressing it
       as it goes. The use of the &quot;InputLength&quot; option will guarantee that at
       most $compressedLength bytes of compressed data will be read from the $fh
       filehandle (The only exception is for an error case like a truncated file
       or a corrupt data stream).

       This means that once RawInflate is finished $fh will be left at the byte
       directly after the compressed data stream.

       Now consider what the code looks like without &quot;InputLength&quot;

           while (1) {

               # read local zip header data
               # get $filename
               # get $compressedLength

               # read all the compressed data into $data
               read($fh, $data, $compressedLength);

               my $inf = new IO::Uncompress::RawInflate \$data,
                                   Transparent =&gt; 1,
                 or die &quot;Cannot uncompress $file [$filename]: $RawInflateError\n&quot;  ;

               my $line_count = 0;

               while (&lt;$inf&gt;)
               {
                   ++ $line_count;
               }

               print &quot;$filename: $line_count\n&quot;;
           }

       The difference here is the addition of the temporary variable $data.
       This is used to store a copy of the compressed data while it is being
       uncompressed.

       If you know that $compressedLength isn&apos;t that big then using temporary
       storage won&apos;t be a problem. But if $compressedLength is very large or you
       are writing an application that other people will use, and so have no
       idea how big $compressedLength will be, it could be an issue.

       Using &quot;InputLength&quot; avoids the use of temporary storage and means the
       application can cope with large compressed data streams.

       One final point -- obviously &quot;InputLength&quot; can only be used whenever you
       know the length of the compressed data beforehand, like here with a zip
       file.

SEE ALSO
       Compress::Zlib, IO::Compress::Gzip, IO::Uncompress::Gunzip,
       IO::Compress::Deflate, IO::Uncompress::Inflate, IO::Compress::RawDeflate,
       IO::Uncompress::RawInflate, IO::Compress::Bzip2, IO::Uncompress::Bunzip2,
       IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz,
       IO::Uncompress::UnXz, IO::Compress::Lzop, IO::Uncompress::UnLzop,
       IO::Compress::Lzf, IO::Uncompress::UnLzf, IO::Uncompress::AnyInflate,
       IO::Uncompress::AnyUncompress

       IO::Compress::FAQ

       File::GlobMapper, Archive::Zip, Archive::Tar, IO::Zlib

AUTHOR
       This module was written by Paul Marquess, pmqs@cpan.org.

MODIFICATION HISTORY
       See the Changes file.

COPYRIGHT AND LICENSE
       Copyright (c) 2005-2012 Paul Marquess. All rights reserved.

       This program is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.



perl v5.14.2                       2012-04-29             IO::Compress::FAQ(3pm)

</pre></body></html>
