<html>
<head><meta charset=utf-8/>
<title>JSON - JSON (JavaScript Object Notation) encoder/decoder</title></head>
<body><pre>

JSON(3pm)              User Contributed Perl Documentation             JSON(3pm)



NAME
       JSON - JSON (JavaScript Object Notation) encoder/decoder

SYNOPSIS
        use JSON; # imports encode_json, decode_json, to_json and from_json.

        # simple and fast interfaces (expect/generate UTF-8)

        $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
        $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;

        # OO-interface

        $json = JSON-&gt;new-&gt;allow_nonref;

        $json_text   = $json-&gt;encode( $perl_scalar );
        $perl_scalar = $json-&gt;decode( $json_text );

        $pretty_printed = $json-&gt;pretty-&gt;encode( $perl_scalar ); # pretty-printing

        # If you want to use PP only support features, call with &apos;-support_by_pp&apos;
        # When XS unsupported feature is enable, using PP (de|en)code instead of XS ones.

        use JSON -support_by_pp;

        # option-acceptable interfaces (expect/generate UNICODE by default)

        $json_text   = to_json( $perl_scalar, { ascii =&gt; 1, pretty =&gt; 1 } );
        $perl_scalar = from_json( $json_text, { utf8  =&gt; 1 } );

        # Between (en|de)code_json and (to|from)_json, if you want to write
        # a code which communicates to an outer world (encoded in UTF-8),
        # recommend to use (en|de)code_json.

VERSION
           2.53

       This version is compatible with JSON::XS 2.27 and later.

NOTE
       JSON::PP was inculded in &quot;JSON&quot; distribution.  It comes to be a perl core
       module in Perl 5.14.  And JSON::PP will be split away it.

       &quot;JSON&quot; distribution will inculde yet another JSON::PP modules.  They are
       JSNO::backportPP and so on. JSON.pm should work as it did at all.

DESCRIPTION
        ************************** CAUTION ********************************
        * This is &apos;JSON module version 2&apos; and there are many differences  *
        * to version 1.xx                                                 *
        * Please check your applications useing old version.              *
        *   See to &apos;INCOMPATIBLE CHANGES TO OLD VERSION&apos;                  *
        *******************************************************************

       JSON (JavaScript Object Notation) is a simple data format.  See to
       &lt;http://www.json.org/&gt; and
       &quot;RFC4627&quot;(&lt;http://www.ietf.org/rfc/rfc4627.txt&gt;).

       This module converts Perl data structures to JSON and vice versa using
       either JSON::XS or JSON::PP.

       JSON::XS is the fastest and most proper JSON module on CPAN which must be
       compiled and installed in your environment.  JSON::PP is a pure-Perl
       module which is bundled in this distribution and has a strong
       compatibility to JSON::XS.

       This module try to use JSON::XS by default and fail to it, use JSON::PP
       instead.  So its features completely depend on JSON::XS or JSON::PP.

       See to &quot;BACKEND MODULE DECISION&quot;.

       To distinguish the module name &apos;JSON&apos; and the format type JSON, the
       former is quoted by C&lt;&gt; (its results vary with your using media), and the
       latter is left just as it is.

       Module name : &quot;JSON&quot;

       Format type : JSON

   FEATURES
       &#183;   correct unicode handling

           This module (i.e. backend modules) knows how to handle Unicode,
           documents how and when it does so, and even documents what &quot;correct&quot;
           means.

           Even though there are limitations, this feature is available since
           Perl version 5.6.

           JSON::XS requires Perl 5.8.2 (but works correctly in 5.8.8 or later),
           so in older versions &quot;JSON&quot; sholud call JSON::PP as the backend which
           can be used since Perl 5.005.

           With Perl 5.8.x JSON::PP works, but from 5.8.0 to 5.8.2, because of a
           Perl side problem, JSON::PP works slower in the versions. And in
           5.005, the Unicode handling is not available.  See to &quot;UNICODE
           HANDLING ON PERLS&quot; in JSON::PP for more information.

           See also to &quot;A FEW NOTES ON UNICODE AND PERL&quot; in JSON::XS and
           &quot;ENCODING/CODESET_FLAG_NOTES&quot; in JSON::XS.

       &#183;   round-trip integrity

           When you serialise a perl data structure using only data types
           supported by JSON and Perl, the deserialised data structure is
           identical on the Perl level. (e.g. the string &quot;2.0&quot; doesn&apos;t suddenly
           become &quot;2&quot; just because it looks like a number). There are minor
           exceptions to this, read the &quot;MAPPING&quot; section below to learn about
           those.

       &#183;   strict checking of JSON correctness

           There is no guessing, no generating of illegal JSON texts by default,
           and only JSON is accepted as input by default (the latter is a
           security feature).

           See to &quot;FEATURES&quot; in JSON::XS and &quot;FEATURES&quot; in JSON::PP.

       &#183;   fast

           This module returns a JSON::XS object itself if available.  Compared
           to other JSON modules and other serialisers such as Storable,
           JSON::XS usually compares favourably in terms of speed, too.

           If not available, &quot;JSON&quot; returns a JSON::PP object instead of
           JSON::XS and it is very slow as pure-Perl.

       &#183;   simple to use
&#12;           This module has both a simple functional interface as well as an
           object oriented interface interface.

       &#183;   reasonably versatile output formats

           You can choose between the most compact guaranteed-single-line format
           possible (nice for simple line-based protocols), a pure-ASCII format
           (for when your transport is not 8-bit clean, still supports the whole
           Unicode range), or a pretty-printed format (for when you want to read
           that stuff). Or you can combine those features in whatever way you
           like.

FUNCTIONAL INTERFACE
       Some documents are copied and modified from &quot;FUNCTIONAL INTERFACE&quot; in
       JSON::XS.  &quot;to_json&quot; and &quot;from_json&quot; are additional functions.

   encode_json
           $json_text = encode_json $perl_scalar

       Converts the given Perl data structure to a UTF-8 encoded, binary string.

       This function call is functionally identical to:

           $json_text = JSON-&gt;new-&gt;utf8-&gt;encode($perl_scalar)

   decode_json
           $perl_scalar = decode_json $json_text

       The opposite of &quot;encode_json&quot;: expects an UTF-8 (binary) string and tries
       to parse that as an UTF-8 encoded JSON text, returning the resulting
       reference.

       This function call is functionally identical to:

           $perl_scalar = JSON-&gt;new-&gt;utf8-&gt;decode($json_text)

   to_json
          $json_text = to_json($perl_scalar)

       Converts the given Perl data structure to a json string.

       This function call is functionally identical to:

          $json_text = JSON-&gt;new-&gt;encode($perl_scalar)

       Takes a hash reference as the second.

          $json_text = to_json($perl_scalar, $flag_hashref)

       So,

          $json_text = to_json($perl_scalar, {utf8 =&gt; 1, pretty =&gt; 1})

       equivalent to:

          $json_text = JSON-&gt;new-&gt;utf8(1)-&gt;pretty(1)-&gt;encode($perl_scalar)

       If you want to write a modern perl code which communicates to outer
       world, you should use &quot;encode_json&quot; (supposed that JSON data are encoded
       in UTF-8).

   from_json
          $perl_scalar = from_json($json_text)

       The opposite of &quot;to_json&quot;: expects a json string and tries to parse it,
       returning the resulting reference.
&#12;       This function call is functionally identical to:

           $perl_scalar = JSON-&gt;decode($json_text)

       Takes a hash reference as the second.

           $perl_scalar = from_json($json_text, $flag_hashref)

       So,

           $perl_scalar = from_json($json_text, {utf8 =&gt; 1})

       equivalent to:

           $perl_scalar = JSON-&gt;new-&gt;utf8(1)-&gt;decode($json_text)

       If you want to write a modern perl code which communicates to outer
       world, you should use &quot;decode_json&quot; (supposed that JSON data are encoded
       in UTF-8).

   JSON::is_bool
           $is_boolean = JSON::is_bool($scalar)

       Returns true if the passed scalar represents either JSON::true or
       JSON::false, two constants that act like 1 and 0 respectively and are
       also used to represent JSON &quot;true&quot; and &quot;false&quot; in Perl strings.

   JSON::true
       Returns JSON true value which is blessed object.  It &quot;isa&quot; JSON::Boolean
       object.

   JSON::false
       Returns JSON false value which is blessed object.  It &quot;isa&quot; JSON::Boolean
       object.

   JSON::null
       Returns &quot;undef&quot;.

       See MAPPING, below, for more information on how JSON values are mapped to
       Perl.

HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER
       This section supposes that your perl vresion is 5.8 or later.

       If you know a JSON text from an outer world - a network, a file content,
       and so on, is encoded in UTF-8, you should use &quot;decode_json&quot; or &quot;JSON&quot;
       module object with &quot;utf8&quot; enable. And the decoded result will contain
       UNICODE characters.

         # from network
         my $json        = JSON-&gt;new-&gt;utf8;
         my $json_text   = CGI-&gt;new-&gt;param( &apos;json_data&apos; );
         my $perl_scalar = $json-&gt;decode( $json_text );

         # from file content
         local $/;
         open( my $fh, &apos;&lt;&apos;, &apos;json.data&apos; );
         $json_text   = &lt;$fh&gt;;
         $perl_scalar = decode_json( $json_text );

       If an outer data is not encoded in UTF-8, firstly you should &quot;decode&quot; it.

         use Encode;
         local $/;
         open( my $fh, &apos;&lt;&apos;, &apos;json.data&apos; );
         my $encoding = &apos;cp932&apos;;
         my $unicode_json_text = decode( $encoding, &lt;$fh&gt; ); # UNICODE
&#12;         # or you can write the below code.
         #
         # open( my $fh, &quot;&lt;:encoding($encoding)&quot;, &apos;json.data&apos; );
         # $unicode_json_text = &lt;$fh&gt;;

       In this case, $unicode_json_text is of course UNICODE string.  So you
       cannot use &quot;decode_json&quot; nor &quot;JSON&quot; module object with &quot;utf8&quot; enable.
       Instead of them, you use &quot;JSON&quot; module object with &quot;utf8&quot; disable or
       &quot;from_json&quot;.

         $perl_scalar = $json-&gt;utf8(0)-&gt;decode( $unicode_json_text );
         # or
         $perl_scalar = from_json( $unicode_json_text );

       Or &quot;encode &apos;utf8&apos;&quot; and &quot;decode_json&quot;:

         $perl_scalar = decode_json( encode( &apos;utf8&apos;, $unicode_json_text ) );
         # this way is not efficient.

       And now, you want to convert your $perl_scalar into JSON data and send it
       to an outer world - a network or a file content, and so on.

       Your data usually contains UNICODE strings and you want the converted
       data to be encoded in UTF-8, you should use &quot;encode_json&quot; or &quot;JSON&quot;
       module object with &quot;utf8&quot; enable.

         print encode_json( $perl_scalar ); # to a network? file? or display?
         # or
         print $json-&gt;utf8-&gt;encode( $perl_scalar );

       If $perl_scalar does not contain UNICODE but $encoding-encoded strings
       for some reason, then its characters are regarded as latin1 for perl
       (because it does not concern with your $encoding).  You cannot use
       &quot;encode_json&quot; nor &quot;JSON&quot; module object with &quot;utf8&quot; enable.  Instead of
       them, you use &quot;JSON&quot; module object with &quot;utf8&quot; disable or &quot;to_json&quot;.
       Note that the resulted text is a UNICODE string but no problem to print
       it.

         # $perl_scalar contains $encoding encoded string values
         $unicode_json_text = $json-&gt;utf8(0)-&gt;encode( $perl_scalar );
         # or
         $unicode_json_text = to_json( $perl_scalar );
         # $unicode_json_text consists of characters less than 0x100
         print $unicode_json_text;

       Or &quot;decode $encoding&quot; all string values and &quot;encode_json&quot;:

         $perl_scalar-&gt;{ foo } = decode( $encoding, $perl_scalar-&gt;{ foo } );
         # ... do it to each string values, then encode_json
         $json_text = encode_json( $perl_scalar );

       This method is a proper way but probably not efficient.

       See to Encode, perluniintro.

COMMON OBJECT-ORIENTED INTERFACE
   new
           $json = new JSON

       Returns a new &quot;JSON&quot; object inherited from either JSON::XS or JSON::PP
       that can be used to de/encode JSON strings.

       All boolean flags described below are by default disabled.

       The mutators for flags all return the JSON object again and thus calls
       can be chained:

          my $json = JSON-&gt;new-&gt;utf8-&gt;space_after-&gt;encode({a =&gt; [1,2]})
          =&gt; {&quot;a&quot;: [1, 2]}
&#12;   ascii
           $json = $json-&gt;ascii([$enable])

           $enabled = $json-&gt;get_ascii

       If $enable is true (or missing), then the encode method will not generate
       characters outside the code range 0..127. Any Unicode characters outside
       that range will be escaped using either a single \uXXXX or a double
       \uHHHH\uLLLLL escape sequence, as per RFC4627.

       If $enable is false, then the encode method will not escape Unicode
       characters unless required by the JSON syntax or other flags. This
       results in a faster and more compact format.

       This feature depends on the used Perl version and environment.

       See to &quot;UNICODE HANDLING ON PERLS&quot; in JSON::PP if the backend is PP.

         JSON-&gt;new-&gt;ascii(1)-&gt;encode([chr 0x10401])
         =&gt; [&quot;\ud801\udc01&quot;]

   latin1
           $json = $json-&gt;latin1([$enable])

           $enabled = $json-&gt;get_latin1

       If $enable is true (or missing), then the encode method will encode the
       resulting JSON text as latin1 (or iso-8859-1), escaping any characters
       outside the code range 0..255.

       If $enable is false, then the encode method will not escape Unicode
       characters unless required by the JSON syntax or other flags.

         JSON-&gt;new-&gt;latin1-&gt;encode ([&quot;\x{89}\x{abc}&quot;]
         =&gt; [&quot;\x{89}\\u0abc&quot;]    # (perl syntax, U+abc escaped, U+89 not)

   utf8
           $json = $json-&gt;utf8([$enable])

           $enabled = $json-&gt;get_utf8

       If $enable is true (or missing), then the encode method will encode the
       JSON result into UTF-8, as required by many protocols, while the decode
       method expects to be handled an UTF-8-encoded string. Please note that
       UTF-8-encoded strings do not contain any characters outside the range
       0..255, they are thus useful for bytewise/binary I/O.

       In future versions, enabling this option might enable autodetection of
       the UTF-16 and UTF-32 encoding families, as described in RFC4627.

       If $enable is false, then the encode method will return the JSON string
       as a (non-encoded) Unicode string, while decode expects thus a Unicode
       string. Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs to be
       done yourself, e.g. using the Encode module.

       Example, output UTF-16BE-encoded JSON:

         use Encode;
         $jsontext = encode &quot;UTF-16BE&quot;, JSON::XS-&gt;new-&gt;encode ($object);

       Example, decode UTF-32LE-encoded JSON:

         use Encode;
         $object = JSON::XS-&gt;new-&gt;decode (decode &quot;UTF-32LE&quot;, $jsontext);

       See to &quot;UNICODE HANDLING ON PERLS&quot; in JSON::PP if the backend is PP.

   pretty
           $json = $json-&gt;pretty([$enable])
&#12;       This enables (or disables) all of the &quot;indent&quot;, &quot;space_before&quot; and
       &quot;space_after&quot; (and in the future possibly more) flags in one call to
       generate the most readable (or most compact) form possible.

       Equivalent to:

          $json-&gt;indent-&gt;space_before-&gt;space_after

       The indent space length is three and JSON::XS cannot change the indent
       space length.

   indent
           $json = $json-&gt;indent([$enable])

           $enabled = $json-&gt;get_indent

       If $enable is true (or missing), then the &quot;encode&quot; method will use a
       multiline format as output, putting every array member or object/hash
       key-value pair into its own line, identing them properly.

       If $enable is false, no newlines or indenting will be produced, and the
       resulting JSON text is guarenteed not to contain any &quot;newlines&quot;.

       This setting has no effect when decoding JSON texts.

       The indent space length is three.  With JSON::PP, you can also access
       &quot;indent_length&quot; to change indent space length.

   space_before
           $json = $json-&gt;space_before([$enable])

           $enabled = $json-&gt;get_space_before

       If $enable is true (or missing), then the &quot;encode&quot; method will add an
       extra optional space before the &quot;:&quot; separating keys from values in JSON
       objects.

       If $enable is false, then the &quot;encode&quot; method will not add any extra
       space at those places.

       This setting has no effect when decoding JSON texts.

       Example, space_before enabled, space_after and indent disabled:

          {&quot;key&quot; :&quot;value&quot;}

   space_after
           $json = $json-&gt;space_after([$enable])

           $enabled = $json-&gt;get_space_after

       If $enable is true (or missing), then the &quot;encode&quot; method will add an
       extra optional space after the &quot;:&quot; separating keys from values in JSON
       objects and extra whitespace after the &quot;,&quot; separating key-value pairs and
       array members.

       If $enable is false, then the &quot;encode&quot; method will not add any extra
       space at those places.

       This setting has no effect when decoding JSON texts.

       Example, space_before and indent disabled, space_after enabled:

          {&quot;key&quot;: &quot;value&quot;}

   relaxed
           $json = $json-&gt;relaxed([$enable])

           $enabled = $json-&gt;get_relaxed
&#12;       If $enable is true (or missing), then &quot;decode&quot; will accept some
       extensions to normal JSON syntax (see below). &quot;encode&quot; will not be
       affected in anyway. Be aware that this option makes you accept invalid
       JSON texts as if they were valid!. I suggest only to use this option to
       parse application-specific files written by humans (configuration files,
       resource files etc.)

       If $enable is false (the default), then &quot;decode&quot; will only accept valid
       JSON texts.

       Currently accepted extensions are:

       &#183;   list items can have an end-comma

           JSON separates array elements and key-value pairs with commas. This
           can be annoying if you write JSON texts manually and want to be able
           to quickly append elements, so this extension accepts comma at the
           end of such items not just between them:

              [
                 1,
                 2, &lt;- this comma not normally allowed
              ]
              {
                 &quot;k1&quot;: &quot;v1&quot;,
                 &quot;k2&quot;: &quot;v2&quot;, &lt;- this comma not normally allowed
              }

       &#183;   shell-style &apos;#&apos;-comments

           Whenever JSON allows whitespace, shell-style comments are
           additionally allowed. They are terminated by the first carriage-
           return or line-feed character, after which more white-space and
           comments are allowed.

             [
                1, # this comment not allowed in JSON
                   # neither this one...
             ]

   canonical
           $json = $json-&gt;canonical([$enable])

           $enabled = $json-&gt;get_canonical

       If $enable is true (or missing), then the &quot;encode&quot; method will output
       JSON objects by sorting their keys. This is adding a comparatively high
       overhead.

       If $enable is false, then the &quot;encode&quot; method will output key-value pairs
       in the order Perl stores them (which will likely change between runs of
       the same script).

       This option is useful if you want the same data structure to be encoded
       as the same JSON text (given the same overall settings). If it is
       disabled, the same hash might be encoded differently even if contains the
       same data, as key-value pairs have no inherent ordering in Perl.

       This setting has no effect when decoding JSON texts.

   allow_nonref
           $json = $json-&gt;allow_nonref([$enable])

           $enabled = $json-&gt;get_allow_nonref

       If $enable is true (or missing), then the &quot;encode&quot; method can convert a
       non-reference into its corresponding string, number or null JSON value,
       which is an extension to RFC4627. Likewise, &quot;decode&quot; will accept those
       JSON values instead of croaking.
&#12;       If $enable is false, then the &quot;encode&quot; method will croak if it isn&apos;t
       passed an arrayref or hashref, as JSON texts must either be an object or
       array. Likewise, &quot;decode&quot; will croak if given something that is not a
       JSON object or array.

          JSON-&gt;new-&gt;allow_nonref-&gt;encode (&quot;Hello, World!&quot;)
          =&gt; &quot;Hello, World!&quot;

   allow_unknown
           $json = $json-&gt;allow_unknown ([$enable])

           $enabled = $json-&gt;get_allow_unknown

       If $enable is true (or missing), then &quot;encode&quot; will *not* throw an
       exception when it encounters values it cannot represent in JSON (for
       example, filehandles) but instead will encode a JSON &quot;null&quot; value.  Note
       that blessed objects are not included here and are handled separately by
       c&lt;allow_nonref&gt;.

       If $enable is false (the default), then &quot;encode&quot; will throw an exception
       when it encounters anything it cannot encode as JSON.

       This option does not affect &quot;decode&quot; in any way, and it is recommended to
       leave it off unless you know your communications partner.

   allow_blessed
           $json = $json-&gt;allow_blessed([$enable])

           $enabled = $json-&gt;get_allow_blessed

       If $enable is true (or missing), then the &quot;encode&quot; method will not barf
       when it encounters a blessed reference. Instead, the value of the
       convert_blessed option will decide whether &quot;null&quot; (&quot;convert_blessed&quot;
       disabled or no &quot;TO_JSON&quot; method found) or a representation of the object
       (&quot;convert_blessed&quot; enabled and &quot;TO_JSON&quot; method found) is being encoded.
       Has no effect on &quot;decode&quot;.

       If $enable is false (the default), then &quot;encode&quot; will throw an exception
       when it encounters a blessed object.

   convert_blessed
           $json = $json-&gt;convert_blessed([$enable])

           $enabled = $json-&gt;get_convert_blessed

       If $enable is true (or missing), then &quot;encode&quot;, upon encountering a
       blessed object, will check for the availability of the &quot;TO_JSON&quot; method
       on the object&apos;s class. If found, it will be called in scalar context and
       the resulting scalar will be encoded instead of the object. If no
       &quot;TO_JSON&quot; method is found, the value of &quot;allow_blessed&quot; will decide what
       to do.

       The &quot;TO_JSON&quot; method may safely call die if it wants. If &quot;TO_JSON&quot;
       returns other blessed objects, those will be handled in the same way.
       &quot;TO_JSON&quot; must take care of not causing an endless recursion cycle (==
       crash) in this case. The name of &quot;TO_JSON&quot; was chosen because other
       methods called by the Perl core (== not by the user of the object) are
       usually in upper case letters and to avoid collisions with the &quot;to_json&quot;
       function or method.

       This setting does not yet influence &quot;decode&quot; in any way.

       If $enable is false, then the &quot;allow_blessed&quot; setting will decide what to
       do when a blessed object is found.

       convert_blessed_universally mode
           If use &quot;JSON&quot; with &quot;-convert_blessed_universally&quot;, the
           &quot;UNIVERSAL::TO_JSON&quot; subroutine is defined as the below code:

              *UNIVERSAL::TO_JSON = sub {
                  my $b_obj = B::svref_2object( $_[0] );
                  return    $b_obj-&gt;isa(&apos;B::HV&apos;) ? { %{ $_[0] } }
                          : $b_obj-&gt;isa(&apos;B::AV&apos;) ? [ @{ $_[0] } ]
                          : undef
                          ;
              }
&#12;           This will cause that &quot;encode&quot; method converts simple blessed objects
           into JSON objects as non-blessed object.

              JSON -convert_blessed_universally;
              $json-&gt;allow_blessed-&gt;convert_blessed-&gt;encode( $blessed_object )

           This feature is experimental and may be removed in the future.

   filter_json_object
           $json = $json-&gt;filter_json_object([$coderef])

       When $coderef is specified, it will be called from &quot;decode&quot; each time it
       decodes a JSON object. The only argument passed to the coderef is a
       reference to the newly-created hash. If the code references returns a
       single scalar (which need not be a reference), this value (i.e. a copy of
       that scalar to avoid aliasing) is inserted into the deserialised data
       structure. If it returns an empty list (NOTE: not &quot;undef&quot;, which is a
       valid scalar), the original deserialised hash will be inserted. This
       setting can slow down decoding considerably.

       When $coderef is omitted or undefined, any existing callback will be
       removed and &quot;decode&quot; will not change the deserialised hash in any way.

       Example, convert all JSON objects into the integer 5:

          my $js = JSON-&gt;new-&gt;filter_json_object (sub { 5 });
          # returns [5]
          $js-&gt;decode (&apos;[{}]&apos;); # the given subroutine takes a hash reference.
          # throw an exception because allow_nonref is not enabled
          # so a lone 5 is not allowed.
          $js-&gt;decode (&apos;{&quot;a&quot;:1, &quot;b&quot;:2}&apos;);

   filter_json_single_key_object
           $json = $json-&gt;filter_json_single_key_object($key [=&gt; $coderef])

       Works remotely similar to &quot;filter_json_object&quot;, but is only called for
       JSON objects having a single key named $key.

       This $coderef is called before the one specified via
       &quot;filter_json_object&quot;, if any. It gets passed the single value in the JSON
       object. If it returns a single value, it will be inserted into the data
       structure. If it returns nothing (not even &quot;undef&quot; but the empty list),
       the callback from &quot;filter_json_object&quot; will be called next, as if no
       single-key callback were specified.

       If $coderef is omitted or undefined, the corresponding callback will be
       disabled. There can only ever be one callback for a given key.

       As this callback gets called less often then the &quot;filter_json_object&quot;
       one, decoding speed will not usually suffer as much. Therefore, single-
       key objects make excellent targets to serialise Perl objects into,
       especially as single-key JSON objects are as close to the type-tagged
       value concept as JSON gets (it&apos;s basically an ID/VALUE tuple). Of course,
       JSON does not support this in any way, so you need to make sure your data
       never looks like a serialised Perl hash.

       Typical names for the single object key are &quot;__class_whatever__&quot;, or
       &quot;$__dollars_are_rarely_used__$&quot; or &quot;}ugly_brace_placement&quot;, or even
       things like &quot;__class_md5sum(classname)__&quot;, to reduce the risk of clashing
       with real hashes.

       Example, decode JSON objects of the form &quot;{ &quot;__widget__&quot; =&gt; &lt;id&gt; }&quot; into
       the corresponding $WIDGET{&lt;id&gt;} object:

          # return whatever is in $WIDGET{5}:
          JSON
             -&gt;new
             -&gt;filter_json_single_key_object (__widget__ =&gt; sub {
                   $WIDGET{ $_[0] }
                })
             -&gt;decode (&apos;{&quot;__widget__&quot;: 5&apos;)

          # this can be used with a TO_JSON method in some &quot;widget&quot; class
          # for serialisation to json:
          sub WidgetBase::TO_JSON {
             my ($self) = @_;
&#12;             unless ($self-&gt;{id}) {
                $self-&gt;{id} = ..get..some..id..;
                $WIDGET{$self-&gt;{id}} = $self;
             }

             { __widget__ =&gt; $self-&gt;{id} }
          }

   shrink
           $json = $json-&gt;shrink([$enable])

           $enabled = $json-&gt;get_shrink

       With JSON::XS, this flag resizes strings generated by either &quot;encode&quot; or
       &quot;decode&quot; to their minimum size possible. This can save memory when your
       JSON texts are either very very long or you have many short strings. It
       will also try to downgrade any strings to octet-form if possible: perl
       stores strings internally either in an encoding called UTF-X or in octet-
       form. The latter cannot store everything but uses less space in general
       (and some buggy Perl or C code might even rely on that internal
       representation being used).

       With JSON::PP, it is noop about resizing strings but tries
       &quot;utf8::downgrade&quot; to the returned string by &quot;encode&quot;. See to utf8.

       See to &quot;OBJECT-ORIENTED INTERFACE&quot; in JSON::XS and &quot;METHODS&quot; in JSON::PP.

   max_depth
           $json = $json-&gt;max_depth([$maximum_nesting_depth])

           $max_depth = $json-&gt;get_max_depth

       Sets the maximum nesting level (default 512) accepted while encoding or
       decoding. If a higher nesting level is detected in JSON text or a Perl
       data structure, then the encoder and decoder will stop and croak at that
       point.

       Nesting level is defined by number of hash- or arrayrefs that the encoder
       needs to traverse to reach a given point or the number of &quot;{&quot; or &quot;[&quot;
       characters without their matching closing parenthesis crossed to reach a
       given character in a string.

       If no argument is given, the highest possible setting will be used, which
       is rarely useful.

       Note that nesting is implemented by recursion in C. The default value has
       been chosen to be as large as typical operating systems allow without
       crashing. (JSON::XS)

       With JSON::PP as the backend, when a large value (100 or more) was set
       and it de/encodes a deep nested object/text, it may raise a warning &apos;Deep
       recursion on subroutin&apos; at the perl runtime phase.

       See &quot;SECURITY CONSIDERATIONS&quot; in JSON::XS for more info on why this is
       useful.

   max_size
           $json = $json-&gt;max_size([$maximum_string_size])

           $max_size = $json-&gt;get_max_size

       Set the maximum length a JSON text may have (in bytes) where decoding is
       being attempted. The default is 0, meaning no limit. When &quot;decode&quot; is
       called on a string that is longer then this many bytes, it will not
       attempt to decode the string but throw an exception. This setting has no
       effect on &quot;encode&quot; (yet).

       If no argument is given, the limit check will be deactivated (same as
       when 0 is specified).

       See &quot;SECURITY CONSIDERATIONS&quot; in JSON::XS, below, for more info on why
       this is useful.

   encode
           $json_text = $json-&gt;encode($perl_scalar)

       Converts the given Perl data structure (a simple scalar or a reference to
       a hash or array) to its JSON representation. Simple scalars will be
       converted into JSON string or number sequences, while references to
       arrays become JSON arrays and references to hashes become JSON objects.
       Undefined Perl values (e.g. &quot;undef&quot;) become JSON &quot;null&quot; values.
       References to the integers 0 and 1 are converted into &quot;true&quot; and &quot;false&quot;.

   decode
           $perl_scalar = $json-&gt;decode($json_text)

       The opposite of &quot;encode&quot;: expects a JSON text and tries to parse it,
       returning the resulting simple scalar or reference. Croaks on error.

       JSON numbers and strings become simple Perl scalars. JSON arrays become
       Perl arrayrefs and JSON objects become Perl hashrefs. &quot;true&quot; becomes 1
       (&quot;JSON::true&quot;), &quot;false&quot; becomes 0 (&quot;JSON::false&quot;) and &quot;null&quot; becomes
       &quot;undef&quot;.

   decode_prefix
           ($perl_scalar, $characters) = $json-&gt;decode_prefix($json_text)

       This works like the &quot;decode&quot; method, but instead of raising an exception
       when there is trailing garbage after the first JSON object, it will
       silently stop parsing there and return the number of characters consumed
       so far.

          JSON-&gt;new-&gt;decode_prefix (&quot;[1] the tail&quot;)
          =&gt; ([], 3)

       See to &quot;OBJECT-ORIENTED INTERFACE&quot; in JSON::XS

   property
           $boolean = $json-&gt;property($property_name)

       Returns a boolean value about above some properties.

       The available properties are &quot;ascii&quot;, &quot;latin1&quot;, &quot;utf8&quot;,
       &quot;indent&quot;,&quot;space_before&quot;, &quot;space_after&quot;, &quot;relaxed&quot;, &quot;canonical&quot;,
       &quot;allow_nonref&quot;, &quot;allow_unknown&quot;, &quot;allow_blessed&quot;, &quot;convert_blessed&quot;,
       &quot;shrink&quot;, &quot;max_depth&quot; and &quot;max_size&quot;.

          $boolean = $json-&gt;property(&apos;utf8&apos;);
           =&gt; 0
          $json-&gt;utf8;
          $boolean = $json-&gt;property(&apos;utf8&apos;);
           =&gt; 1

       Sets the property with a given boolean value.

           $json = $json-&gt;property($property_name =&gt; $boolean);

       With no argumnt, it returns all the above properties as a hash reference.

           $flag_hashref = $json-&gt;property();

INCREMENTAL PARSING
       Most of this section are copied and modified from &quot;INCREMENTAL PARSING&quot;
       in JSON::XS.

       In some cases, there is the need for incremental parsing of JSON texts.
       This module does allow you to parse a JSON stream incrementally.  It does
       so by accumulating text until it has a full JSON object, which it then
       can decode. This process is similar to using &quot;decode_prefix&quot; to see if a
       full JSON object is available, but is much more efficient (and can be
       implemented with a minimum of method calls).

       The backend module will only attempt to parse the JSON text once it is
       sure it has enough text to get a decisive result, using a very simple but
       truly incremental parser. This means that it sometimes won&apos;t stop as
       early as the full parser, for example, it doesn&apos;t detect parenthese
       mismatches. The only thing it guarantees is that it starts decoding as
       soon as a syntactically valid JSON text has been seen. This means you
       need to set resource limits (e.g. &quot;max_size&quot;) to ensure the parser will
       stop parsing in the presence if syntax errors.

       The following methods implement this incremental parser.

   incr_parse
           $json-&gt;incr_parse( [$string] ) # void context
&#12;           $obj_or_undef = $json-&gt;incr_parse( [$string] ) # scalar context

           @obj_or_empty = $json-&gt;incr_parse( [$string] ) # list context

       This is the central parsing function. It can both append new text and
       extract objects from the stream accumulated so far (both of these
       functions are optional).

       If $string is given, then this string is appended to the already existing
       JSON fragment stored in the $json object.

       After that, if the function is called in void context, it will simply
       return without doing anything further. This can be used to add more text
       in as many chunks as you want.

       If the method is called in scalar context, then it will try to extract
       exactly one JSON object. If that is successful, it will return this
       object, otherwise it will return &quot;undef&quot;. If there is a parse error, this
       method will croak just as &quot;decode&quot; would do (one can then use &quot;incr_skip&quot;
       to skip the errornous part). This is the most common way of using the
       method.

       And finally, in list context, it will try to extract as many objects from
       the stream as it can find and return them, or the empty list otherwise.
       For this to work, there must be no separators between the JSON objects or
       arrays, instead they must be concatenated back-to-back. If an error
       occurs, an exception will be raised as in the scalar context case. Note
       that in this case, any previously-parsed JSON texts will be lost.

       Example: Parse some JSON arrays/objects in a given string and return
       them.

           my @objs = JSON-&gt;new-&gt;incr_parse (&quot;[5][7][1,2]&quot;);

   incr_text
           $lvalue_string = $json-&gt;incr_text

       This method returns the currently stored JSON fragment as an lvalue, that
       is, you can manipulate it. This only works when a preceding call to
       &quot;incr_parse&quot; in scalar context successfully returned an object. Under all
       other circumstances you must not call this function (I mean it.  although
       in simple tests it might actually work, it will fail under real world
       conditions). As a special exception, you can also call this method before
       having parsed anything.

       This function is useful in two cases: a) finding the trailing text after
       a JSON object or b) parsing multiple JSON objects separated by non-JSON
       text (such as commas).

           $json-&gt;incr_text =~ s/\s*,\s*//;

       In Perl 5.005, &quot;lvalue&quot; attribute is not available.  You must write codes
       like the below:

           $string = $json-&gt;incr_text;
           $string =~ s/\s*,\s*//;
           $json-&gt;incr_text( $string );

   incr_skip
           $json-&gt;incr_skip

       This will reset the state of the incremental parser and will remove the
       parsed text from the input buffer. This is useful after &quot;incr_parse&quot;
       died, in which case the input buffer and incremental parser state is left
       unchanged, to skip the text parsed so far and to reset the parse state.

   incr_reset
           $json-&gt;incr_reset

       This completely resets the incremental parser, that is, after this call,
       it will be as if the parser had never parsed anything.

       This is useful if you want ot repeatedly parse JSON objects and want to
       ignore any trailing data, which means you have to reset the parser after
       each successful decode.

       See to &quot;INCREMENTAL PARSING&quot; in JSON::XS for examples.

JSON::PP SUPPORT METHODS
       The below methods are JSON::PP own methods, so when &quot;JSON&quot; works with
       JSON::PP (i.e. the created object is a JSON::PP object), available.  See
       to &quot;JSON::PP OWN METHODS&quot; in JSON::PP in detail.

       If you use &quot;JSON&quot; with additonal &quot;-support_by_pp&quot;, some methods are
       available even with JSON::XS. See to &quot;USE PP FEATURES EVEN THOUGH XS
       BACKEND&quot;.

          BEING { $ENV{PERL_JSON_BACKEND} = &apos;JSON::XS&apos; }

          use JSON -support_by_pp;

          my $json = new JSON;
          $json-&gt;allow_nonref-&gt;escape_slash-&gt;encode(&quot;/&quot;);

          # functional interfaces too.
          print to_json([&quot;/&quot;], {escape_slash =&gt; 1});
          print from_json(&apos;[&quot;foo&quot;]&apos;, {utf8 =&gt; 1});

       If you do not want to all functions but &quot;-support_by_pp&quot;, use
       &quot;-no_export&quot;.

          use JSON -support_by_pp, -no_export;
          # functional interfaces are not exported.

   allow_singlequote
           $json = $json-&gt;allow_singlequote([$enable])

       If $enable is true (or missing), then &quot;decode&quot; will accept any JSON
       strings quoted by single quotations that are invalid JSON format.

           $json-&gt;allow_singlequote-&gt;decode({&quot;foo&quot;:&apos;bar&apos;});
           $json-&gt;allow_singlequote-&gt;decode({&apos;foo&apos;:&quot;bar&quot;});
           $json-&gt;allow_singlequote-&gt;decode({&apos;foo&apos;:&apos;bar&apos;});

       As same as the &quot;relaxed&quot; option, this option may be used to parse
       application-specific files written by humans.

   allow_barekey
           $json = $json-&gt;allow_barekey([$enable])

       If $enable is true (or missing), then &quot;decode&quot; will accept bare keys of
       JSON object that are invalid JSON format.

       As same as the &quot;relaxed&quot; option, this option may be used to parse
       application-specific files written by humans.

           $json-&gt;allow_barekey-&gt;decode(&apos;{foo:&quot;bar&quot;}&apos;);

   allow_bignum
           $json = $json-&gt;allow_bignum([$enable])

       If $enable is true (or missing), then &quot;decode&quot; will convert the big
       integer Perl cannot handle as integer into a Math::BigInt object and
       convert a floating number (any) into a Math::BigFloat.

       On the contary, &quot;encode&quot; converts &quot;Math::BigInt&quot; objects and
       &quot;Math::BigFloat&quot; objects into JSON numbers with &quot;allow_blessed&quot; enable.

          $json-&gt;allow_nonref-&gt;allow_blessed-&gt;allow_bignum;
          $bigfloat = $json-&gt;decode(&apos;2.000000000000000000000000001&apos;);
          print $json-&gt;encode($bigfloat);
          # =&gt; 2.000000000000000000000000001

       See to MAPPING aboout the conversion of JSON number.

   loose
           $json = $json-&gt;loose([$enable])

       The unescaped [\x00-\x1f\x22\x2f\x5c] strings are invalid in JSON strings
       and the module doesn&apos;t allow to &quot;decode&quot; to these (except for \x2f).  If
       $enable is true (or missing), then &quot;decode&quot;  will accept these unescaped
       strings.

           $json-&gt;loose-&gt;decode(qq|[&quot;abc
                                          def&quot;]|);

       See to &quot;JSON::PP OWN METHODS&quot; in JSON::PP.

   escape_slash
           $json = $json-&gt;escape_slash([$enable])

       According to JSON Grammar, slash (U+002F) is escaped. But by default JSON
       backend modules encode strings without escaping slash.

       If $enable is true (or missing), then &quot;encode&quot; will escape slashes.

   indent_length
           $json = $json-&gt;indent_length($length)

       With JSON::XS, The indent space length is 3 and cannot be changed.  With
       JSON::PP, it sets the indent space length with the given $length.  The
       default is 3. The acceptable range is 0 to 15.

   sort_by
           $json = $json-&gt;sort_by($function_name)
           $json = $json-&gt;sort_by($subroutine_ref)

       If $function_name or $subroutine_ref are set, its sort routine are used.

          $js = $pc-&gt;sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })-&gt;encode($obj);
          # is($js, q|{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5,&quot;f&quot;:6,&quot;g&quot;:7,&quot;h&quot;:8,&quot;i&quot;:9}|);

          $js = $pc-&gt;sort_by(&apos;own_sort&apos;)-&gt;encode($obj);
          # is($js, q|{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5,&quot;f&quot;:6,&quot;g&quot;:7,&quot;h&quot;:8,&quot;i&quot;:9}|);

          sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }

       As the sorting routine runs in the JSON::PP scope, the given subroutine
       name and the special variables $a, $b will begin with &apos;JSON::PP::&apos;.

       If $integer is set, then the effect is same as &quot;canonical&quot; on.

       See to &quot;JSON::PP OWN METHODS&quot; in JSON::PP.

MAPPING
       This section is copied from JSON::XS and modified to &quot;JSON&quot;.  JSON::XS
       and JSON::PP mapping mechanisms are almost equivalent.

       See to &quot;MAPPING&quot; in JSON::XS.

   JSON -&gt; PERL
       object
           A JSON object becomes a reference to a hash in Perl. No ordering of
           object keys is preserved (JSON does not preserver object key ordering
           itself).

       array
           A JSON array becomes a reference to an array in Perl.

       string
           A JSON string becomes a string scalar in Perl - Unicode codepoints in
           JSON are represented by the same codepoints in the Perl string, so no
           manual decoding is necessary.

       number
           A JSON number becomes either an integer, numeric (floating point) or
           string scalar in perl, depending on its range and any fractional
           parts. On the Perl level, there is no difference between those as
           Perl handles all the conversion details, but an integer may take
           slightly less memory and might represent more values exactly than
           floating point numbers.

           If the number consists of digits only, &quot;JSON&quot; will try to represent
           it as an integer value. If that fails, it will try to represent it as
           a numeric (floating point) value if that is possible without loss of
           precision. Otherwise it will preserve the number as a string value
           (in which case you lose roundtripping ability, as the JSON number
           will be re-encoded toa JSON string).

           Numbers containing a fractional or exponential part will always be
           represented as numeric (floating point) values, possibly at a loss of
           precision (in which case you might lose perfect roundtripping
           ability, but the JSON number will still be re-encoded as a JSON
           number).

           Note that precision is not accuracy - binary floating point values
           cannot represent most decimal fractions exactly, and when converting
           from and to floating point, &quot;JSON&quot; only guarantees precision up to
           but not including the leats significant bit.

           If the backend is JSON::PP and &quot;allow_bignum&quot; is enable, the big
           integers and the numeric can be optionally converted into
           Math::BigInt and Math::BigFloat objects.

       true, false
           These JSON atoms become &quot;JSON::true&quot; and &quot;JSON::false&quot;, respectively.
           They are overloaded to act almost exactly like the numbers 1 and 0.
           You can check wether a scalar is a JSON boolean by using the
           &quot;JSON::is_bool&quot; function.

           If &quot;JSON::true&quot; and &quot;JSON::false&quot; are used as strings or compared as
           strings, they represent as &quot;true&quot; and &quot;false&quot; respectively.

              print JSON::true . &quot;\n&quot;;
               =&gt; true
              print JSON::true + 1;
               =&gt; 1

              ok(JSON::true eq &apos;true&apos;);
              ok(JSON::true eq  &apos;1&apos;);
              ok(JSON::true == 1);

           &quot;JSON&quot; will install these missing overloading features to the backend
           modules.

       null
           A JSON null atom becomes &quot;undef&quot; in Perl.

           &quot;JSON::null&quot; returns &quot;unddef&quot;.

   PERL -&gt; JSON
       The mapping from Perl to JSON is slightly more difficult, as Perl is a
       truly typeless language, so we can only guess which JSON type is meant by
       a Perl value.

       hash references
           Perl hash references become JSON objects. As there is no inherent
           ordering in hash keys (or JSON objects), they will usually be encoded
           in a pseudo-random order that can change between runs of the same
           program but stays generally the same within a single run of a
           program. &quot;JSON&quot; optionally sort the hash keys (determined by the
           canonical flag), so the same datastructure will serialise to the same
           JSON text (given same settings and version of JSON::XS), but this
           incurs a runtime overhead and is only rarely useful, e.g. when you
           want to compare some JSON text against another for equality.

           In future, the ordered object feature will be added to JSON::PP using
           &quot;tie&quot; mechanism.

       array references
           Perl array references become JSON arrays.

       other references
           Other unblessed references are generally not allowed and will cause
           an exception to be thrown, except for references to the integers 0
           and 1, which get turned into &quot;false&quot; and &quot;true&quot; atoms in JSON. You
           can also use &quot;JSON::false&quot; and &quot;JSON::true&quot; to improve readability.

              to_json [\0,JSON::true]      # yields [false,true]

       JSON::true, JSON::false, JSON::null
           These special values become JSON true and JSON false values,
           respectively. You can also use &quot;\1&quot; and &quot;\0&quot; directly if you want.

           JSON::null returns &quot;undef&quot;.

       blessed objects
           Blessed objects are not directly representable in JSON. See the
           &quot;allow_blessed&quot; and &quot;convert_blessed&quot; methods on various options on
           how to deal with this: basically, you can choose between throwing an
           exception, encoding the reference as if it weren&apos;t blessed, or
           provide your own serialiser method.

           With &quot;convert_blessed_universally&quot; mode,  &quot;encode&quot; converts blessed
           hash references or blessed array references (contains other blessed
           references) into JSON members and arrays.

              use JSON -convert_blessed_universally;
              JSON-&gt;new-&gt;allow_blessed-&gt;convert_blessed-&gt;encode( $blessed_object );

           See to convert_blessed.

       simple scalars
           Simple Perl scalars (any scalar that is not a reference) are the most
           difficult objects to encode: JSON::XS and JSON::PP will encode
           undefined scalars as JSON &quot;null&quot; values, scalars that have last been
           used in a string context before encoding as JSON strings, and
           anything else as number value:

              # dump as number
              encode_json [2]                      # yields [2]
              encode_json [-3.0e17]                # yields [-3e+17]
              my $value = 5; encode_json [$value]  # yields [5]

              # used as string, so dump as string
              print $value;
              encode_json [$value]                 # yields [&quot;5&quot;]

              # undef becomes null
              encode_json [undef]                  # yields [null]

           You can force the type to be a string by stringifying it:

              my $x = 3.1; # some variable containing a number
              &quot;$x&quot;;        # stringified
              $x .= &quot;&quot;;    # another, more awkward way to stringify
              print $x;    # perl does it for you, too, quite often

           You can force the type to be a number by numifying it:

              my $x = &quot;3&quot;; # some variable containing a string
              $x += 0;     # numify it, ensuring it will be dumped as a number
              $x *= 1;     # same thing, the choise is yours.

           You can not currently force the type in other, less obscure, ways.

           Note that numerical precision has the same meaning as under Perl (so
           binary to decimal conversion follows the same rules as in Perl, which
           can differ to other languages). Also, your perl interpreter might
           expose extensions to the floating point numbers of your platform,
           such as infinities or NaN&apos;s - these cannot be represented in JSON,
           and it is an error to pass those in.

       Big Number
           If the backend is JSON::PP and &quot;allow_bignum&quot; is enable, &quot;encode&quot;
           converts &quot;Math::BigInt&quot; objects and &quot;Math::BigFloat&quot; objects into
           JSON numbers.

JSON and ECMAscript
       See to &quot;JSON and ECMAscript&quot; in JSON::XS.

JSON and YAML
       JSON is not a subset of YAML.  See to &quot;JSON and YAML&quot; in JSON::XS.

BACKEND MODULE DECISION
       When you use &quot;JSON&quot;, &quot;JSON&quot; tries to &quot;use&quot; JSON::XS. If this call failed,
       it will &quot;uses&quot; JSON::PP. The required JSON::XS version is 2.2 or later.

       The &quot;JSON&quot; constructor method returns an object inherited from the
       backend module, and JSON::XS object is a blessed scaler reference while
       JSON::PP is a blessed hash reference.

       So, your program should not depend on the backend module, especially
       returned objects should not be modified.

        my $json = JSON-&gt;new; # XS or PP?
        $json-&gt;{stash} = &apos;this is xs object&apos;; # this code may raise an error!

       To check the backend module, there are some methods - &quot;backend&quot;, &quot;is_pp&quot;
       and &quot;is_xs&quot;.

         JSON-&gt;backend; # &apos;JSON::XS&apos; or &apos;JSON::PP&apos;

         JSON-&gt;backend-&gt;is_pp: # 0 or 1

         JSON-&gt;backend-&gt;is_xs: # 1 or 0

         $json-&gt;is_xs; # 1 or 0

         $json-&gt;is_pp; # 0 or 1

       If you set an enviornment variable &quot;PERL_JSON_BACKEND&quot;, The calling
       action will be changed.

       PERL_JSON_BACKEND = 0 or PERL_JSON_BACKEND = &apos;JSON::PP&apos;
           Always use JSON::PP
&#12;       PERL_JSON_BACKEND == 1 or PERL_JSON_BACKEND = &apos;JSON::XS,JSON::PP&apos;
           (The default) Use compiled JSON::XS if it is properly compiled &amp;
           installed, otherwise use JSON::PP.

       PERL_JSON_BACKEND == 2 or PERL_JSON_BACKEND = &apos;JSON::XS&apos;
           Always use compiled JSON::XS, die if it isn&apos;t properly compiled &amp;
           installed.

       PERL_JSON_BACKEND = &apos;JSON::backportPP&apos;
           Always use JSON::backportPP.  JSON::backportPP is JSON::PP back port
           module.  &quot;JSON&quot; includs JSON::backportPP instead of JSON::PP.

       These ideas come from DBI::PurePerl mechanism.

       example:

        BEGIN { $ENV{PERL_JSON_BACKEND} = &apos;JSON::PP&apos; }
        use JSON; # always uses JSON::PP

       In future, it may be able to specify another module.

USE PP FEATURES EVEN THOUGH XS BACKEND
       Many methods are available with either JSON::XS or JSON::PP and when the
       backend module is JSON::XS, if any JSON::PP specific (i.e. JSON::XS
       unspported) method is called, it will &quot;warn&quot; and be noop.

       But If you &quot;use&quot; &quot;JSON&quot; passing the optional string &quot;-support_by_pp&quot;, it
       makes a part of those unupported methods available.  This feature is
       achieved by using JSON::PP in &quot;de/encode&quot;.

          BEGIN { $ENV{PERL_JSON_BACKEND} = 2 } # with JSON::XS
          use JSON -support_by_pp;
          my $json = new JSON;
          $json-&gt;allow_nonref-&gt;escape_slash-&gt;encode(&quot;/&quot;);

       At this time, the returned object is a &quot;JSON::Backend::XS::Supportable&quot;
       object (re-blessed XS object), and  by checking JSON::XS unsupported
       flags in de/encoding, can support some unsupported methods - &quot;loose&quot;,
       &quot;allow_bignum&quot;, &quot;allow_barekey&quot;, &quot;allow_singlequote&quot;, &quot;escape_slash&quot; and
       &quot;indent_length&quot;.

       When any unsupported methods are not enable, &quot;XS de/encode&quot; will be used
       as is. The switch is achieved by changing the symbolic tables.

       &quot;-support_by_pp&quot; is effective only when the backend module is JSON::XS
       and it makes the de/encoding speed down a bit.

       See to &quot;JSON::PP SUPPORT METHODS&quot;.

INCOMPATIBLE CHANGES TO OLD VERSION
       There are big incompatibility between new version (2.00) and old (1.xx).
       If you use old &quot;JSON&quot; 1.xx in your code, please check it.

       See to &quot;Transition ways from 1.xx to 2.xx.&quot;

       jsonToObj and objToJson are obsoleted.
           Non Perl-style name &quot;jsonToObj&quot; and &quot;objToJson&quot; are obsoleted (but
           not yet deleted from the source).  If you use these functions in your
           code, please replace them with &quot;from_json&quot; and &quot;to_json&quot;.

       Global variables are no longer available.
           &quot;JSON&quot; class variables - $JSON::AUTOCONVERT, $JSON::BareKey, etc...
           - are not available any longer.  Instead, various features can be
           used through object methods.

       Package JSON::Converter and JSON::Parser are deleted.
           Now &quot;JSON&quot; bundles with JSON::PP which can handle JSON more properly
           than them.

       Package JSON::NotString is deleted.
           There was &quot;JSON::NotString&quot; class which represents JSON value &quot;true&quot;,
           &quot;false&quot;, &quot;null&quot; and numbers. It was deleted and replaced by
           &quot;JSON::Boolean&quot;.

           &quot;JSON::Boolean&quot; represents &quot;true&quot; and &quot;false&quot;.

           &quot;JSON::Boolean&quot; does not represent &quot;null&quot;.

           &quot;JSON::null&quot; returns &quot;undef&quot;.

           &quot;JSON&quot; makes JSON::XS::Boolean and JSON::PP::Boolean is-a relation to
           JSON::Boolean.

       function JSON::Number is obsoleted.
           &quot;JSON::Number&quot; is now needless because JSON::XS and JSON::PP have
           round-trip integrity.

       JSONRPC modules are deleted.
           Perl implementation of JSON-RPC protocol - &quot;JSONRPC &quot;,
           &quot;JSONRPC::Transport::HTTP&quot; and &quot;Apache::JSONRPC &quot; are deleted in this
           distribution.  Instead of them, there is JSON::RPC which supports
           JSON-RPC protocol version 1.1.

   Transition ways from 1.xx to 2.xx.
       You should set &quot;suport_by_pp&quot; mode firstly, because it is always
       successful for the below codes even with JSON::XS.

           use JSON -support_by_pp;

       Exported jsonToObj (simple)
             from_json($json_text);

       Exported objToJson (simple)
             to_json($perl_scalar);

       Exported jsonToObj (advanced)
             $flags = {allow_barekey =&gt; 1, allow_singlequote =&gt; 1};
             from_json($json_text, $flags);

           equivalent to:

             $JSON::BareKey = 1;
             $JSON::QuotApos = 1;
             jsonToObj($json_text);

       Exported objToJson (advanced)
             $flags = {allow_blessed =&gt; 1, allow_barekey =&gt; 1};
             to_json($perl_scalar, $flags);

           equivalent to:

             $JSON::BareKey = 1;
             objToJson($perl_scalar);

       jsonToObj as object method
             $json-&gt;decode($json_text);

       objToJson as object method
             $json-&gt;encode($perl_scalar);

       new method with parameters
           The &quot;new&quot; method in 2.x takes any parameters no longer.  You can set
           parameters instead;

              $json = JSON-&gt;new-&gt;pretty;

       $JSON::Pretty, $JSON::Indent, $JSON::Delimiter
           If &quot;indent&quot; is enable, that means $JSON::Pretty flag set. And
           $JSON::Delimiter was substituted by &quot;space_before&quot; and &quot;space_after&quot;.
           In conclusion:

              $json-&gt;indent-&gt;space_before-&gt;space_after;

           Equivalent to:

             $json-&gt;pretty;

           To change indent length, use &quot;indent_length&quot;.

           (Only with JSON::PP, if &quot;-support_by_pp&quot; is not used.)

             $json-&gt;pretty-&gt;indent_length(2)-&gt;encode($perl_scalar);

       $JSON::BareKey
           (Only with JSON::PP, if &quot;-support_by_pp&quot; is not used.)

             $json-&gt;allow_barekey-&gt;decode($json_text)

       $JSON::ConvBlessed
           use &quot;-convert_blessed_universally&quot;. See to convert_blessed.

       $JSON::QuotApos
           (Only with JSON::PP, if &quot;-support_by_pp&quot; is not used.)
&#12;             $json-&gt;allow_singlequote-&gt;decode($json_text)

       $JSON::SingleQuote
           Disable. &quot;JSON&quot; does not make such a invalid JSON string any longer.

       $JSON::KeySort
             $json-&gt;canonical-&gt;encode($perl_scalar)

           This is the ascii sort.

           If you want to use with your own sort routine, check the &quot;sort_by&quot;
           method.

           (Only with JSON::PP, even if &quot;-support_by_pp&quot; is used currently.)

             $json-&gt;sort_by($sort_routine_ref)-&gt;encode($perl_scalar)

             $json-&gt;sort_by(sub { $JSON::PP::a &lt;=&gt; $JSON::PP::b })-&gt;encode($perl_scalar)

           Can&apos;t access $a and $b but $JSON::PP::a and $JSON::PP::b.

       $JSON::SkipInvalid
             $json-&gt;allow_unknown

       $JSON::AUTOCONVERT
           Needless. &quot;JSON&quot; backend modules have the round-trip integrity.

       $JSON::UTF8
           Needless because &quot;JSON&quot; (JSON::XS/JSON::PP) sets the UTF8 flag on
           properly.

               # With UTF8-flagged strings

               $json-&gt;allow_nonref;
               $str = chr(1000); # UTF8-flagged

               $json_text  = $json-&gt;utf8(0)-&gt;encode($str);
               utf8::is_utf8($json_text);
               # true
               $json_text  = $json-&gt;utf8(1)-&gt;encode($str);
               utf8::is_utf8($json_text);
               # false

               $str = &apos;&quot;&apos; . chr(1000) . &apos;&quot;&apos;; # UTF8-flagged

               $perl_scalar  = $json-&gt;utf8(0)-&gt;decode($str);
               utf8::is_utf8($perl_scalar);
               # true
               $perl_scalar  = $json-&gt;utf8(1)-&gt;decode($str);
               # died because of &apos;Wide character in subroutine&apos;

           See to &quot;A FEW NOTES ON UNICODE AND PERL&quot; in JSON::XS.

       $JSON::UnMapping
           Disable. See to MAPPING.

       $JSON::SelfConvert
           This option was deleted.  Instead of it, if a givien blessed object
           has the &quot;TO_JSON&quot; method, &quot;TO_JSON&quot; will be executed with
           &quot;convert_blessed&quot;.

             $json-&gt;convert_blessed-&gt;encode($bleesed_hashref_or_arrayref)
             # if need, call allow_blessed

           Note that it was &quot;toJson&quot; in old version, but now not &quot;toJson&quot; but
           &quot;TO_JSON&quot;.

TODO
       example programs

THREADS
       No test with JSON::PP. If with JSON::XS, See to &quot;THREADS&quot; in JSON::XS.

BUGS
       Please report bugs relevant to &quot;JSON&quot; to &lt;makamaka[at]cpan.org&gt;.

SEE ALSO
       Most of the document is copied and modified from JSON::XS doc.

       JSON::XS, JSON::PP

       &quot;RFC4627&quot;(&lt;http://www.ietf.org/rfc/rfc4627.txt&gt;)

AUTHOR
       Makamaka Hannyaharamitu, &lt;makamaka[at]cpan.org&gt;

       JSON::XS was written by  Marc Lehmann &lt;schmorp[at]schmorp.de&gt;

       The relese of this new version owes to the courtesy of Marc Lehmann.

COPYRIGHT AND LICENSE
       Copyright 2005-2011 by Makamaka Hannyaharamitu

       This library is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.



perl v5.12.3                       2011-05-22                          JSON(3pm)

</pre></body></html>
