<html>
<head><meta charset=utf-8/>
<title>JSON::PP - JSON::XS compatible pure-Perl module.</title></head>
<body><pre>

JSON::backportPP(3pm)  User Contributed Perl Documentation JSON::backportPP(3pm)



NAME
       JSON::PP - JSON::XS compatible pure-Perl module.

SYNOPSIS
        use JSON::PP;

        # exported functions, they croak on error
        # and expect/generate UTF-8

        $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
        $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;

        # OO-interface

        $coder = JSON::PP-&gt;new-&gt;ascii-&gt;pretty-&gt;allow_nonref;

        $json_text   = $json-&gt;encode( $perl_scalar );
        $perl_scalar = $json-&gt;decode( $json_text );

        $pretty_printed = $json-&gt;pretty-&gt;encode( $perl_scalar ); # pretty-printing

        # Note that JSON version 2.0 and above will automatically use
        # JSON::XS or JSON::PP, so you should be able to just:

        use JSON;

VERSION
           2.27200

       JSON::XS 2.27 (~2.30) compatible.

DESCRIPTION
       This module is JSON::XS compatible pure Perl module.  (Perl 5.8 or later
       is recommended)

       JSON::XS is the fastest and most proper JSON module on CPAN.  It is
       written by Marc Lehmann in C, so must be compiled and installed in the
       used environment.

       JSON::PP is a pure-Perl module and has compatibility to JSON::XS.

   FEATURES
       &#183;   correct unicode handling

           This module knows how to handle Unicode (depending on Perl version).

           See to &quot;A FEW NOTES ON UNICODE AND PERL&quot; in JSON::XS and &quot;UNICODE
           HANDLING ON PERLS&quot;.

       &#183;   round-trip integrity

           When you serialise a perl data structure using only data types
           supported by JSON and Perl, the deserialised data structure is
           identical on the Perl level. (e.g. the string &quot;2.0&quot; doesn&apos;t suddenly
           become &quot;2&quot; just because it looks like a number). There are minor
           exceptions to this, read the MAPPING section below to learn about
           those.

       &#183;   strict checking of JSON correctness

           There is no guessing, no generating of illegal JSON texts by default,
           and only JSON is accepted as input by default (the latter is a
           security feature).  But when some options are set, loose chcking
           features are available.

FUNCTIONAL INTERFACE
       Some documents are copied and modified from &quot;FUNCTIONAL INTERFACE&quot; in
       JSON::XS.

   encode_json
           $json_text = encode_json $perl_scalar

       Converts the given Perl data structure to a UTF-8 encoded, binary string.

       This function call is functionally identical to:

           $json_text = JSON::PP-&gt;new-&gt;utf8-&gt;encode($perl_scalar)

   decode_json
           $perl_scalar = decode_json $json_text

       The opposite of &quot;encode_json&quot;: expects an UTF-8 (binary) string and tries
       to parse that as an UTF-8 encoded JSON text, returning the resulting
       reference.

       This function call is functionally identical to:

           $perl_scalar = JSON::PP-&gt;new-&gt;utf8-&gt;decode($json_text)

   JSON::PP::is_bool
           $is_boolean = JSON::PP::is_bool($scalar)

       Returns true if the passed scalar represents either JSON::PP::true or
       JSON::PP::false, two constants that act like 1 and 0 respectively and are
       also used to represent JSON &quot;true&quot; and &quot;false&quot; in Perl strings.

   JSON::PP::true
       Returns JSON true value which is blessed object.  It &quot;isa&quot;
       JSON::PP::Boolean object.

   JSON::PP::false
       Returns JSON false value which is blessed object.  It &quot;isa&quot;
       JSON::PP::Boolean object.

   JSON::PP::null
       Returns &quot;undef&quot;.

       See MAPPING, below, for more information on how JSON values are mapped to
       Perl.

HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER
       This section supposes that your perl vresion is 5.8 or later.

       If you know a JSON text from an outer world - a network, a file content,
       and so on, is encoded in UTF-8, you should use &quot;decode_json&quot; or &quot;JSON&quot;
       module object with &quot;utf8&quot; enable. And the decoded result will contain
       UNICODE characters.

         # from network
         my $json        = JSON::PP-&gt;new-&gt;utf8;
         my $json_text   = CGI-&gt;new-&gt;param( &apos;json_data&apos; );
         my $perl_scalar = $json-&gt;decode( $json_text );

         # from file content
         local $/;
         open( my $fh, &apos;&lt;&apos;, &apos;json.data&apos; );
         $json_text   = &lt;$fh&gt;;
         $perl_scalar = decode_json( $json_text );

       If an outer data is not encoded in UTF-8, firstly you should &quot;decode&quot; it.

         use Encode;
         local $/;
         open( my $fh, &apos;&lt;&apos;, &apos;json.data&apos; );
         my $encoding = &apos;cp932&apos;;
         my $unicode_json_text = decode( $encoding, &lt;$fh&gt; ); # UNICODE

         # or you can write the below code.
         #
         # open( my $fh, &quot;&lt;:encoding($encoding)&quot;, &apos;json.data&apos; );
         # $unicode_json_text = &lt;$fh&gt;;

       In this case, $unicode_json_text is of course UNICODE string.  So you
       cannot use &quot;decode_json&quot; nor &quot;JSON&quot; module object with &quot;utf8&quot; enable.
       Instead of them, you use &quot;JSON&quot; module object with &quot;utf8&quot; disable.

         $perl_scalar = $json-&gt;utf8(0)-&gt;decode( $unicode_json_text );

       Or &quot;encode &apos;utf8&apos;&quot; and &quot;decode_json&quot;:

         $perl_scalar = decode_json( encode( &apos;utf8&apos;, $unicode_json_text ) );
         # this way is not efficient.

       And now, you want to convert your $perl_scalar into JSON data and send it
       to an outer world - a network or a file content, and so on.

       Your data usually contains UNICODE strings and you want the converted
       data to be encoded in UTF-8, you should use &quot;encode_json&quot; or &quot;JSON&quot;
       module object with &quot;utf8&quot; enable.

         print encode_json( $perl_scalar ); # to a network? file? or display?
         # or
         print $json-&gt;utf8-&gt;encode( $perl_scalar );

       If $perl_scalar does not contain UNICODE but $encoding-encoded strings
       for some reason, then its characters are regarded as latin1 for perl
       (because it does not concern with your $encoding).  You cannot use
       &quot;encode_json&quot; nor &quot;JSON&quot; module object with &quot;utf8&quot; enable.  Instead of
       them, you use &quot;JSON&quot; module object with &quot;utf8&quot; disable.  Note that the
       resulted text is a UNICODE string but no problem to print it.

         # $perl_scalar contains $encoding encoded string values
         $unicode_json_text = $json-&gt;utf8(0)-&gt;encode( $perl_scalar );
         # $unicode_json_text consists of characters less than 0x100
         print $unicode_json_text;

       Or &quot;decode $encoding&quot; all string values and &quot;encode_json&quot;:

         $perl_scalar-&gt;{ foo } = decode( $encoding, $perl_scalar-&gt;{ foo } );
         # ... do it to each string values, then encode_json
         $json_text = encode_json( $perl_scalar );

       This method is a proper way but probably not efficient.

       See to Encode, perluniintro.

METHODS
       Basically, check to JSON or JSON::XS.

   new
           $json = JSON::PP-&gt;new

       Rturns a new JSON::PP object that can be used to de/encode JSON strings.
&#12;       All boolean flags described below are by default disabled.

       The mutators for flags all return the JSON object again and thus calls
       can be chained:

          my $json = JSON::PP-&gt;new-&gt;utf8-&gt;space_after-&gt;encode({a =&gt; [1,2]})
          =&gt; {&quot;a&quot;: [1, 2]}

   ascii
           $json = $json-&gt;ascii([$enable])

           $enabled = $json-&gt;get_ascii

       If $enable is true (or missing), then the encode method will not generate
       characters outside the code range 0..127. Any Unicode characters outside
       that range will be escaped using either a single \uXXXX or a double
       \uHHHH\uLLLLL escape sequence, as per RFC4627.  (See to &quot;OBJECT-ORIENTED
       INTERFACE&quot; in JSON::XS).

       In Perl 5.005, there is no character having high value (more than 255).
       See to &quot;UNICODE HANDLING ON PERLS&quot;.

       If $enable is false, then the encode method will not escape Unicode
       characters unless required by the JSON syntax or other flags. This
       results in a faster and more compact format.

         JSON::PP-&gt;new-&gt;ascii(1)-&gt;encode([chr 0x10401])
         =&gt; [&quot;\ud801\udc01&quot;]

   latin1
           $json = $json-&gt;latin1([$enable])

           $enabled = $json-&gt;get_latin1

       If $enable is true (or missing), then the encode method will encode the
       resulting JSON text as latin1 (or iso-8859-1), escaping any characters
       outside the code range 0..255.

       If $enable is false, then the encode method will not escape Unicode
       characters unless required by the JSON syntax or other flags.

         JSON::XS-&gt;new-&gt;latin1-&gt;encode ([&quot;\x{89}\x{abc}&quot;]
         =&gt; [&quot;\x{89}\\u0abc&quot;]    # (perl syntax, U+abc escaped, U+89 not)

       See to &quot;UNICODE HANDLING ON PERLS&quot;.

   utf8
           $json = $json-&gt;utf8([$enable])

           $enabled = $json-&gt;get_utf8

       If $enable is true (or missing), then the encode method will encode the
       JSON result into UTF-8, as required by many protocols, while the decode
       method expects to be handled an UTF-8-encoded string. Please note that
       UTF-8-encoded strings do not contain any characters outside the range
       0..255, they are thus useful for bytewise/binary I/O.

       (In Perl 5.005, any character outside the range 0..255 does not exist.
       See to &quot;UNICODE HANDLING ON PERLS&quot;.)

       In future versions, enabling this option might enable autodetection of
       the UTF-16 and UTF-32 encoding families, as described in RFC4627.

       If $enable is false, then the encode method will return the JSON string
       as a (non-encoded) Unicode string, while decode expects thus a Unicode
       string. Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs to be
       done yourself, e.g. using the Encode module.

       Example, output UTF-16BE-encoded JSON:

         use Encode;
         $jsontext = encode &quot;UTF-16BE&quot;, JSON::PP-&gt;new-&gt;encode ($object);

       Example, decode UTF-32LE-encoded JSON:

         use Encode;
         $object = JSON::PP-&gt;new-&gt;decode (decode &quot;UTF-32LE&quot;, $jsontext);

   pretty
           $json = $json-&gt;pretty([$enable])

       This enables (or disables) all of the &quot;indent&quot;, &quot;space_before&quot; and
       &quot;space_after&quot; flags in one call to generate the most readable (or most
       compact) form possible.

       Equivalent to:

          $json-&gt;indent-&gt;space_before-&gt;space_after

   indent
           $json = $json-&gt;indent([$enable])

           $enabled = $json-&gt;get_indent

       The default indent space length is three.  You can use &quot;indent_length&quot; to
       change the length.

   space_before
           $json = $json-&gt;space_before([$enable])

           $enabled = $json-&gt;get_space_before

       If $enable is true (or missing), then the &quot;encode&quot; method will add an
       extra optional space before the &quot;:&quot; separating keys from values in JSON
       objects.

       If $enable is false, then the &quot;encode&quot; method will not add any extra
       space at those places.

       This setting has no effect when decoding JSON texts.

       Example, space_before enabled, space_after and indent disabled:

          {&quot;key&quot; :&quot;value&quot;}

   space_after
           $json = $json-&gt;space_after([$enable])

           $enabled = $json-&gt;get_space_after

       If $enable is true (or missing), then the &quot;encode&quot; method will add an
       extra optional space after the &quot;:&quot; separating keys from values in JSON
       objects and extra whitespace after the &quot;,&quot; separating key-value pairs and
       array members.

       If $enable is false, then the &quot;encode&quot; method will not add any extra
       space at those places.

       This setting has no effect when decoding JSON texts.

       Example, space_before and indent disabled, space_after enabled:
&#12;          {&quot;key&quot;: &quot;value&quot;}

   relaxed
           $json = $json-&gt;relaxed([$enable])

           $enabled = $json-&gt;get_relaxed

       If $enable is true (or missing), then &quot;decode&quot; will accept some
       extensions to normal JSON syntax (see below). &quot;encode&quot; will not be
       affected in anyway. Be aware that this option makes you accept invalid
       JSON texts as if they were valid!. I suggest only to use this option to
       parse application-specific files written by humans (configuration files,
       resource files etc.)

       If $enable is false (the default), then &quot;decode&quot; will only accept valid
       JSON texts.

       Currently accepted extensions are:

       &#183;   list items can have an end-comma

           JSON separates array elements and key-value pairs with commas. This
           can be annoying if you write JSON texts manually and want to be able
           to quickly append elements, so this extension accepts comma at the
           end of such items not just between them:

              [
                 1,
                 2, &lt;- this comma not normally allowed
              ]
              {
                 &quot;k1&quot;: &quot;v1&quot;,
                 &quot;k2&quot;: &quot;v2&quot;, &lt;- this comma not normally allowed
              }

       &#183;   shell-style &apos;#&apos;-comments

           Whenever JSON allows whitespace, shell-style comments are
           additionally allowed. They are terminated by the first carriage-
           return or line-feed character, after which more white-space and
           comments are allowed.

             [
                1, # this comment not allowed in JSON
                   # neither this one...
             ]

   canonical
           $json = $json-&gt;canonical([$enable])

           $enabled = $json-&gt;get_canonical

       If $enable is true (or missing), then the &quot;encode&quot; method will output
       JSON objects by sorting their keys. This is adding a comparatively high
       overhead.

       If $enable is false, then the &quot;encode&quot; method will output key-value pairs
       in the order Perl stores them (which will likely change between runs of
       the same script).

       This option is useful if you want the same data structure to be encoded
       as the same JSON text (given the same overall settings). If it is
       disabled, the same hash might be encoded differently even if contains the
       same data, as key-value pairs have no inherent ordering in Perl.

       This setting has no effect when decoding JSON texts.

       If you want your own sorting routine, you can give a code referece or a
       subroutine name to &quot;sort_by&quot;. See to &quot;JSON::PP OWN METHODS&quot;.

   allow_nonref
           $json = $json-&gt;allow_nonref([$enable])

           $enabled = $json-&gt;get_allow_nonref

       If $enable is true (or missing), then the &quot;encode&quot; method can convert a
       non-reference into its corresponding string, number or null JSON value,
       which is an extension to RFC4627. Likewise, &quot;decode&quot; will accept those
       JSON values instead of croaking.

       If $enable is false, then the &quot;encode&quot; method will croak if it isn&apos;t
       passed an arrayref or hashref, as JSON texts must either be an object or
       array. Likewise, &quot;decode&quot; will croak if given something that is not a
       JSON object or array.

          JSON::PP-&gt;new-&gt;allow_nonref-&gt;encode (&quot;Hello, World!&quot;)
          =&gt; &quot;Hello, World!&quot;

   allow_unknown
           $json = $json-&gt;allow_unknown ([$enable])

           $enabled = $json-&gt;get_allow_unknown

       If $enable is true (or missing), then &quot;encode&quot; will *not* throw an
       exception when it encounters values it cannot represent in JSON (for
       example, filehandles) but instead will encode a JSON &quot;null&quot; value.  Note
       that blessed objects are not included here and are handled separately by
       c&lt;allow_nonref&gt;.

       If $enable is false (the default), then &quot;encode&quot; will throw an exception
       when it encounters anything it cannot encode as JSON.

       This option does not affect &quot;decode&quot; in any way, and it is recommended to
       leave it off unless you know your communications partner.

   allow_blessed
           $json = $json-&gt;allow_blessed([$enable])

           $enabled = $json-&gt;get_allow_blessed

       If $enable is true (or missing), then the &quot;encode&quot; method will not barf
       when it encounters a blessed reference. Instead, the value of the
       convert_blessed option will decide whether &quot;null&quot; (&quot;convert_blessed&quot;
       disabled or no &quot;TO_JSON&quot; method found) or a representation of the object
       (&quot;convert_blessed&quot; enabled and &quot;TO_JSON&quot; method found) is being encoded.
       Has no effect on &quot;decode&quot;.

       If $enable is false (the default), then &quot;encode&quot; will throw an exception
       when it encounters a blessed object.

   convert_blessed
           $json = $json-&gt;convert_blessed([$enable])

           $enabled = $json-&gt;get_convert_blessed

       If $enable is true (or missing), then &quot;encode&quot;, upon encountering a
       blessed object, will check for the availability of the &quot;TO_JSON&quot; method
       on the object&apos;s class. If found, it will be called in scalar context and
       the resulting scalar will be encoded instead of the object. If no
       &quot;TO_JSON&quot; method is found, the value of &quot;allow_blessed&quot; will decide what
       to do.
&#12;       The &quot;TO_JSON&quot; method may safely call die if it wants. If &quot;TO_JSON&quot;
       returns other blessed objects, those will be handled in the same way.
       &quot;TO_JSON&quot; must take care of not causing an endless recursion cycle (==
       crash) in this case. The name of &quot;TO_JSON&quot; was chosen because other
       methods called by the Perl core (== not by the user of the object) are
       usually in upper case letters and to avoid collisions with the &quot;to_json&quot;
       function or method.

       This setting does not yet influence &quot;decode&quot; in any way.

       If $enable is false, then the &quot;allow_blessed&quot; setting will decide what to
       do when a blessed object is found.

   filter_json_object
           $json = $json-&gt;filter_json_object([$coderef])

       When $coderef is specified, it will be called from &quot;decode&quot; each time it
       decodes a JSON object. The only argument passed to the coderef is a
       reference to the newly-created hash. If the code references returns a
       single scalar (which need not be a reference), this value (i.e. a copy of
       that scalar to avoid aliasing) is inserted into the deserialised data
       structure. If it returns an empty list (NOTE: not &quot;undef&quot;, which is a
       valid scalar), the original deserialised hash will be inserted. This
       setting can slow down decoding considerably.

       When $coderef is omitted or undefined, any existing callback will be
       removed and &quot;decode&quot; will not change the deserialised hash in any way.

       Example, convert all JSON objects into the integer 5:

          my $js = JSON::PP-&gt;new-&gt;filter_json_object (sub { 5 });
          # returns [5]
          $js-&gt;decode (&apos;[{}]&apos;); # the given subroutine takes a hash reference.
          # throw an exception because allow_nonref is not enabled
          # so a lone 5 is not allowed.
          $js-&gt;decode (&apos;{&quot;a&quot;:1, &quot;b&quot;:2}&apos;);

   filter_json_single_key_object
           $json = $json-&gt;filter_json_single_key_object($key [=&gt; $coderef])

       Works remotely similar to &quot;filter_json_object&quot;, but is only called for
       JSON objects having a single key named $key.

       This $coderef is called before the one specified via
       &quot;filter_json_object&quot;, if any. It gets passed the single value in the JSON
       object. If it returns a single value, it will be inserted into the data
       structure. If it returns nothing (not even &quot;undef&quot; but the empty list),
       the callback from &quot;filter_json_object&quot; will be called next, as if no
       single-key callback were specified.

       If $coderef is omitted or undefined, the corresponding callback will be
       disabled. There can only ever be one callback for a given key.

       As this callback gets called less often then the &quot;filter_json_object&quot;
       one, decoding speed will not usually suffer as much. Therefore, single-
       key objects make excellent targets to serialise Perl objects into,
       especially as single-key JSON objects are as close to the type-tagged
       value concept as JSON gets (it&apos;s basically an ID/VALUE tuple). Of course,
       JSON does not support this in any way, so you need to make sure your data
       never looks like a serialised Perl hash.

       Typical names for the single object key are &quot;__class_whatever__&quot;, or
       &quot;$__dollars_are_rarely_used__$&quot; or &quot;}ugly_brace_placement&quot;, or even
       things like &quot;__class_md5sum(classname)__&quot;, to reduce the risk of clashing
       with real hashes.
&#12;       Example, decode JSON objects of the form &quot;{ &quot;__widget__&quot; =&gt; &lt;id&gt; }&quot; into
       the corresponding $WIDGET{&lt;id&gt;} object:

          # return whatever is in $WIDGET{5}:
          JSON::PP
             -&gt;new
             -&gt;filter_json_single_key_object (__widget__ =&gt; sub {
                   $WIDGET{ $_[0] }
                })
             -&gt;decode (&apos;{&quot;__widget__&quot;: 5&apos;)

          # this can be used with a TO_JSON method in some &quot;widget&quot; class
          # for serialisation to json:
          sub WidgetBase::TO_JSON {
             my ($self) = @_;

             unless ($self-&gt;{id}) {
                $self-&gt;{id} = ..get..some..id..;
                $WIDGET{$self-&gt;{id}} = $self;
             }

             { __widget__ =&gt; $self-&gt;{id} }
          }

   shrink
           $json = $json-&gt;shrink([$enable])

           $enabled = $json-&gt;get_shrink

       In JSON::XS, this flag resizes strings generated by either &quot;encode&quot; or
       &quot;decode&quot; to their minimum size possible.  It will also try to downgrade
       any strings to octet-form if possible.

       In JSON::PP, it is noop about resizing strings but tries
       &quot;utf8::downgrade&quot; to the returned string by &quot;encode&quot;.  See to utf8.

       See to &quot;OBJECT-ORIENTED INTERFACE&quot; in JSON::XS

   max_depth
           $json = $json-&gt;max_depth([$maximum_nesting_depth])

           $max_depth = $json-&gt;get_max_depth

       Sets the maximum nesting level (default 512) accepted while encoding or
       decoding. If a higher nesting level is detected in JSON text or a Perl
       data structure, then the encoder and decoder will stop and croak at that
       point.

       Nesting level is defined by number of hash- or arrayrefs that the encoder
       needs to traverse to reach a given point or the number of &quot;{&quot; or &quot;[&quot;
       characters without their matching closing parenthesis crossed to reach a
       given character in a string.

       If no argument is given, the highest possible setting will be used, which
       is rarely useful.

       See &quot;SSECURITY CONSIDERATIONS&quot; in JSON::XS for more info on why this is
       useful.

       When a large value (100 or more) was set and it de/encodes a deep nested
       object/text, it may raise a warning &apos;Deep recursion on subroutin&apos; at the
       perl runtime phase.

   max_size
           $json = $json-&gt;max_size([$maximum_string_size])
&#12;           $max_size = $json-&gt;get_max_size

       Set the maximum length a JSON text may have (in bytes) where decoding is
       being attempted. The default is 0, meaning no limit. When &quot;decode&quot; is
       called on a string that is longer then this many bytes, it will not
       attempt to decode the string but throw an exception. This setting has no
       effect on &quot;encode&quot; (yet).

       If no argument is given, the limit check will be deactivated (same as
       when 0 is specified).

       See &quot;SSECURITY CONSIDERATIONS&quot; in JSON::XS for more info on why this is
       useful.

   encode
           $json_text = $json-&gt;encode($perl_scalar)

       Converts the given Perl data structure (a simple scalar or a reference to
       a hash or array) to its JSON representation. Simple scalars will be
       converted into JSON string or number sequences, while references to
       arrays become JSON arrays and references to hashes become JSON objects.
       Undefined Perl values (e.g. &quot;undef&quot;) become JSON &quot;null&quot; values.
       References to the integers 0 and 1 are converted into &quot;true&quot; and &quot;false&quot;.

   decode
           $perl_scalar = $json-&gt;decode($json_text)

       The opposite of &quot;encode&quot;: expects a JSON text and tries to parse it,
       returning the resulting simple scalar or reference. Croaks on error.

       JSON numbers and strings become simple Perl scalars. JSON arrays become
       Perl arrayrefs and JSON objects become Perl hashrefs. &quot;true&quot; becomes 1
       (&quot;JSON::true&quot;), &quot;false&quot; becomes 0 (&quot;JSON::false&quot;) and &quot;null&quot; becomes
       &quot;undef&quot;.

   decode_prefix
           ($perl_scalar, $characters) = $json-&gt;decode_prefix($json_text)

       This works like the &quot;decode&quot; method, but instead of raising an exception
       when there is trailing garbage after the first JSON object, it will
       silently stop parsing there and return the number of characters consumed
       so far.

          JSON-&gt;new-&gt;decode_prefix (&quot;[1] the tail&quot;)
          =&gt; ([], 3)

INCREMENTAL PARSING
       Most of this section are copied and modified from &quot;INCREMENTAL PARSING&quot;
       in JSON::XS.

       In some cases, there is the need for incremental parsing of JSON texts.
       This module does allow you to parse a JSON stream incrementally.  It does
       so by accumulating text until it has a full JSON object, which it then
       can decode. This process is similar to using &quot;decode_prefix&quot; to see if a
       full JSON object is available, but is much more efficient (and can be
       implemented with a minimum of method calls).

       This module will only attempt to parse the JSON text once it is sure it
       has enough text to get a decisive result, using a very simple but truly
       incremental parser. This means that it sometimes won&apos;t stop as early as
       the full parser, for example, it doesn&apos;t detect parenthese mismatches.
       The only thing it guarantees is that it starts decoding as soon as a
       syntactically valid JSON text has been seen. This means you need to set
       resource limits (e.g. &quot;max_size&quot;) to ensure the parser will stop parsing
       in the presence if syntax errors.
&#12;       The following methods implement this incremental parser.

   incr_parse
           $json-&gt;incr_parse( [$string] ) # void context

           $obj_or_undef = $json-&gt;incr_parse( [$string] ) # scalar context

           @obj_or_empty = $json-&gt;incr_parse( [$string] ) # list context

       This is the central parsing function. It can both append new text and
       extract objects from the stream accumulated so far (both of these
       functions are optional).

       If $string is given, then this string is appended to the already existing
       JSON fragment stored in the $json object.

       After that, if the function is called in void context, it will simply
       return without doing anything further. This can be used to add more text
       in as many chunks as you want.

       If the method is called in scalar context, then it will try to extract
       exactly one JSON object. If that is successful, it will return this
       object, otherwise it will return &quot;undef&quot;. If there is a parse error, this
       method will croak just as &quot;decode&quot; would do (one can then use &quot;incr_skip&quot;
       to skip the errornous part). This is the most common way of using the
       method.

       And finally, in list context, it will try to extract as many objects from
       the stream as it can find and return them, or the empty list otherwise.
       For this to work, there must be no separators between the JSON objects or
       arrays, instead they must be concatenated back-to-back. If an error
       occurs, an exception will be raised as in the scalar context case. Note
       that in this case, any previously-parsed JSON texts will be lost.

       Example: Parse some JSON arrays/objects in a given string and return
       them.

           my @objs = JSON-&gt;new-&gt;incr_parse (&quot;[5][7][1,2]&quot;);

   incr_text
           $lvalue_string = $json-&gt;incr_text

       This method returns the currently stored JSON fragment as an lvalue, that
       is, you can manipulate it. This only works when a preceding call to
       &quot;incr_parse&quot; in scalar context successfully returned an object. Under all
       other circumstances you must not call this function (I mean it.  although
       in simple tests it might actually work, it will fail under real world
       conditions). As a special exception, you can also call this method before
       having parsed anything.

       This function is useful in two cases: a) finding the trailing text after
       a JSON object or b) parsing multiple JSON objects separated by non-JSON
       text (such as commas).

           $json-&gt;incr_text =~ s/\s*,\s*//;

       In Perl 5.005, &quot;lvalue&quot; attribute is not available.  You must write codes
       like the below:

           $string = $json-&gt;incr_text;
           $string =~ s/\s*,\s*//;
           $json-&gt;incr_text( $string );

   incr_skip
           $json-&gt;incr_skip
&#12;       This will reset the state of the incremental parser and will remove the
       parsed text from the input buffer. This is useful after &quot;incr_parse&quot;
       died, in which case the input buffer and incremental parser state is left
       unchanged, to skip the text parsed so far and to reset the parse state.

   incr_reset
           $json-&gt;incr_reset

       This completely resets the incremental parser, that is, after this call,
       it will be as if the parser had never parsed anything.

       This is useful if you want ot repeatedly parse JSON objects and want to
       ignore any trailing data, which means you have to reset the parser after
       each successful decode.

       See to &quot;INCREMENTAL PARSING&quot; in JSON::XS for examples.

JSON::PP OWN METHODS
   allow_singlequote
           $json = $json-&gt;allow_singlequote([$enable])

       If $enable is true (or missing), then &quot;decode&quot; will accept JSON strings
       quoted by single quotations that are invalid JSON format.

           $json-&gt;allow_singlequote-&gt;decode({&quot;foo&quot;:&apos;bar&apos;});
           $json-&gt;allow_singlequote-&gt;decode({&apos;foo&apos;:&quot;bar&quot;});
           $json-&gt;allow_singlequote-&gt;decode({&apos;foo&apos;:&apos;bar&apos;});

       As same as the &quot;relaxed&quot; option, this option may be used to parse
       application-specific files written by humans.

   allow_barekey
           $json = $json-&gt;allow_barekey([$enable])

       If $enable is true (or missing), then &quot;decode&quot; will accept bare keys of
       JSON object that are invalid JSON format.

       As same as the &quot;relaxed&quot; option, this option may be used to parse
       application-specific files written by humans.

           $json-&gt;allow_barekey-&gt;decode(&apos;{foo:&quot;bar&quot;}&apos;);

   allow_bignum
           $json = $json-&gt;allow_bignum([$enable])

       If $enable is true (or missing), then &quot;decode&quot; will convert the big
       integer Perl cannot handle as integer into a Math::BigInt object and
       convert a floating number (any) into a Math::BigFloat.

       On the contary, &quot;encode&quot; converts &quot;Math::BigInt&quot; objects and
       &quot;Math::BigFloat&quot; objects into JSON numbers with &quot;allow_blessed&quot; enable.

          $json-&gt;allow_nonref-&gt;allow_blessed-&gt;allow_bignum;
          $bigfloat = $json-&gt;decode(&apos;2.000000000000000000000000001&apos;);
          print $json-&gt;encode($bigfloat);
          # =&gt; 2.000000000000000000000000001

       See to &quot;MAPPING&quot; in JSON::XS aboout the normal conversion of JSON number.

   loose
           $json = $json-&gt;loose([$enable])

       The unescaped [\x00-\x1f\x22\x2f\x5c] strings are invalid in JSON strings
       and the module doesn&apos;t allow to &quot;decode&quot; to these (except for \x2f).  If
       $enable is true (or missing), then &quot;decode&quot;  will accept these unescaped
       strings.

           $json-&gt;loose-&gt;decode(qq|[&quot;abc
                                          def&quot;]|);

       See &quot;SSECURITY CONSIDERATIONS&quot; in JSON::XS.

   escape_slash
           $json = $json-&gt;escape_slash([$enable])

       According to JSON Grammar, slash (U+002F) is escaped. But default
       JSON::PP (as same as JSON::XS) encodes strings without escaping slash.

       If $enable is true (or missing), then &quot;encode&quot; will escape slashes.

   indent_length
           $json = $json-&gt;indent_length($length)

       JSON::XS indent space length is 3 and cannot be changed.  JSON::PP set
       the indent space length with the given $length.  The default is 3. The
       acceptable range is 0 to 15.

   sort_by
           $json = $json-&gt;sort_by($function_name)
           $json = $json-&gt;sort_by($subroutine_ref)

       If $function_name or $subroutine_ref are set, its sort routine are used
       in encoding JSON objects.

          $js = $pc-&gt;sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })-&gt;encode($obj);
          # is($js, q|{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5,&quot;f&quot;:6,&quot;g&quot;:7,&quot;h&quot;:8,&quot;i&quot;:9}|);

          $js = $pc-&gt;sort_by(&apos;own_sort&apos;)-&gt;encode($obj);
          # is($js, q|{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5,&quot;f&quot;:6,&quot;g&quot;:7,&quot;h&quot;:8,&quot;i&quot;:9}|);

          sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }

       As the sorting routine runs in the JSON::PP scope, the given subroutine
       name and the special variables $a, $b will begin &apos;JSON::PP::&apos;.

       If $integer is set, then the effect is same as &quot;canonical&quot; on.

INTERNAL
       For developers.

       PP_encode_box
           Returns

                   {
                       depth        =&gt; $depth,
                       indent_count =&gt; $indent_count,
                   }

       PP_decode_box
           Returns

                   {
                       text    =&gt; $text,
                       at      =&gt; $at,
                       ch      =&gt; $ch,
                       len     =&gt; $len,
                       depth   =&gt; $depth,
                       encoding      =&gt; $encoding,
                       is_valid_utf8 =&gt; $is_valid_utf8,
                   };

MAPPING
       This section is copied from JSON::XS and modified to &quot;JSON::PP&quot;.
       JSON::XS and JSON::PP mapping mechanisms are almost equivalent.

       See to &quot;MAPPING&quot; in JSON::XS.

   JSON -&gt; PERL
       object
           A JSON object becomes a reference to a hash in Perl. No ordering of
           object keys is preserved (JSON does not preserver object key ordering
           itself).

       array
           A JSON array becomes a reference to an array in Perl.

       string
           A JSON string becomes a string scalar in Perl - Unicode codepoints in
           JSON are represented by the same codepoints in the Perl string, so no
           manual decoding is necessary.

       number
           A JSON number becomes either an integer, numeric (floating point) or
           string scalar in perl, depending on its range and any fractional
           parts. On the Perl level, there is no difference between those as
           Perl handles all the conversion details, but an integer may take
           slightly less memory and might represent more values exactly than
           floating point numbers.

           If the number consists of digits only, &quot;JSON&quot; will try to represent
           it as an integer value. If that fails, it will try to represent it as
           a numeric (floating point) value if that is possible without loss of
           precision. Otherwise it will preserve the number as a string value
           (in which case you lose roundtripping ability, as the JSON number
           will be re-encoded toa JSON string).

           Numbers containing a fractional or exponential part will always be
           represented as numeric (floating point) values, possibly at a loss of
           precision (in which case you might lose perfect roundtripping
           ability, but the JSON number will still be re-encoded as a JSON
           number).

           Note that precision is not accuracy - binary floating point values
           cannot represent most decimal fractions exactly, and when converting
           from and to floating point, &quot;JSON&quot; only guarantees precision up to
           but not including the leats significant bit.

           When &quot;allow_bignum&quot; is enable, the big integers and the numeric can
           be optionally converted into Math::BigInt and Math::BigFloat objects.

       true, false
           These JSON atoms become &quot;JSON::PP::true&quot; and &quot;JSON::PP::false&quot;,
           respectively. They are overloaded to act almost exactly like the
           numbers 1 and 0. You can check wether a scalar is a JSON boolean by
           using the &quot;JSON::is_bool&quot; function.

              print JSON::PP::true . &quot;\n&quot;;
               =&gt; true
              print JSON::PP::true + 1;
               =&gt; 1

              ok(JSON::true eq  &apos;1&apos;);
              ok(JSON::true == 1);

           &quot;JSON&quot; will install these missing overloading features to the backend
           modules.

       null
           A JSON null atom becomes &quot;undef&quot; in Perl.

           &quot;JSON::PP::null&quot; returns &quot;unddef&quot;.
&#12;   PERL -&gt; JSON
       The mapping from Perl to JSON is slightly more difficult, as Perl is a
       truly typeless language, so we can only guess which JSON type is meant by
       a Perl value.

       hash references
           Perl hash references become JSON objects. As there is no inherent
           ordering in hash keys (or JSON objects), they will usually be encoded
           in a pseudo-random order that can change between runs of the same
           program but stays generally the same within a single run of a
           program. &quot;JSON&quot; optionally sort the hash keys (determined by the
           canonical flag), so the same datastructure will serialise to the same
           JSON text (given same settings and version of JSON::XS), but this
           incurs a runtime overhead and is only rarely useful, e.g. when you
           want to compare some JSON text against another for equality.

       array references
           Perl array references become JSON arrays.

       other references
           Other unblessed references are generally not allowed and will cause
           an exception to be thrown, except for references to the integers 0
           and 1, which get turned into &quot;false&quot; and &quot;true&quot; atoms in JSON. You
           can also use &quot;JSON::false&quot; and &quot;JSON::true&quot; to improve readability.

              to_json [\0,JSON::PP::true]      # yields [false,true]

       JSON::PP::true, JSON::PP::false, JSON::PP::null
           These special values become JSON true and JSON false values,
           respectively. You can also use &quot;\1&quot; and &quot;\0&quot; directly if you want.

           JSON::PP::null returns &quot;undef&quot;.

       blessed objects
           Blessed objects are not directly representable in JSON. See the
           &quot;allow_blessed&quot; and &quot;convert_blessed&quot; methods on various options on
           how to deal with this: basically, you can choose between throwing an
           exception, encoding the reference as if it weren&apos;t blessed, or
           provide your own serialiser method.

           See to convert_blessed.

       simple scalars
           Simple Perl scalars (any scalar that is not a reference) are the most
           difficult objects to encode: JSON::XS and JSON::PP will encode
           undefined scalars as JSON &quot;null&quot; values, scalars that have last been
           used in a string context before encoding as JSON strings, and
           anything else as number value:

              # dump as number
              encode_json [2]                      # yields [2]
              encode_json [-3.0e17]                # yields [-3e+17]
              my $value = 5; encode_json [$value]  # yields [5]

              # used as string, so dump as string
              print $value;
              encode_json [$value]                 # yields [&quot;5&quot;]

              # undef becomes null
              encode_json [undef]                  # yields [null]

           You can force the type to be a string by stringifying it:

              my $x = 3.1; # some variable containing a number
              &quot;$x&quot;;        # stringified
              $x .= &quot;&quot;;    # another, more awkward way to stringify
              print $x;    # perl does it for you, too, quite often
&#12;           You can force the type to be a number by numifying it:

              my $x = &quot;3&quot;; # some variable containing a string
              $x += 0;     # numify it, ensuring it will be dumped as a number
              $x *= 1;     # same thing, the choise is yours.

           You can not currently force the type in other, less obscure, ways.

           Note that numerical precision has the same meaning as under Perl (so
           binary to decimal conversion follows the same rules as in Perl, which
           can differ to other languages). Also, your perl interpreter might
           expose extensions to the floating point numbers of your platform,
           such as infinities or NaN&apos;s - these cannot be represented in JSON,
           and it is an error to pass those in.

       Big Number
           When &quot;allow_bignum&quot; is enable, &quot;encode&quot; converts &quot;Math::BigInt&quot;
           objects and &quot;Math::BigFloat&quot; objects into JSON numbers.

UNICODE HANDLING ON PERLS
       If you do not know about Unicode on Perl well, please check &quot;A FEW NOTES
       ON UNICODE AND PERL&quot; in JSON::XS.

   Perl 5.8 and later
       Perl can handle Unicode and the JSON::PP de/encode methods also work
       properly.

           $json-&gt;allow_nonref-&gt;encode(chr hex 3042);
           $json-&gt;allow_nonref-&gt;encode(chr hex 12345);

       Reuturns &quot;\u3042&quot; and &quot;\ud808\udf45&quot; respectively.

           $json-&gt;allow_nonref-&gt;decode(&apos;&quot;\u3042&quot;&apos;);
           $json-&gt;allow_nonref-&gt;decode(&apos;&quot;\ud808\udf45&quot;&apos;);

       Returns UTF-8 encoded strings with UTF8 flag, regarded as &quot;U+3042&quot; and
       &quot;U+12345&quot;.

       Note that the versions from Perl 5.8.0 to 5.8.2, Perl built-in &quot;join&quot; was
       broken, so JSON::PP wraps the &quot;join&quot; with a subroutine. Thus JSON::PP
       works slow in the versions.

   Perl 5.6
       Perl can handle Unicode and the JSON::PP de/encode methods also work.

   Perl 5.005
       Perl 5.005 is a byte sementics world -- all strings are sequences of
       bytes.  That means the unicode handling is not available.

       In encoding,

           $json-&gt;allow_nonref-&gt;encode(chr hex 3042);  # hex 3042 is 12354.
           $json-&gt;allow_nonref-&gt;encode(chr hex 12345); # hex 12345 is 74565.

       Returns &quot;B&quot; and &quot;E&quot;, as &quot;chr&quot; takes a value more than 255, it treats as
       &quot;$value % 256&quot;, so the above codes are equivalent to :

           $json-&gt;allow_nonref-&gt;encode(chr 66);
           $json-&gt;allow_nonref-&gt;encode(chr 69);

       In decoding,

           $json-&gt;decode(&apos;&quot;\u00e3\u0081\u0082&quot;&apos;);

       The returned is a byte sequence &quot;0xE3 0x81 0x82&quot; for UTF-8 encoded
       japanese character (&quot;HIRAGANA LETTER A&quot;).  And if it is represented in
       Unicode code point, &quot;U+3042&quot;.
&#12;       Next,

           $json-&gt;decode(&apos;&quot;\u3042&quot;&apos;);

       We ordinary expect the returned value is a Unicode character &quot;U+3042&quot;.
       But here is 5.005 world. This is &quot;0xE3 0x81 0x82&quot;.

           $json-&gt;decode(&apos;&quot;\ud808\udf45&quot;&apos;);

       This is not a character &quot;U+12345&quot; but bytes - &quot;0xf0 0x92 0x8d 0x85&quot;.

TODO
       speed
       memory saving

SEE ALSO
       Most of the document are copied and modified from JSON::XS doc.

       JSON::XS

       RFC4627 (&lt;http://www.ietf.org/rfc/rfc4627.txt&gt;)

AUTHOR
       Makamaka Hannyaharamitu, &lt;makamaka[at]cpan.org&gt;

COPYRIGHT AND LICENSE
       Copyright 2007-2011 by Makamaka Hannyaharamitu

       This library is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.



perl v5.12.3                       2011-05-22              JSON::backportPP(3pm)

</pre></body></html>
