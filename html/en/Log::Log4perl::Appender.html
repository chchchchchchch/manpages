<html>
<head><meta charset=utf-8/>
<title>Log::Log4perl::Appender - Log appender class</title></head>
<body><pre>

Appender(3pm)          User Contributed Perl Documentation         Appender(3pm)



NAME
       Log::Log4perl::Appender - Log appender class

SYNOPSIS
         use Log::Log4perl;

             # Define a logger
         my $logger = Log::Log4perl-&gt;get_logger(&quot;abc.def.ghi&quot;);

             # Define a layout
         my $layout = Log::Log4perl::Layout::PatternLayout-&gt;new(
                          &quot;%d (%F:%L)&gt; %m&quot;);

             # Define an appender
         my $appender = Log::Log4perl::Appender-&gt;new(
                          &quot;Log::Log4perl::Appender::Screen&quot;,
                          name =&gt; &apos;dumpy&apos;);

             # Set the appender&apos;s layout
         $appender-&gt;layout($layout);
         $logger-&gt;add_appender($appender);

DESCRIPTION
       This class is a wrapper around the &quot;Log::Log4perl::Appender&quot; appender
       set.

       It also supports the &lt;Log::Dispatch::*&gt; collections of appenders. The
       module hides the idiosyncrasies of &quot;Log::Dispatch&quot; (e.g. every dispatcher
       gotta have a name, but there&apos;s no accessor to retrieve it) from
       &quot;Log::Log4perl&quot; and yet re-uses the extremely useful variety of
       dispatchers already created and tested in &quot;Log::Dispatch&quot;.

FUNCTIONS
   Log::Log4perl::Appender-&gt;new($dispatcher_class_name, ...);
       The constructor &quot;new()&quot; takes the name of the appender class to be
       created as a string (!) argument, optionally followed by a number of
       appender-specific parameters, for example:

             # Define an appender
         my $appender = Log::Log4perl::Appender-&gt;new(
             &quot;Log::Log4perl::Appender::File&quot;
             filename =&gt; &apos;out.log&apos;);

       In case of &quot;Log::Dispatch&quot; appenders, if no &quot;name&quot; parameter is
       specified, the appender object will create a unique one (format
       &quot;appNNN&quot;), which can be retrieved later via the &quot;name()&quot; method:

         print &quot;The appender&apos;s name is &quot;, $appender-&gt;name(), &quot;\n&quot;;

       Other parameters are specific to the appender class being used.  In the
       case above, the &quot;filename&quot; parameter specifies the name of the
       &quot;Log::Log4perl::Appender::File&quot; dispatcher used.

       However, if, for instance, you&apos;re using a &quot;Log::Dispatch::Email&quot;
       dispatcher to send you email, you&apos;ll have to specify &quot;from&quot; and &quot;to&quot;
       email addresses.  Every dispatcher is different.  Please check the
       &quot;Log::Dispatch::*&quot; documentation for the appender used for details on
       specific requirements.

       The &quot;new()&quot; method will just pass these parameters on to a newly created
       &quot;Log::Dispatch::*&quot; object of the specified type.
&#12;       When it comes to logging, the &quot;Log::Log4perl::Appender&quot; will
       transparently relay all messages to the &quot;Log::Dispatch::*&quot; object it
       carries in its womb.

   $appender-&gt;layout($layout);
       The &quot;layout()&quot; method sets the log layout used by the appender to the
       format specified by the &quot;Log::Log4perl::Layout::*&quot; object which is passed
       to it as a reference.  Currently there&apos;s two layouts available:

           Log::Log4perl::Layout::SimpleLayout
           Log::Log4perl::Layout::PatternLayout

       Please check the Log::Log4perl::Layout::SimpleLayout and
       Log::Log4perl::Layout::PatternLayout manual pages for details.

Supported Appenders
       Here&apos;s the list of appender modules currently available via
       &quot;Log::Dispatch&quot;, if not noted otherwise, written by Dave Rolsky:

              Log::Dispatch::ApacheLog
              Log::Dispatch::DBI (by Tatsuhiko Miyagawa)
              Log::Dispatch::Email,
              Log::Dispatch::Email::MailSend,
              Log::Dispatch::Email::MailSendmail,
              Log::Dispatch::Email::MIMELite
              Log::Dispatch::File
              Log::Dispatch::FileRotate (by Mark Pfeiffer)
              Log::Dispatch::Handle
              Log::Dispatch::Screen
              Log::Dispatch::Syslog
              Log::Dispatch::Tk (by Dominique Dumont)

       &quot;Log4perl&quot; doesn&apos;t care which ones you use, they&apos;re all handled in the
       same way via the &quot;Log::Log4perl::Appender&quot; interface.  Please check the
       well-written manual pages of the &quot;Log::Dispatch&quot; hierarchy on how to use
       each one of them.

Parameters passed on to the appender&apos;s log() method
       When calling the appender&apos;s log()-Funktion, Log::Log4perl will submit a
       list of key/value pairs. Entries to the following keys are guaranteed to
       be present:

       message
           Text of the rendered message

       log4p_category
           Name of the category of the logger that triggered the event.

       log4p_level
           Log::Log4perl level of the event

Pitfalls
       Since the &quot;Log::Dispatch::File&quot; appender truncates log files by default,
       and most of the time this is not what you want, we&apos;ve instructed
       &quot;Log::Log4perl&quot; to change this behavior by slipping it the &quot;mode =&gt;
       append&quot; parameter behind the scenes. So, effectively with &quot;Log::Log4perl&quot;
       0.23, a configuration like

           log4perl.category = INFO, FileAppndr
           log4perl.appender.FileAppndr          = Log::Dispatch::File
           log4perl.appender.FileAppndr.filename = test.log
           log4perl.appender.FileAppndr.layout   = Log::Log4perl::Layout::SimpleLayout

       will always append to an existing logfile &quot;test.log&quot; while if you
       specifically request clobbering like in
&#12;           log4perl.category = INFO, FileAppndr
           log4perl.appender.FileAppndr          = Log::Dispatch::File
           log4perl.appender.FileAppndr.filename = test.log
           log4perl.appender.FileAppndr.mode     = write
           log4perl.appender.FileAppndr.layout   = Log::Log4perl::Layout::SimpleLayout

       it will overwrite an existing log file &quot;test.log&quot; and start from scratch.

Appenders Expecting Message Chunks
       Instead of simple strings, certain appenders are expecting multiple
       fields as log messages. If a statement like

           $logger-&gt;debug($ip, $user, &quot;signed in&quot;);

       causes an off-the-shelf &quot;Log::Log4perl::Appender::Screen&quot; appender to
       fire, the appender will just concatenate the three message chunks passed
       to it in order to form a single string.  The chunks will be separated by
       a string defined in $Log::Log4perl::JOIN_MSG_ARRAY_CHAR (defaults to the
       empty string &quot;&quot;).

       However, different appenders might choose to interpret the message above
       differently: An appender like &quot;Log::Log4perl::Appender::DBI&quot; might take
       the three arguments passed to the logger and put them in three separate
       rows into the DB.

       The  &quot;warp_message&quot; appender option is used to specify the desired
       behavior.  If no setting for the appender property

           # *** Not defined ***
           # log4perl.appender.SomeApp.warp_message

       is defined in the Log4perl configuration file, the appender referenced by
       &quot;SomeApp&quot; will fall back to the standard behavior and join all message
       chunks together, separating them by $Log::Log4perl::JOIN_MSG_ARRAY_CHAR.

       If, on the other hand, it is set to a false value, like in

           log4perl.appender.SomeApp.layout=NoopLayout
           log4perl.appender.SomeApp.warp_message = 0

       then the message chunks are passed unmodified to the appender as an array
       reference. Please note that you need to set the appender&apos;s layout to
       &quot;Log::Log4perl::Layout::NoopLayout&quot; which just leaves the messages chunks
       alone instead of formatting them or replacing conversion specifiers.

       Please note that the standard appenders in the Log::Dispatch hierarchy
       will choke on a bunch of messages passed to them as an array reference.
       You can&apos;t use &quot;warp_message = 0&quot; (or the function name syntax defined
       below) on them.  Only special appenders like Log::Log4perl::Appender::DBI
       can deal with this.

       If (and now we&apos;re getting fancy) an appender expects message chunks, but
       we would like to pre-inspect and probably modify them before they&apos;re
       actually passed to the appender&apos;s &quot;log&quot; method, an inspection subroutine
       can be defined with the appender&apos;s &quot;warp_message&quot; property:

           log4perl.appender.SomeApp.layout=NoopLayout
           log4perl.appender.SomeApp.warp_message = sub { \
                                                  $#_ = 2 if @_ &gt; 3; \
                                                  return @_; }

       The inspection subroutine defined by the &quot;warp_message&quot; property will
       receive the list of message chunks, like they were passed to the logger
       and is expected to return a corrected list.  The example above simply
       limits the argument list to a maximum of three by cutting off excess
       elements and returning the shortened list.

       Also, the warp function can be specified by name like in

           log4perl.appender.SomeApp.layout=NoopLayout
           log4perl.appender.SomeApp.warp_message = main::filter_my_message

       In this example, &quot;filter_my_message&quot; is a function in the &quot;main&quot; package,
       defined like this:

           my $COUNTER = 0;

           sub filter_my_message {
               my @chunks = @_;
               unshift @chunks, ++$COUNTER;
               return @chunks;
           }

       The subroutine above will add an ever increasing counter as an additional
       first field to every message passed to the &quot;SomeApp&quot; appender -- but not
       to any other appender in the system.

   Composite Appenders
       Composite appenders relay their messages to sub-appenders after providing
       some filtering or synchronizing functionality on incoming messages.
       Examples are Log::Log4perl::Appender::Synchronized,
       Log::Log4perl::Appender::Limit, and Log::Log4perl::Appender::Buffer.
       Check their manual pages for details.

       Composite appender objects are regular Log::Log4perl::Appender objects,
       but they have the composite flag set:

           $app-&gt;composite(1);

       and they define a post_init() method, which sets the appender it relays
       its messages to:

           ###########################################
           sub post_init {
           ############################################
               my($self) = @_;

               if(! exists $self-&gt;{appender}) {
                   die &quot;No appender defined for &quot; . __PACKAGE__;
               }

               my $appenders = Log::Log4perl-&gt;appenders();
               my $appender = Log::Log4perl-&gt;appenders()-&gt;{$self-&gt;{appender}};

               if(! defined $appender) {
                   die &quot;Appender $self-&gt;{appender} not defined (yet) when &quot; .
                       __PACKAGE__ . &quot; needed it&quot;;
               }

               $self-&gt;{app} = $appender;
           }

       The reason for this post-processing step is that the relay appender might
       not be defined yet when the composite appender gets defined.  This can
       happen if Log4perl is initialized with a configuration file (which is the
       most common way to initialize Log4perl), because appenders spring into
       existance in unpredictable order.

       For example, if you define a Synchronized appender like

           log4perl.appender.Syncer            = Log::Log4perl::Appender::Synchronized
           log4perl.appender.Syncer.appender   = Logfile
&#12;       then Log4perl will set the appender&apos;s &quot;appender&quot; attribute to the name of
       the appender to finally relay messages to. After the Log4perl
       configuration file has been processed, Log4perl will remember to call the
       composite appender&apos;s post_init() method, which will grab the relay
       appender instance referred to by the name (Logfile) and set it in its
       &quot;app&quot; attribute. This is exactly what the code snippet above does.

       But if you initialize Log4perl by its API, you need to remember to
       perform these steps. Here&apos;s the lineup:

           use Log::Log4perl qw(get_logger :levels);

           my $fileApp = Log::Log4perl::Appender-&gt;new(
                       &apos;Log::Log4perl::Appender::File&apos;,
                       name     =&gt; &apos;MyFileApp&apos;,
                       filename =&gt; &apos;mylog&apos;,
                       mode     =&gt; &apos;append&apos;,
                       );
           $fileApp-&gt;layout(
                       Log::Log4perl::Layout::PatternLayout::Multiline-&gt;new(
                               &apos;%d{yyyy-MM-dd HH:mm:ss} %p [%c] #%P&gt; %m%n&apos;)
                       );
             # Make the appender known to the system (without assigning it to
             # any logger
           Log::Log4perl-&gt;add_appender( $fileApp );

           my $syncApp = Log::Log4perl::Appender-&gt;new(
                       &apos;Log::Log4perl::Appender::Synchronized&apos;,
                       name       =&gt; &apos;MySyncApp&apos;,
                       appender   =&gt; &apos;MyFileApp&apos;,
                       key        =&gt; &apos;nem&apos;,
                       );
           $syncApp-&gt;post_init();
           $syncApp-&gt;composite(1);

             # The Synchronized appender is now ready, assign it to a logger
             # and start logging.
           get_logger(&quot;&quot;)-&gt;add_appender($syncApp);

           get_logger(&quot;&quot;)-&gt;level($DEBUG);
           get_logger(&quot;wonk&quot;)-&gt;debug(&quot;waah!&quot;);

       The composite appender&apos;s log() function will typically cache incoming
       messages until a certain trigger condition is met and then forward a bulk
       of messages to the relay appender.

       Caching messages is surprisingly tricky, because you want them to look
       like they came from the code location they were originally issued from
       and not from the location that triggers the flush. Luckily, Log4perl
       offers a cache mechanism for messages, all you need to do is call the
       base class&apos; log() function with an additional reference to a scalar, and
       then save its content to your composite appender&apos;s message buffer
       afterwards:

           ###########################################
           sub log {
           ###########################################
               my($self, %params) = @_;

               # ... some logic to decide whether to cache or flush

                   # Adjust the caller stack
               local $Log::Log4perl::caller_depth =
                     $Log::Log4perl::caller_depth + 2;

                   # We need to cache.
                   # Ask the appender to save a cached message in $cache
               $self-&gt;{relay_app}-&gt;SUPER::log(\%params,
                                    $params{log4p_category},
                                    $params{log4p_level}, \my $cache);

                   # Save it in the appender&apos;s message buffer
               push @{ $self-&gt;{buffer} }, $cache;
           }

       Note that before calling the log() method of the relay appender&apos;s base
       class (and thus introducing two additional levels on the call stack), we
       need to adjust the call stack to allow Log4perl to render cspecs like the
       %M or %L correctly.  The cache will then contain a correctly rendered
       message, according to the layout of the target appender.

       Later, when the time comes to flush the cached messages, a call to the
       relay appender&apos;s base class&apos; log_cached() method with the cached message
       as an argument will forward the correctly rendered message:

           ###########################################
           sub log {
           ###########################################
               my($self, %params) = @_;

               # ... some logic to decide whether to cache or flush

                   # Flush pending messages if we have any
               for my $cache (@{$self-&gt;{buffer}}) {
                   $self-&gt;{relay_app}-&gt;SUPER::log_cached($cache);
               }
           }

SEE ALSO
       Log::Dispatch

COPYRIGHT AND LICENSE
       Copyright 2002-2009 by Mike Schilli &lt;m@perlmeister.com&gt; and Kevin Goess
       &lt;cpan@goess.org&gt;.

       This library is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.



perl v5.10.1                       2010-07-21                      Appender(3pm)

</pre></body></html>
