<html>
<head><meta charset=utf-8/>
<title>Log::Log4perl::Appender::DBI - implements appending to a DB</title></head>
<body><pre>

Appender::DBI(3pm)     User Contributed Perl Documentation    Appender::DBI(3pm)



NAME
       Log::Log4perl::Appender::DBI - implements appending to a DB

SYNOPSIS
           my $config = q{
            log4j.category = WARN, DBAppndr
            log4j.appender.DBAppndr             = Log::Log4perl::Appender::DBI
            log4j.appender.DBAppndr.datasource  = DBI:CSV:f_dir=t/tmp
            log4j.appender.DBAppndr.username    = bobjones
            log4j.appender.DBAppndr.password    = 12345
            log4j.appender.DBAppndr.sql         = \
               insert into log4perltest           \
               (loglevel, custid, category, message, ipaddr) \
               values (?,?,?,?,?)
            log4j.appender.DBAppndr.params.1 = %p
                                          #2 is custid from the log() call
            log4j.appender.DBAppndr.params.3 = %c
                                          #4 is the message from log()
                                          #5 is ipaddr from log()


            log4j.appender.DBAppndr.usePreparedStmt = 1
             #--or--
            log4j.appender.DBAppndr.bufferSize = 2

            #just pass through the array of message items in the log statement
            log4j.appender.DBAppndr.layout    = Log::Log4perl::Layout::NoopLayout
            log4j.appender.DBAppndr.warp_message = 0
           };

           $logger-&gt;warn( $custid, &apos;big problem!!&apos;, $ip_addr );

CAVEAT
       This is a very young module and there are a lot of variations in setups
       with different databases and connection methods, so make sure you test
       thoroughly!  Any feedback is welcome!

DESCRIPTION
       This is a specialized Log::Dispatch object customized to work with
       log4perl and its abilities, originally based on Log::Dispatch::DBI by
       Tatsuhiko Miyagawa but with heavy modifications.

       It is an attempted compromise between what Log::Dispatch::DBI was doing
       and what log4j&apos;s JDBCAppender does.  Note the log4j docs say the
       JDBCAppender &quot;is very likely to be completely replaced in the future.&quot;

       The simplest usage is this:

           log4j.category = WARN, DBAppndr
           log4j.appender.DBAppndr            = Log::Log4perl::Appender::DBI
           log4j.appender.DBAppndr.datasource = DBI:CSV:f_dir=t/tmp
           log4j.appender.DBAppndr.username   = bobjones
           log4j.appender.DBAppndr.password   = 12345
           log4j.appender.DBAppndr.sql        = \
              INSERT INTO logtbl                \
                 (loglevel, message)            \
                 VALUES (&apos;%c&apos;,&apos;%m&apos;)

           log4j.appender.DBAppndr.layout    = Log::Log4perl::Layout::PatternLayout


           $logger-&gt;fatal(&apos;fatal message&apos;);
           $logger-&gt;warn(&apos;warning message&apos;);

           ===============================
           |FATAL|fatal message          |
           |WARN |warning message        |
           ===============================

       But the downsides to that usage are:

       &#183;   You&apos;d better be darn sure there are not quotes in your log message,
           or your insert could have unforseen consequences!  This is a very
           insecure way to handle database inserts, using place holders and bind
           values is much better, keep reading. (Note that the log4j docs warn
           &quot;Be careful of quotes in your messages!&quot;) *.

       &#183;   It&apos;s not terribly high-performance, a statement is created and
           executed for each log call.

       &#183;   The only run-time parameter you get is the %m message, in reality you
           probably want to log specific data in specific table columns.

       So let&apos;s try using placeholders, and tell the logger to create a prepared
       statement handle at the beginning and just reuse it (just like
       Log::Dispatch::DBI does)

           log4j.appender.DBAppndr.sql = \
              INSERT INTO logtbl \
                 (custid, loglevel, message) \
                 VALUES (?,?,?)

           #---------------------------------------------------
           #now the bind values:
                                         #1 is the custid
           log4j.appender.DBAppndr.params.2 = %p
                                         #3 is the message
           #---------------------------------------------------

           log4j.appender.DBAppndr.layout    = Log::Log4perl::Layout::NoopLayout
           log4j.appender.DBAppndr.warp_message = 0

           log4j.appender.DBAppndr.usePreparedStmt = 1


           $logger-&gt;warn( 1234, &apos;warning message&apos; );

       Now see how we&apos;re using the &apos;?&apos; placeholders in our statement?  This
       means we don&apos;t have to worry about messages that look like

           invalid input: 1234&apos;;drop table custid;

       fubaring our database!

       Normally a list of things in the logging statement gets concatenated into
       a single string, but setting &quot;warp_message&quot; to 0 and using the NoopLayout
       means that in

           $logger-&gt;warn( 1234, &apos;warning message&apos;, &apos;bgates&apos; );

       the individual list values will still be available for the DBI appender
       later on.  (If &quot;warp_message&quot; is not set to 0, the default behavior is to
       join the list elements into a single string.   If PatternLayout or
       SimpleLayout are used, their attempt to &quot;render()&quot; your layout will
       result in something like &quot;ARRAY(0x841d8dc)&quot; in your logs.  More
       information on &quot;warp_message&quot; is in Log::Log4perl::Appender.)

       In your insert SQL you can mix up &apos;?&apos; placeholders with conversion
       specifiers (%c, %p, etc) as you see fit--the logger will match the
       question marks to params you&apos;ve defined in the config file and populate
       the rest with values from your list.  If there are more &apos;?&apos; placeholders
       than there are values in your message, it will use undef for the rest.
       For instance,

               log4j.appender.DBAppndr.sql =                 \
                  insert into log4perltest                   \
                  (loglevel, message, datestr, subpoena_id)\
                  values (?,?,?,?)
               log4j.appender.DBAppndr.params.1 = %p
               log4j.appender.DBAppndr.params.3 = %d

               log4j.appender.DBAppndr.warp_message=0


               $logger-&gt;info(&apos;arrest him!&apos;, $subpoena_id);

       results in the first &apos;?&apos; placholder being bound to %p, the second to
       &quot;arrest him!&quot;, the third to the date from &quot;%d&quot;, and the fourth to your
       $subpoenaid.  If you forget the $subpoena_id and just log

               $logger-&gt;info(&apos;arrest him!&apos;);

       then you just get undef in the fourth column.

       If the logger statement is also being handled by other non-DBI appenders,
       they will just join the list into a string, joined with
       $Log::Log4perl::JOIN_MSG_ARRAY_CHAR (default is an empty string).

       And see the &quot;usePreparedStmt&quot;?  That creates a statement handle when the
       logger object is created and just reuses it.  That, however, may be
       problematic for long-running processes like webservers, in which case you
       can use this parameter instead

           log4j.appender.DBAppndr.bufferSize=2

       This copies log4j&apos;s JDBCAppender&apos;s behavior, it saves up that many log
       statements and writes them all out at once.  If your INSERT statement
       uses only ? placeholders and no %x conversion specifiers it should be
       quite efficient because the logger can re-use the same statement handle
       for the inserts.

       If the program ends while the buffer is only partly full, the DESTROY
       block should flush the remaining statements, if the DESTROY block runs of
       course.

       * As I was writing this, Danko Mannhaupt was coming out with his improved
       log4j JDBCAppender (http://www.mannhaupt.com/danko/projects/) which
       overcomes many of the drawbacks of the original JDBCAppender.

DESCRIPTION 2
       Or another way to say the same thing:

       The idea is that if you&apos;re logging to a database table, you probably want
       specific parts of your log information in certain columns.  To this end,
       you pass an list to the log statement, like

           $logger-&gt;warn(&apos;big problem!!&apos;,$userid,$subpoena_nr,$ip_addr);

       and the array members drop into the positions defined by the placeholders
       in your SQL statement. You can also define information in the config file
       like

           log4j.appender.DBAppndr.params.2 = %p
&#12;       in which case those numbered placeholders will be filled in with the
       specified values, and the rest of the placeholders will be filled in with
       the values from your log statement&apos;s array.

MISC PARAMETERS
       usePreparedStmt
           See above.

       warp_message
           see Log::Log4perl::Appender

       max_col_size
           If you&apos;re used to just throwing debugging messages like huge
           stacktraces into your logger, some databases (Sybase&apos;s DBD!!) may
           suprise you by choking on data size limitations.  Normally, the data
           would just be truncated to fit in the column, but Sybases&apos;s DBD it
           turns out maxes out at 255 characters.  Use this parameter in such a
           situation to truncate long messages before they get to the INSERT
           statement.

CHANGING DBH CONNECTIONS (POOLING)
       If you want to get your dbh from some place in particular, like maybe a
       pool, subclass and override _init() and/or create_statement(), for
       instance

           sub _init {
               ; #no-op, no pooling at this level
           }
           sub create_statement {
               my ($self, $stmt) = @_;

               $stmt || croak &quot;Log4perl: sql not set in &quot;.__PACKAGE__;

               return My::Connections-&gt;getConnection-&gt;prepare($stmt)
                   || croak &quot;Log4perl: DBI-&gt;prepare failed $DBI::errstr\n$stmt&quot;;
           }

LIFE OF CONNECTIONS
       If you&apos;re using &quot;log4j.appender.DBAppndr.usePreparedStmt&quot; this module
       creates an sth when it starts and keeps it for the life of the program.
       For long-running processes (e.g. mod_perl), connections might go stale,
       but if &quot;Log::Log4perl::Appender::DBI&quot; tries to write a message and
       figures out that the DB connection is no longer working (using DBI&apos;s ping
       method), it will reconnect.

       The reconnection process can be controlled by two parameters,
       &quot;reconnect_attempts&quot; and &quot;reconnect_sleep&quot;. &quot;reconnect_attempts&quot;
       specifies the number of reconnections attempts the DBI appender performs
       until it gives up and dies. &quot;reconnect_sleep&quot; is the time between
       reconnection attempts, measured in seconds.  &quot;reconnect_attempts&quot;
       defaults to 1,  &quot;reconnect_sleep&quot; to 0.

       Alternatively, use &quot;Apache::DBI&quot; or &quot;Apache::DBI::Cache&quot; and read
       CHANGING DB CONNECTIONS above.

       Note that &quot;Log::Log4perl::Appender::DBI&quot; holds one connection open for
       every appender, which might be too many.

SEE ALSO
       Log::Dispatch::DBI

       Log::Log4perl::JavaMap::JDBCAppender

COPYRIGHT AND LICENSE
       Copyright 2002-2009 by Mike Schilli &lt;m@perlmeister.com&gt; and Kevin Goess
       &lt;cpan@goess.org&gt;.

       This library is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.



perl v5.10.1                       2010-07-21                 Appender::DBI(3pm)

</pre></body></html>
