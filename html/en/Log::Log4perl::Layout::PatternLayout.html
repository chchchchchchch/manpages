<html>
<head><meta charset=utf-8/>
<title>Log::Log4perl::Layout::PatternLayout - Pattern Layout</title></head>
<body><pre>

Layout::PatternLayout(3User Contributed Perl DocumentaLayout::PatternLayout(3pm)



NAME
       Log::Log4perl::Layout::PatternLayout - Pattern Layout

SYNOPSIS
         use Log::Log4perl::Layout::PatternLayout;

         my $layout = Log::Log4perl::Layout::PatternLayout-&gt;new(
                                                          &quot;%d (%F:%L)&gt; %m&quot;);

DESCRIPTION
       Creates a pattern layout according to
       http://jakarta.apache.org/log4j/docs/api/org/apache/log4j/PatternLayout.html
       and a couple of Log::Log4perl-specific extensions.

       The &quot;new()&quot; method creates a new PatternLayout, specifying its log
       format. The format string can contain a number of placeholders which will
       be replaced by the logging engine when it&apos;s time to log the message:

           %c Category of the logging event.
           %C Fully qualified package (or class) name of the caller
           %d Current date in yyyy/MM/dd hh:mm:ss format
           %F File where the logging event occurred
           %H Hostname (if Sys::Hostname is available)
           %l Fully qualified name of the calling method followed by the
              callers source the file name and line number between
              parentheses.
           %L Line number within the file where the log statement was issued
           %m The message to be logged
           %m{chomp} The message to be logged, stripped off a trailing newline
           %M Method or function where the logging request was issued
           %n Newline (OS-independent)
           %p Priority of the logging event (%p{1} shows the first letter)
           %P pid of the current process
           %r Number of milliseconds elapsed from program start to logging
              event
           %R Number of milliseconds elapsed from last logging event to
              current logging event
           %T A stack trace of functions called
           %x The topmost NDC (see below)
           %X{key} The entry &apos;key&apos; of the MDC (see below)
           %% A literal percent (%) sign

       NDC and MDC are explained in &quot;Nested Diagnostic Context (NDC)&quot; in
       Log::Log4perl and &quot;Mapped Diagnostic Context (MDC)&quot; in Log::Log4perl.

       The granularity of time values is milliseconds if Time::HiRes is
       available.  If not, only full seconds are used.

       Every once in a while, someone uses the &quot;%m%n&quot; pattern and additionally
       provides an extra newline in the log message (e.g.  &quot;-&gt;log(&quot;message\n&quot;)&quot;.
       To avoid printing an extra newline in this case, the PatternLayout will
       chomp the message, printing only one newline. This option can be
       controlled by PatternLayout&apos;s &quot;message_chomp_before_newline&quot; option. See
       &quot;Advanced options&quot; for details.

   Quantify placeholders
       All placeholders can be extended with formatting instructions, just like
       in printf:

           %20c   Reserve 20 chars for the category, right-justify and fill
                  with blanks if it is shorter
           %-20c  Same as %20c, but left-justify and fill the right side
                  with blanks
           %09r   Zero-pad the number of milliseconds to 9 digits
           %.8c   Specify the maximum field with and have the formatter
                  cut off the rest of the value
&#12;   Fine-tuning with curlies
       Some placeholders have special functions defined if you add curlies with
       content after them:

           %c{1}  Just show the right-most category compontent, useful in large
                  class hierarchies (Foo::Baz::Bar -&gt; Bar)
           %c{2}  Just show the two right most category components
                  (Foo::Baz::Bar -&gt; Baz::Bar)

           %F     Display source file including full path
           %F{1}  Just display filename
           %F{2}  Display filename and last path component (dir/test.log)
           %F{3}  Display filename and last two path components (d1/d2/test.log)

           %M     Display fully qualified method/function name
           %M{1}  Just display method name (foo)
           %M{2}  Display method name and last path component (main::foo)

       In this way, you&apos;re able to shrink the displayed category or limit
       file/path components to save space in your logs.

   Fine-tune the date
       If you&apos;re not happy with the default %d format for the date which looks
       like

           yyyy/MM/DD HH:mm:ss

       (which is slightly different from Log4j which uses &quot;yyyy-MM-dd
       HH:mm:ss,SSS&quot;) you&apos;re free to fine-tune it in order to display only
       certain characteristics of a date, according to the SimpleDateFormat in
       the Java World
       (http://java.sun.com/j2se/1.3/docs/api/java/text/SimpleDateFormat.html):

           %d{HH:mm}     &quot;23:45&quot; -- Just display hours and minutes
           %d{yy, EEEE}  &quot;02, Monday&quot; -- Just display two-digit year
                                         and spelled-out weekday
       Here&apos;s the symbols and their meaning, according to the SimpleDateFormat
       specification:

           Symbol   Meaning                 Presentation     Example
           ------   -------                 ------------     -------
           G        era designator          (Text)           AD
           y        year                    (Number)         1996
           M        month in year           (Text &amp; Number)  July &amp; 07
           d        day in month            (Number)         10
           h        hour in am/pm (1-12)    (Number)         12
           H        hour in day (0-23)      (Number)         0
           m        minute in hour          (Number)         30
           s        second in minute        (Number)         55
           E        day in week             (Text)           Tuesday
           D        day in year             (Number)         189
           a        am/pm marker            (Text)           PM

           (Text): 4 or more pattern letters--use full form, &lt; 4--use short or
                   abbreviated form if one exists.

           (Number): the minimum number of digits. Shorter numbers are
                     zero-padded to this amount. Year is handled
                     specially; that is, if the count of &apos;y&apos; is 2, the
                     Year will be truncated to 2 digits.

           (Text &amp; Number): 3 or over, use text, otherwise use number.

       There&apos;s also a bunch of pre-defined formats:

           %d{ABSOLUTE}   &quot;HH:mm:ss,SSS&quot;
           %d{DATE}       &quot;dd MMM yyyy HH:mm:ss,SSS&quot;
           %d{ISO8601}    &quot;yyyy-MM-dd HH:mm:ss,SSS&quot;

   Custom cspecs
       First of all, &quot;cspecs&quot; is short for &quot;conversion specifiers&quot;, which is the
       log4j and the printf(3) term for what Mike is calling &quot;placeholders.&quot;  I
       suggested &quot;cspecs&quot; for this part of the api before I saw that Mike was
       using &quot;placeholders&quot; consistently in the log4perl documentation.  Ah, the
       joys of collaboration ;=) --kg

       If the existing corpus of placeholders/cspecs isn&apos;t good enough for you,
       you can easily roll your own:

           #&apos;U&apos; a global user-defined cspec
           log4j.PatternLayout.cspec.U = sub { return &quot;UID: $&lt; &quot;}

           #&apos;K&apos; cspec local to appndr1                 (pid in hex)
           log4j.appender.appndr1.layout.cspec.K = sub { return sprintf &quot;%1x&quot;, $$}

           #and now you can use them
           log4j.appender.appndr1.layout.ConversionPattern = %K %U %m%n

       The benefit of this approach is that you can define and use the cspecs
       right next to each other in the config file.

       If you&apos;re an API kind of person, there&apos;s also this call:

           Log::Log4perl::Layout::PatternLayout::
                           add_global_cspec(&apos;Z&apos;, sub {&apos;zzzzzzzz&apos;}); #snooze?

       When the log message is being put together, your anonymous sub will be
       called with these arguments:

           ($layout, $message, $category, $priority, $caller_level);

           layout: the PatternLayout object that called it
           message: the logging message (%m)
           category: e.g. groceries.beverages.adult.beer.schlitz
           priority: e.g. DEBUG|WARN|INFO|ERROR|FATAL
           caller_level: how many levels back up the call stack you have
               to go to find the caller

       Please note that the subroutines you&apos;re defining in this way are going to
       be run in the &quot;main&quot; namespace, so be sure to fully qualify functions and
       variables if they&apos;re located in different packages. Also make sure these
       subroutines aren&apos;t using Log4perl, otherwise Log4perl will enter an
       infinite recursion.

       With Log4perl 1.20 and better, cspecs can be written with parameters in
       curly braces. Writing something like

           log4perl.appender.Screen.layout.ConversionPattern = %U{user} %U{id} %m%n

       will cause the cspec function defined for %U to be called twice, once
       with the parameter &apos;user&apos; and then again with the parameter &apos;id&apos;, and the
       placeholders in the cspec string will be replaced with the respective
       return values.

       The parameter value is available in the &apos;curlies&apos; entry of the first
       parameter passed to the subroutine (the layout object reference).  So, if
       you wanted to map %U{xxx} to entries in the POE session hash, you&apos;d write
       something like:

          log4perl.PatternLayout.cspec.U = sub { \
            POE::Kernel-&gt;get_active_session-&gt;get_heap()-&gt;{ $_[0]-&gt;{curlies} } }

       SECURITY NOTE

       This feature means arbitrary perl code can be embedded in the config
       file.  In the rare case where the people who have access to your config
       file are different from the people who write your code and shouldn&apos;t have
       execute rights, you might want to set

           $Log::Log4perl::Config-&gt;allow_code(0);

       before you call init().  Alternatively you can supply a restricted set of
       Perl opcodes that can be embedded in the config file as described in
       &quot;Restricting what Opcodes can be in a Perl Hook&quot; in Log::Log4perl.

   Advanced Options
       The constructor of the &quot;Log::Log4perl::Layout::PatternLayout&quot; class takes
       an optional hash reference as a first argument to specify additional
       options in order to (ab)use it in creative ways:

         my $layout = Log::Log4perl::Layout::PatternLayout-&gt;new(
           { time_function       =&gt; \&amp;my_time_func,
           },
           &quot;%d (%F:%L)&gt; %m&quot;);

       Here&apos;s a list of parameters:

       time_function
           Takes a reference to a function returning the time for the time/date
           fields, either in seconds since the epoch or as an array, carrying
           seconds and microseconds, just like &quot;Time::HiRes::gettimeofday&quot; does.

       message_chomp_before_newline
           If a layout contains the pattern &quot;%m%n&quot; and the message ends with a
           newline, PatternLayout will chomp the message, to prevent printing
           two newlines.  If this is not desired, and you want two newlines in
           this case, the feature can be turned off by setting the
           &quot;message_chomp_before_newline&quot; option to a false value:

             my $layout = Log::Log4perl::Layout::PatternLayout-&gt;new(
                 { message_chomp_before_newline =&gt; 0
                 },
                 &quot;%d (%F:%L)&gt; %m%n&quot;);

           In a Log4perl configuration file, the feature can be turned off like
           this:

               log4perl.appender.App.layout   = PatternLayout
               log4perl.appender.App.layout.ConversionPattern = %d %m%n
                 # Yes, I want two newlines
               log4perl.appender.App.layout.message_chomp_before_newline = 0

   Getting rid of newlines
       If your code contains logging statements like

             # WRONG, don&apos;t do that!
           $logger-&gt;debug(&quot;Some message\n&quot;);

       then it&apos;s usually best to strip the newlines from these calls. As
       explained in &quot;Logging newlines&quot; in Log::Log4perl, logging statements
       should never contain newlines, but rely on appender layouts to add
       necessary newlines instead.

       If changing the code is not an option, use the special PatternLayout
       placeholder %m{chomp} to refer to the message excluding a trailing
       newline:

           log4perl.appender.App.layout.ConversionPattern = %d %m{chomp}%n

       This will add a single newline to every message, regardless if it
       complies with the Log4perl newline guidelines or not (thanks to Tim Bunce
       for this idea).

COPYRIGHT AND LICENSE
       Copyright 2002-2009 by Mike Schilli &lt;m@perlmeister.com&gt; and Kevin Goess
       &lt;cpan@goess.org&gt;.

       This library is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.



perl v5.10.1                       2010-07-21         Layout::PatternLayout(3pm)

</pre></body></html>
