<html>
<head><meta charset=utf-8/>
<title>Net::DNS - Perl interface to the DNS resolver</title></head>
<body><pre>

Net::DNS(3pm)          User Contributed Perl Documentation         Net::DNS(3pm)



NAME
       Net::DNS - Perl interface to the DNS resolver

SYNOPSIS
       &quot;use Net::DNS;&quot;

DESCRIPTION
       Net::DNS is a collection of Perl modules that act as a Domain Name System
       (DNS) resolver.  It allows the programmer to perform DNS queries that are
       beyond the capabilities of &quot;gethostbyname&quot; and &quot;gethostbyaddr&quot;.

       The programmer should be somewhat familiar with the format of a DNS
       packet and its various sections.  See RFC 1035 or DNS and BIND (Albitz &amp;
       Liu) for details.

   Resolver Objects
       A resolver object is an instance of the Net::DNS::Resolver class. A
       program can have multiple resolver objects, each maintaining its own
       state information such as the nameservers to be queried, whether
       recursion is desired, etc.

   Packet Objects
       Net::DNS::Resolver queries return Net::DNS::Packet objects.  Packet
       objects have five sections:

       &#183;  The header section, a Net::DNS::Header object.

       &#183;  The question section, a list of Net::DNS::Question objects.

       &#183;  The answer section, a list of Net::DNS::RR objects.

       &#183;  The authority section, a list of Net::DNS::RR objects.

       &#183;  The additional section, a list of Net::DNS::RR objects.

   Update Objects
       The Net::DNS::Update package is a subclass of Net::DNS::Packet for
       creating packet objects to be used in dynamic updates.

   Header Objects
       Net::DNS::Header objects represent the header section of a DNS packet.

   Question Objects
       Net::DNS::Question objects represent the question section of a DNS
       packet.

   RR Objects
       Net::DNS::RR is the base class for DNS resource record (RR) objects in
       the answer, authority, and additional sections of a DNS packet.

       Don&apos;t assume that RR objects will be of the type you requested -- always
       check an RR object&apos;s type before calling any of its methods.

METHODS
       See the manual pages listed above for other class-specific methods.

   version
           print Net::DNS-&gt;version, &quot;\n&quot;;

       Returns the version of Net::DNS.

   mx
           # Use a default resolver -- can&apos;t get an error string this way.
           use Net::DNS;
           my @mx = mx(&quot;example.com&quot;);
&#12;           # Use your own resolver object.
           use Net::DNS;
           my $res = Net::DNS::Resolver-&gt;new;
           my  @mx = mx($res, &quot;example.com&quot;);

       Returns a list of Net::DNS::RR::MX objects representing the MX records
       for the specified name; the list will be sorted by preference. Returns an
       empty list if the query failed or no MX records were found.

       This method does not look up A records -- it only performs MX queries.

       See &quot;EXAMPLES&quot; for a more complete example.

   yxrrset
       Use this method to add an &quot;RRset exists&quot; prerequisite to a dynamic update
       packet.  There are two forms, value-independent and value-dependent:

           # RRset exists (value-independent)
           $update-&gt;push(pre =&gt; yxrrset(&quot;host.example.com A&quot;));

       Meaning:  At least one RR with the specified name and type must exist.

           # RRset exists (value-dependent)
           $packet-&gt;push(pre =&gt; yxrrset(&quot;host.example.com A 10.1.2.3&quot;));

       Meaning:  At least one RR with the specified name and type must exist and
       must have matching data.

       Returns a &quot;Net::DNS::RR&quot; object or &quot;undef&quot; if the object couldn&apos;t be
       created.

   nxrrset
       Use this method to add an &quot;RRset does not exist&quot; prerequisite to a
       dynamic update packet.

           $packet-&gt;push(pre =&gt; nxrrset(&quot;host.example.com A&quot;));

       Meaning:  No RRs with the specified name and type can exist.

       Returns a &quot;Net::DNS::RR&quot; object or &quot;undef&quot; if the object couldn&apos;t be
       created.

   yxdomain
       Use this method to add a &quot;name is in use&quot; prerequisite to a dynamic
       update packet.

           $packet-&gt;push(pre =&gt; yxdomain(&quot;host.example.com&quot;));

       Meaning:  At least one RR with the specified name must exist.

       Returns a &quot;Net::DNS::RR&quot; object or &quot;undef&quot; if the object couldn&apos;t be
       created.

   nxdomain
       Use this method to add a &quot;name is not in use&quot; prerequisite to a dynamic
       update packet.

           $packet-&gt;push(pre =&gt; nxdomain(&quot;host.example.com&quot;));

       Meaning:  No RR with the specified name can exist.

       Returns a &quot;Net::DNS::RR&quot; object or &quot;undef&quot; if the object couldn&apos;t be
       created.

   rr_add
       Use this method to add RRs to a zone.

           $packet-&gt;push(update =&gt; rr_add(&quot;host.example.com A 10.1.2.3&quot;));

       Meaning:  Add this RR to the zone.

       RR objects created by this method should be added to the &quot;update&quot; section
       of a dynamic update packet.  The TTL defaults to 86400 seconds (24 hours)
       if not specified.

       Returns a &quot;Net::DNS::RR&quot; object or &quot;undef&quot; if the object couldn&apos;t be
       created.

   rr_del
       Use this method to delete RRs from a zone.  There are three forms: delete
       an RRset, delete all RRsets, and delete an RR.

           # Delete an RRset.
           $packet-&gt;push(update =&gt; rr_del(&quot;host.example.com A&quot;));

       Meaning:  Delete all RRs having the specified name and type.

           # Delete all RRsets.
           $packet-&gt;push(update =&gt; rr_del(&quot;host.example.com&quot;));

       Meaning:  Delete all RRs having the specified name.

           # Delete an RR.
           $packet-&gt;push(update =&gt; rr_del(&quot;host.example.com A 10.1.2.3&quot;));

       Meaning:  Delete all RRs having the specified name, type, and data.

       RR objects created by this method should be added to the &quot;update&quot; section
       of a dynamic update packet.

       Returns a &quot;Net::DNS::RR&quot; object or &quot;undef&quot; if the object couldn&apos;t be
       created.

   Sorting of RR arrays
       As of version 0.55 there is functionality to help you sort RR arrays.
       &apos;rrsort()&apos; is the function that is available to do the sorting. In most
       cases rrsort will give you the answer that you want but you can specify
       your own sorting method by using the Net::DNS::RR::FOO-&gt;set_rrsort_func()
       class method. See Net::DNS::RR for details.

       rrsort()

          use Net::DNS qw(rrsort);

          my @prioritysorted=rrsort(&quot;SRV&quot;,&quot;priority&quot;,@rr_array);

       rrsort() selects all RRs from the input array that are of the type that
       are defined in the first argument. Those RRs are sorted based on the
       attribute that is specified as second argument.

       There are a number of RRs for which the sorting function is specifically
       defined for certain attributes.  If such sorting function is defined in
       the code (it can be set or overwritten using the set_rrsort_func() class
       method) that function is used.

       For instance:
          my @prioritysorted=rrsort(&quot;SRV&quot;,&quot;priority&quot;,@rr_array); returns the SRV
       records sorted from lowest to heighest priority and for equal priorities
       from heighes to lowes weight.

       If the function does not exist then a numerical sort on the attribute
       value is performed.
          my @portsorted=rrsort(&quot;SRV&quot;,&quot;port&quot;,@rr_array);

       If the attribute does not exist for a certain RR than the RRs are sorted
       on string comparrisson of the rdata.

       If the attribute is not defined than either the default_sort function
       will be defined or &quot;Canonical sorting&quot; (as defined by DNSSEC) will be
       used.

       rrsort() returns a sorted array with only elements of the specified RR
       type or undef.

       rrsort() returns undef when arguments are incorrect.

EXAMPLES
       The following examples show how to use the &quot;Net::DNS&quot; modules.  See the
       other manual pages and the demo scripts included with the source code for
       additional examples.

       See the &quot;Net::DNS::Update&quot; manual page for an example of performing
       dynamic updates.

   Look up a host&apos;s addresses.
         use Net::DNS;
         my $res   = Net::DNS::Resolver-&gt;new;
         my $query = $res-&gt;search(&quot;host.example.com&quot;);

         if ($query) {
             foreach my $rr ($query-&gt;answer) {
                 next unless $rr-&gt;type eq &quot;A&quot;;
                 print $rr-&gt;address, &quot;\n&quot;;
             }
         } else {
             warn &quot;query failed: &quot;, $res-&gt;errorstring, &quot;\n&quot;;
         }

   Find the nameservers for a domain.
         use Net::DNS;
         my $res   = Net::DNS::Resolver-&gt;new;
         my $query = $res-&gt;query(&quot;example.com&quot;, &quot;NS&quot;);

         if ($query) {
             foreach $rr (grep { $_-&gt;type eq &apos;NS&apos; } $query-&gt;answer) {
                 print $rr-&gt;nsdname, &quot;\n&quot;;
             }
         }
         else {
             warn &quot;query failed: &quot;, $res-&gt;errorstring, &quot;\n&quot;;
         }

   Find the MX records for a domain.
         use Net::DNS;
         my $name = &quot;example.com&quot;;
         my $res  = Net::DNS::Resolver-&gt;new;
         my @mx   = mx($res, $name);

         if (@mx) {
             foreach $rr (@mx) {
                 print $rr-&gt;preference, &quot; &quot;, $rr-&gt;exchange, &quot;\n&quot;;
             }
         } else {
             warn &quot;Can&apos;t find MX records for $name: &quot;, $res-&gt;errorstring, &quot;\n&quot;;
         }

   Print a domain&apos;s SOA record in zone file format.
         use Net::DNS;
         my $res   = Net::DNS::Resolver-&gt;new;
         my $query = $res-&gt;query(&quot;example.com&quot;, &quot;SOA&quot;);

         if ($query) {
             ($query-&gt;answer)[0]-&gt;print;
         } else {
             print &quot;query failed: &quot;, $res-&gt;errorstring, &quot;\n&quot;;
         }

   Perform a zone transfer and print all the records.
         use Net::DNS;
         my $res  = Net::DNS::Resolver-&gt;new;
         $res-&gt;nameservers(&quot;ns.example.com&quot;);
&#12;         my @zone = $res-&gt;axfr(&quot;example.com&quot;);

         foreach $rr (@zone) {
             $rr-&gt;print;
         }

   Perform a background query and do some other work while waiting for the
       answer.
         use Net::DNS;
         my $res    = Net::DNS::Resolver-&gt;new;
         my $socket = $res-&gt;bgsend(&quot;host.example.com&quot;);

         until ($res-&gt;bgisready($socket)) {
             # do some work here while waiting for the answer
             # ...and some more here
         }

         my $packet = $res-&gt;bgread($socket);
         $packet-&gt;print;

   Send a background query and use select to determine when the answer has
       arrived.
         use Net::DNS;
         use IO::Select;

         my $timeout = 5;
         my $res     = Net::DNS::Resolver-&gt;new;
         my $bgsock  = $res-&gt;bgsend(&quot;host.example.com&quot;);
         my $sel     = IO::Select-&gt;new($bgsock);

         # Add more sockets to $sel if desired.
         my @ready = $sel-&gt;can_read($timeout);
         if (@ready) {
             foreach my $sock (@ready) {
                 if ($sock == $bgsock) {
                     my $packet = $res-&gt;bgread($bgsock);
                     $packet-&gt;print;
                     $bgsock = undef;
                 }
                 # Check for the other sockets.
                 $sel-&gt;remove($sock);
                 $sock = undef;
             }
         } else {
             warn &quot;timed out after $timeout seconds\n&quot;;
         }

BUGS
       &quot;Net::DNS&quot; is slow.

       For other items to be fixed, please see the TODO file included with the
       source distribution.

COPYRIGHT
       Copyright (c) 1997-2002 Michael Fuhr.  Portions Copyright (c) 2002-2004
       Chris Reinhardt.  Portions Copyright (c) 2005 Olaf Kolkman (RIPE NCC)
       Portions Copyright (c) 2006 Olaf Kolkman (NLnet Labs)

       All rights reserved.  This program is free software; you may redistribute
       it and/or modify it under the same terms as Perl itself.

AUTHOR INFORMATION
       Net::DNS is currently maintained at NLnet Labs (www.nlnetlabs.nl) by:
               Olaf Kolkman      olaf@net-dns.org

       Between 2002 and 2004 Net::DNS was maintained by:
              Chris Reinhardt

       Net::DNS was created by:      Michael Fuhr      mike@fuhr.org

       For more information see:
           http://www.net-dns.org/

       Stay tuned and syncicate:
           http://www.net-dns.org/blog/

SEE ALSO
       perl(1), Net::DNS::Resolver, Net::DNS::Packet, Net::DNS::Update,
       Net::DNS::Header, Net::DNS::Question, Net::DNS::RR, RFC 1035, DNS and
       BIND by Paul Albitz &amp; Cricket Liu



perl v5.14.2                       2009-12-30                      Net::DNS(3pm)

</pre></body></html>
