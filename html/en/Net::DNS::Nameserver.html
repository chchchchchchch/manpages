<html>
<head><meta charset=utf-8/>
<title>Net::DNS::Nameserver - DNS server class</title></head>
<body><pre>

Net::DNS::Nameserver(3pUser Contributed Perl DocumentatNet::DNS::Nameserver(3pm)



NAME
       Net::DNS::Nameserver - DNS server class

SYNOPSIS
       &quot;use Net::DNS::Nameserver;&quot;

DESCRIPTION
       Instances of the &quot;Net::DNS::Nameserver&quot; class represent DNS server
       objects.  See &quot;EXAMPLE&quot; for an example.

METHODS
   new
        my $ns = Net::DNS::Nameserver-&gt;new(
               LocalAddr        =&gt; &quot;10.1.2.3&quot;,
               LocalPort        =&gt; &quot;5353&quot;,
               ReplyHandler =&gt; \&amp;reply_handler,
               Verbose          =&gt; 1
        );



        my $ns = Net::DNS::Nameserver-&gt;new(
               LocalAddr        =&gt; [&apos;::1&apos; , &apos;127.0.0.1&apos; ],
               LocalPort        =&gt; &quot;5353&quot;,
               ReplyHandler =&gt; \&amp;reply_handler,
               Verbose          =&gt; 1,
               Truncate         =&gt; 0,
        );

       Creates a nameserver object.  Attributes are:

         LocalAddr             IP address on which to listen.  Defaults to INADDR_ANY.
         LocalPort             Port on which to listen.        Defaults to 53.
         ReplyHandler          Reference to reply-handling
                               subroutine                      Required.
         NotifyHandler         Reference to reply-handling
                               subroutine for queries with
                               opdcode NS_NOTIFY (RFC1996)
         Verbose               Print info about received
                               queries.                        Defaults to 0 (off).
         Truncate              Truncates UDP packets that
                               are to big for the reply        Defaults to 1 (on)

       The LocalAddr attribute may alternatively be specified as a list of IP
       addresses to listen to.

       If IO::Socket::INET6 and Socket6 are available on the system you can also
       list IPv6 addresses and the default is &apos;0&apos; (listen on all interfaces on
       IPv6 and IPv4);

       The ReplyHandler subroutine is passed the query name, query class, query
       type and optionally an argument containing the peerhost, the incoming
       query, and the name of the incoming socket (sockethost). It must return
       the response code and references to the answer, authority, and additional
       sections of the response.  Common response codes are:

         NOERROR       No error
         FORMERR       Format error
         SERVFAIL      Server failure
         NXDOMAIN      Non-existent domain (name doesn&apos;t exist)
         NOTIMP        Not implemented
         REFUSED       Query refused
&#12;       For advanced usage it may also contain a headermaks containing an hashref
       with the settings for the &quot;aa&quot;, &quot;ra&quot;, and &quot;ad&quot; header bits. The argument
       is of the form &quot;{ ad =&gt; 1, aa =&gt; 0, ra =&gt; 1 }&quot;.

       See RFC 1035 and the IANA dns-parameters file for more information:

         ftp://ftp.rfc-editor.org/in-notes/rfc1035.txt
         http://www.isi.edu/in-notes/iana/assignments/dns-parameters

       The nameserver will listen for both UDP and TCP connections.  On Unix-
       like systems, the program will probably have to run as root to listen on
       the default port, 53.  A non-privileged user should be able to listen on
       ports 1024 and higher.

       Packet Truncation is new functionality for
       $Net::DNS::Nameserver::VERSION&gt;830 and uses the
       Net::DNS::Packet::truncate method with a size determinde by the
       advertised EDNS0 size in the query, or 512 if EDNS0 is not advertised in
       the query. Only UDP replies are truncated. If you want to do packet
       runcation yourself you should set Truncate to 0 and use the truncate
       method on the reply packet in the code you use for the ReplyHandler.

       Returns a Net::DNS::Nameserver object, or undef if the object couldn&apos;t be
       created.

       See &quot;EXAMPLE&quot; for an example.

   main_loop
               $ns-&gt;main_loop;

       Start accepting queries. Calling main_loop never returns.

   loop_once
               $ns-&gt;loop_once( [TIMEOUT_IN_SECONDS] );

       Start accepting queries, but returns. If called without a parameter, the
       call will not return until a request has been received (and replied to).
       If called with a number, that number specifies how many seconds (even
       fractional) to maximum wait before returning. If called with 0 it will
       return immediately unless there&apos;s something to do.

       Handling a request and replying obviously depends on the speed of
       ReplyHandler. Assuming ReplyHandler is super fast, loop_once should spend
       just a fraction of a second, if called with a timeout value of 0 seconds.
       One exception is when an AXFR has requested a huge amount of data that
       the OS is not ready to receive in full. In that case, it will keep
       running through a loop (while servicing new requests) until the reply has
       been sent.

       In case loop_once accepted a TCP connection it will immediatly check if
       there is data to be read from the socket. If not it will return and you
       will have to call loop_once() again to check if there is any data waiting
       on the socket to be processed. In most cases you will have to count on
       calling &quot;loop_once&quot; twice.

       A code fragment like:      $ns-&gt;loop_once(10);
               while( $ns-&gt;get_open_tcp() ){            $ns-&gt;loop_once(0);
            }

       Would wait for 10 seconds for the initial connection and would then
       process all TCP sockets until none is left.

   get_open_tcp
       In scalar context returns the number of TCP connections for which state
       is maintained. In array context it returns IO::Socket objects, these
       could be useful for troubleshooting but be careful using them.
&#12;EXAMPLE
       The following example will listen on port 5353 and respond to all queries
       for A records with the IP address 10.1.2.3.    All other queries will be
       answered with NXDOMAIN.    Authority and additional sections are left
       empty.  The $peerhost variable catches the IP address of the peer host,
       so that additional filtering on its basis may be applied.

        #!/usr/bin/perl

        use Net::DNS::Nameserver;
        use strict;
        use warnings;

        sub reply_handler {
                my ($qname, $qclass, $qtype, $peerhost,$query,$conn) = @_;
                my ($rcode, @ans, @auth, @add);

                print &quot;Received query from $peerhost to &quot;. $conn-&gt;{&quot;sockhost&quot;}. &quot;\n&quot;;
                $query-&gt;print;


                if ($qtype eq &quot;A&quot; &amp;&amp; $qname eq &quot;foo.example.com&quot; ) {
                        my ($ttl, $rdata) = (3600, &quot;10.1.2.3&quot;);
                        push @ans, Net::DNS::RR-&gt;new(&quot;$qname $ttl $qclass $qtype $rdata&quot;);
                        $rcode = &quot;NOERROR&quot;;
                }elsif( $qname eq &quot;foo.example.com&quot; ) {
                        $rcode = &quot;NOERROR&quot;;

                }else{
                         $rcode = &quot;NXDOMAIN&quot;;
                }


                # mark the answer as authoritive (by setting the &apos;aa&apos; flag
                return ($rcode, \@ans, \@auth, \@add, { aa =&gt; 1 });
        }

        my $ns = Net::DNS::Nameserver-&gt;new(
            LocalPort    =&gt; 5353,
            ReplyHandler =&gt; \&amp;reply_handler,
            Verbose      =&gt; 1,
        ) || die &quot;couldn&apos;t create nameserver object\n&quot;;

        $ns-&gt;main_loop;

BUGS
       Limitations in perl 5.8.6 makes it impossible to guarantee that replies
       to UDP queries from Net::DNS::Nameserver are sent from the IP-address
       they were received on. This is a problem for machines with multiple IP-
       addresses and causes violation of RFC2181 section 4.  Thus a UDP socket
       created listening to INADDR_ANY (all available IP-addresses) will reply
       not necessarily with the source address being the one to which the
       request was sent, but rather with the address that the operating system
       choses. This is also often called &quot;the closest address&quot;. This should
       really only be a problem on a server which has more than one IP-address
       (besides localhost - any experience with IPv6 complications here, would
       be nice). If this is a problem for you, a work-around would be to not
       listen to INADDR_ANY but to specify each address that you want this
       module to listen on. A separate set of sockets will then be created for
       each IP-address.

COPYRIGHT
       Copyright (c) 1997-2002 Michael Fuhr.

       Portions Copyright (c) 2002-2004 Chris Reinhardt.

       Portions Copyright (c) 2005-2009 O.M, Kolkman, RIPE NCC.

       Portions Copyright (c) 2005 Robert Martin-Legene.

       All rights reserved.  This program is free software; you may redistribute
       it and/or modify it under the same terms as Perl itself.

SEE ALSO
       perl(1), Net::DNS, Net::DNS::Resolver, Net::DNS::Packet,
       Net::DNS::Update, Net::DNS::Header, Net::DNS::Question, Net::DNS::RR, RFC
       1035



perl v5.14.2                       2011-11-15          Net::DNS::Nameserver(3pm)

</pre></body></html>
