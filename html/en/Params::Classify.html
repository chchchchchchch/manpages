<html>
<head><meta charset=utf-8/>
<title>Params::Classify - argument type classification</title></head>
<body><pre>

Params::Classify(3pm)  User Contributed Perl Documentation Params::Classify(3pm)



NAME
       Params::Classify - argument type classification

SYNOPSIS
               use Params::Classify qw(
                       scalar_class
                       is_undef check_undef
                       is_string check_string
                       is_number check_number
                       is_glob check_glob
                       is_regexp check_regexp
                       is_ref check_ref ref_type
                       is_blessed check_blessed blessed_class
                       is_strictly_blessed check_strictly_blessed
                       is_able check_able
               );

               $c = scalar_class($arg);

               if(is_undef($arg)) {
               check_undef($arg);

               if(is_string($arg)) {
               check_string($arg);
               if(is_number($arg)) {
               check_number($arg);

               if(is_glob($arg)) {
               check_glob($arg);
               if(is_regexp($arg)) {
               check_regexp($arg);

               if(is_ref($arg)) {
               check_ref($arg);
               $t = ref_type($arg);
               if(is_ref($arg, &quot;HASH&quot;)) {
               check_ref($arg, &quot;HASH&quot;);

               if(is_blessed($arg)) {
               check_blessed($arg);
               if(is_blessed($arg, &quot;IO::Handle&quot;)) {
               check_blessed($arg, &quot;IO::Handle&quot;);
               $c = blessed_class($arg);
               if(is_strictly_blessed($arg, &quot;IO::Pipe::End&quot;)) {
               check_strictly_blessed($arg, &quot;IO::Pipe::End&quot;);
               if(is_able($arg, [&quot;print&quot;, &quot;flush&quot;])) {
               check_able($arg, [&quot;print&quot;, &quot;flush&quot;]);

DESCRIPTION
       This module provides various type-testing functions.  These are intended
       for functions that, unlike most Perl code, care what type of data they
       are operating on.  For example, some functions wish to behave differently
       depending on the type of their arguments (like overloaded functions in
       C++).

       There are two flavours of function in this module.  Functions of the
       first flavour only provide type classification, to allow code to
       discriminate between argument types.  Functions of the second flavour
       package up the most common type of type discrimination: checking that an
       argument is of an expected type.  The functions come in matched pairs, of
       the two flavours, and so the type enforcement functions handle only the
       simplest requirements for arguments of the types handled by the
       classification functions.  Enforcement of more complex types may, of
       course, be built using the classification functions, or it may be more
       convenient to use a module designed for the more complex job, such as
       Params::Validate.

       This module is implemented in XS, with a pure Perl backup version for
       systems that can&apos;t handle XS.

TYPE CLASSIFICATION
       This module divides up scalar values into the following classes:

       &#183;   undef

       &#183;   string (defined ordinary scalar)

       &#183;   typeglob (yes, typeglobs fit into scalar variables)

       &#183;   regexp (first-class regular expression objects in Perl 5.11 onwards)

       &#183;   reference to unblessed object (further classified by physical data
           type of the referenced object)

       &#183;   reference to blessed object (further classified by class blessed
           into)

       These classes are mutually exclusive and should be exhaustive.  This
       classification has been chosen as the most useful when one wishes to
       discriminate between types of scalar.  Other classifications are
       possible.  (For example, the two reference classes are distinguished by a
       feature of the referenced object; Perl does not internally treat this as
       a feature of the reference.)

FUNCTIONS
       Each of these functions takes one scalar argument (ARG) to be tested,
       possibly with other arguments specifying details of the test.  Any scalar
       value is acceptable for the argument to be tested.  Each &quot;is_&quot; function
       returns a simple truth value result, which is true iff ARG is of the type
       being checked for.  Each &quot;check_&quot; function will return normally if the
       argument is of the type being checked for, or will &quot;die&quot; if it is not.

   Classification
       scalar_class(ARG)
           Determines which of the five classes described above ARG falls into.
           Returns &quot;UNDEF&quot;, &quot;STRING&quot;, &quot;GLOB&quot;, &quot;REGEXP&quot;, &quot;REF&quot;, or &quot;BLESSED&quot;
           accordingly.

   The Undefined Value
       is_undef(ARG)
       check_undef(ARG)
           Check whether ARG is &quot;undef&quot;.  &quot;is_undef(ARG)&quot; is precisely
           equivalent to &quot;!defined(ARG)&quot;, and is included for completeness.

   Strings
       is_string(ARG)
       check_string(ARG)
           Check whether ARG is defined and is an ordinary scalar value (not a
           reference, typeglob, or regexp).  This is what one usually thinks of
           as a string in Perl.  In fact, any scalar (including &quot;undef&quot; and
           references) can be coerced to a string, but if you&apos;re trying to
           classify a scalar then you don&apos;t want to do that.

       is_number(ARG)
       check_number(ARG)
           Check whether ARG is defined and an ordinary scalar (i.e., satisfies
           &quot;is_string&quot; above) and is an acceptable number to Perl.  This is what
           one usually thinks of as a number.

           Note that simple (&quot;is_string&quot;-satisfying) scalars may have
           independent numeric and string values, despite the usual pretence
           that they have only one value.  Such a scalar is deemed to be a
           number if either it already has a numeric value (e.g., was generated
           by a numeric literal or an arithmetic computation) or its string
           value has acceptable syntax for a number (so it can be converted).
           Where a scalar has separate numeric and string values (see &quot;dualvar&quot;
           in Scalar::Util), it is possible for it to have an acceptable numeric
           value while its string value does not have acceptable numeric syntax.
           Be careful to use such a value only in a numeric context, if you are
           using it as a number.  &quot;scalar_num_part&quot; in Scalar::Number extracts
           the numeric part of a scalar as an ordinary number.  (&quot;0+ARG&quot;
           suffices for that unless you need to preserve floating point signed
           zeroes.)

           A number may be either a native integer or a native floating point
           value, and there are several subtypes of floating point value.  For
           classification, and other handling of numbers in scalars, see
           Scalar::Number.  For details of the two numeric data types, see
           Data::Integer and Data::Float.

           This function differs from &quot;looks_like_number&quot; (see
           &quot;looks_like_number&quot; in Scalar::Util; also &quot;looks_like_number&quot; in
           perlapi for a lower-level description) in excluding &quot;undef&quot;,
           typeglobs, and references.  Why &quot;looks_like_number&quot; returns true for
           &quot;undef&quot; or typeglobs is anybody&apos;s guess.  References, if treated as
           numbers, evaluate to the address in memory that they reference; this
           is useful for comparing references for equality, but it is not
           otherwise useful to treat references as numbers.  Blessed references
           may have overloaded numeric operators, but if so then they don&apos;t
           necessarily behave like ordinary numbers.  &quot;looks_like_number&quot; is
           also confused by dualvars: it looks at the string portion of the
           scalar.

   Typeglobs
       is_glob(ARG)
       check_glob(ARG)
           Check whether ARG is a typeglob.

   Regexps
       is_regexp(ARG)
       check_regexp(ARG)
           Check whether ARG is a regexp object.

   References to Unblessed Objects
       is_ref(ARG)
       check_ref(ARG)
           Check whether ARG is a reference to an unblessed object.  If it is,
           then the referenced data type can be determined using &quot;ref_type&quot; (see
           below), which will return a string such as &quot;HASH&quot; or &quot;SCALAR&quot;.

       ref_type(ARG)
           Returns &quot;undef&quot; if ARG is not a reference to an unblessed object.
           Otherwise, determines what type of object is referenced.  Returns
           &quot;SCALAR&quot;, &quot;ARRAY&quot;, &quot;HASH&quot;, &quot;CODE&quot;, &quot;FORMAT&quot;, or &quot;IO&quot; accordingly.

           Note that, unlike &quot;ref&quot;, this does not distinguish between different
           types of referenced scalar.  A reference to a string and a reference
           to a reference will both return &quot;SCALAR&quot;.  Consequently, what
           &quot;ref_type&quot; returns for a particular reference will not change due to
           changes in the value of the referent, except for the referent being
           blessed.

       is_ref(ARG, TYPE)
       check_ref(ARG, TYPE)
           Check whether ARG is a reference to an unblessed object of type TYPE,
           as determined by &quot;ref_type&quot;.  TYPE must be a string.  Possible TYPEs
           are &quot;SCALAR&quot;, &quot;ARRAY&quot;, &quot;HASH&quot;, &quot;CODE&quot;, &quot;FORMAT&quot;, and &quot;IO&quot;.

   References to Blessed Objects
       is_blessed(ARG)
       check_blessed(ARG)
           Check whether ARG is a reference to a blessed object.  If it is, then
           the class into which the object was blessed can be determined using
           &quot;blessed_class&quot;.

       is_blessed(ARG, CLASS)
       check_blessed(ARG, CLASS)
           Check whether ARG is a reference to a blessed object that claims to
           be an instance of CLASS (via its &quot;isa&quot; method; see &quot;isa&quot; in perlobj).
           CLASS must be a string, naming a Perl class.

       blessed_class(ARG)
           Returns &quot;undef&quot; if ARG is not a reference to a blessed object.
           Otherwise, returns the class into which the object is blessed.

           &quot;ref&quot; (see &quot;ref&quot; in perlfunc) gives the same result on references to
           blessed objects, but different results on other types of value.
           &quot;blessed_class&quot; is actually identical to &quot;blessed&quot; in Scalar::Util.

       is_strictly_blessed(ARG)
       check_strictly_blessed(ARG)
           Check whether ARG is a reference to a blessed object, identically to
           &quot;is_blessed&quot;.  This exists only for symmetry; the useful form of
           &quot;is_strictly_blessed&quot; appears below.

       is_strictly_blessed(ARG, CLASS)
       check_strictly_blessed(ARG, CLASS)
           Check whether ARG is a reference to an object blessed into CLASS
           exactly.  CLASS must be a string, naming a Perl class.  Because this
           excludes subclasses, this is rarely what one wants, but there are
           some specialised occasions where it is useful.

       is_able(ARG)
       check_able(ARG)
           Check whether ARG is a reference to a blessed object, identically to
           &quot;is_blessed&quot;.  This exists only for symmetry; the useful form of
           &quot;is_able&quot; appears below.

       is_able(ARG, METHODS)
       check_able(ARG, METHODS)
           Check whether ARG is a reference to a blessed object that claims to
           implement the methods specified by METHODS (via its &quot;can&quot; method; see
           &quot;can&quot; in perlobj).  METHODS must be either a single method name or a
           reference to an array of method names.  Each method name is a string.
           This interface check is often more appropriate than a direct ancestry
           check (such as &quot;is_blessed&quot; performs).

BUGS
       Probably ought to handle something like Params::Validate&apos;s scalar type
       specification system, which makes much the same distinctions.

SEE ALSO
       Data::Float, Data::Integer, Params::Validate, Scalar::Number,
       Scalar::Util

AUTHOR
       Andrew Main (Zefram) &lt;zefram@fysh.org&gt;

COPYRIGHT
       Copyright (C) 2004, 2006, 2007, 2009, 2010 Andrew Main (Zefram)
       &lt;zefram@fysh.org&gt;

       Copyright (C) 2009, 2010 PhotoBox Ltd
&#12;LICENSE
       This module is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.



perl v5.14.2                       2011-11-17              Params::Classify(3pm)

</pre></body></html>
