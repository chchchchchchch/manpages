<html>
<head><meta charset=utf-8/>
<title>Params::Util - Simple, compact and correct param-checking functions</title></head>
<body><pre>

Params::Util(3pm)      User Contributed Perl Documentation     Params::Util(3pm)



NAME
       Params::Util - Simple, compact and correct param-checking functions

SYNOPSIS
         # Import some functions
         use Params::Util qw{_SCALAR _HASH _INSTANCE};

         # If you are lazy, or need a lot of them...
         use Params::Util &apos;:ALL&apos;;

         sub foo {
             my $object  = _INSTANCE(shift, &apos;Foo&apos;) or return undef;
             my $image   = _SCALAR(shift)          or return undef;
             my $options = _HASH(shift)            or return undef;
             # etc...
         }

DESCRIPTION
       &quot;Params::Util&quot; provides a basic set of importable functions that makes
       checking parameters a hell of a lot easier

       While they can be (and are) used in other contexts, the main point behind
       this module is that the functions both Do What You Mean, and Do The Right
       Thing, so they are most useful when you are getting params passed into
       your code from someone and/or somewhere else and you can&apos;t really trust
       the quality.

       Thus, &quot;Params::Util&quot; is of most use at the edges of your API, where
       params and data are coming in from outside your code.

       The functions provided by &quot;Params::Util&quot; check in the most strictly
       correct manner known, are documented as thoroughly as possible so their
       exact behaviour is clear, and heavily tested so make sure they are not
       fooled by weird data and Really Bad Things.

       To use, simply load the module providing the functions you want to use as
       arguments (as shown in the SYNOPSIS).

       To aid in maintainability, &quot;Params::Util&quot; will never export by default.

       You must explicitly name the functions you want to export, or use the
       &quot;:ALL&quot; param to just have it export everything (although this is not
       recommended if you have any _FOO functions yourself with which future
       additions to &quot;Params::Util&quot; may clash)

FUNCTIONS
   _STRING $string
       The &quot;_STRING&quot; function is intended to be imported into your package, and
       provides a convenient way to test to see if a value is a normal non-false
       string of non-zero length.

       Note that this will NOT do anything magic to deal with the special &apos;0&apos;
       false negative case, but will return it.

         # &apos;0&apos; not considered valid data
         my $name = _STRING(shift) or die &quot;Bad name&quot;;

         # &apos;0&apos; is considered valid data
         my $string = _STRING($_[0]) ? shift : die &quot;Bad string&quot;;

       Please also note that this function expects a normal string. It does not
       support overloading or other magic techniques to get a string.

       Returns the string as a conveince if it is a valid string, or &quot;undef&quot; if
       not.

   _IDENTIFIER $string
       The &quot;_IDENTIFIER&quot; function is intended to be imported into your package,
       and provides a convenient way to test to see if a value is a string that
       is a valid Perl identifier.

       Returns the string as a convenience if it is a valid identifier, or
       &quot;undef&quot; if not.

   _CLASS $string
       The &quot;_CLASS&quot; function is intended to be imported into your package, and
       provides a convenient way to test to see if a value is a string that is a
       valid Perl class.

       This function only checks that the format is valid, not that the class is
       actually loaded. It also assumes &quot;normalised&quot; form, and does not accept
       class names such as &quot;::Foo&quot; or &quot;D&apos;Oh&quot;.

       Returns the string as a convenience if it is a valid class name, or
       &quot;undef&quot; if not.

   _CLASSISA $string, $class
       The &quot;_CLASSISA&quot; function is intended to be imported into your package,
       and provides a convenient way to test to see if a value is a string that
       is a particularly class, or a subclass of it.

       This function checks that the format is valid and calls the -&gt;isa method
       on the class name. It does not check that the class is actually loaded.

       It also assumes &quot;normalised&quot; form, and does not accept class names such
       as &quot;::Foo&quot; or &quot;D&apos;Oh&quot;.

       Returns the string as a convenience if it is a valid class name, or
       &quot;undef&quot; if not.

   _CLASSDOES $string, $role
       This routine behaves exactly like &quot;_CLASSISA&quot;, but checks with &quot;-&gt;DOES&quot;
       rather than &quot;-&gt;isa&quot;.  This is probably only a good idea to use on Perl
       5.10 or later, when UNIVERSAL::DOES has been implemented.

   _SUBCLASS $string, $class
       The &quot;_SUBCLASS&quot; function is intended to be imported into your package,
       and provides a convenient way to test to see if a value is a string that
       is a subclass of a specified class.

       This function checks that the format is valid and calls the -&gt;isa method
       on the class name. It does not check that the class is actually loaded.

       It also assumes &quot;normalised&quot; form, and does not accept class names such
       as &quot;::Foo&quot; or &quot;D&apos;Oh&quot;.

       Returns the string as a convenience if it is a valid class name, or
       &quot;undef&quot; if not.

   _NUMBER $scalar
       The &quot;_NUMBER&quot; function is intended to be imported into your package, and
       provides a convenient way to test to see if a value is a number. That is,
       it is defined and perl thinks it&apos;s a number.

       This function is basically a Params::Util-style wrapper around the
       Scalar::Util &quot;looks_like_number&quot; function.

       Returns the value as a convience, or &quot;undef&quot; if the value is not a
       number.

   _POSINT $integer
       The &quot;_POSINT&quot; function is intended to be imported into your package, and
       provides a convenient way to test to see if a value is a positive integer
       (of any length).

       Returns the value as a convience, or &quot;undef&quot; if the value is not a
       positive integer.

       The name itself is derived from the XML schema constraint of the same
       name.

   _NONNEGINT $integer
       The &quot;_NONNEGINT&quot; function is intended to be imported into your package,
       and provides a convenient way to test to see if a value is a non-negative
       integer (of any length). That is, a positive integer, or zero.

       Returns the value as a convience, or &quot;undef&quot; if the value is not a non-
       negative integer.

       As with other tests that may return false values, care should be taken to
       test via &quot;defined&quot; in boolean validy contexts.

         unless ( defined _NONNEGINT($value) ) {
            die &quot;Invalid value&quot;;
         }

       The name itself is derived from the XML schema constraint of the same
       name.

   _SCALAR \$scalar
       The &quot;_SCALAR&quot; function is intended to be imported into your package, and
       provides a convenient way to test for a raw and unblessed &quot;SCALAR&quot;
       reference, with content of non-zero length.

       For a version that allows zero length &quot;SCALAR&quot; references, see the
       &quot;_SCALAR0&quot; function.

       Returns the &quot;SCALAR&quot; reference itself as a convenience, or &quot;undef&quot; if the
       value provided is not a &quot;SCALAR&quot; reference.

   _SCALAR0 \$scalar
       The &quot;_SCALAR0&quot; function is intended to be imported into your package, and
       provides a convenient way to test for a raw and unblessed &quot;SCALAR0&quot;
       reference, allowing content of zero-length.

       For a simpler &quot;give me some content&quot; version that requires non-zero
       length, &quot;_SCALAR&quot; function.

       Returns the &quot;SCALAR&quot; reference itself as a convenience, or &quot;undef&quot; if the
       value provided is not a &quot;SCALAR&quot; reference.

   _ARRAY $value
       The &quot;_ARRAY&quot; function is intended to be imported into your package, and
       provides a convenient way to test for a raw and unblessed &quot;ARRAY&quot;
       reference containing at least one element of any kind.

       For a more basic form that allows zero length ARRAY references, see the
       &quot;_ARRAY0&quot; function.

       Returns the &quot;ARRAY&quot; reference itself as a convenience, or &quot;undef&quot; if the
       value provided is not an &quot;ARRAY&quot; reference.

   _ARRAY0 $value
       The &quot;_ARRAY0&quot; function is intended to be imported into your package, and
       provides a convenient way to test for a raw and unblessed &quot;ARRAY&quot;
       reference, allowing &quot;ARRAY&quot; references that contain no elements.

       For a more basic &quot;An array of something&quot; form that also requires at least
       one element, see the &quot;_ARRAY&quot; function.

       Returns the &quot;ARRAY&quot; reference itself as a convenience, or &quot;undef&quot; if the
       value provided is not an &quot;ARRAY&quot; reference.

   _ARRAYLIKE $value
       The &quot;_ARRAYLIKE&quot; function tests whether a given scalar value can respond
       to array dereferencing.  If it can, the value is returned.  If it cannot,
       &quot;_ARRAYLIKE&quot; returns &quot;undef&quot;.

   _HASH $value
       The &quot;_HASH&quot; function is intended to be imported into your package, and
       provides a convenient way to test for a raw and unblessed &quot;HASH&quot;
       reference with at least one entry.

       For a version of this function that allows the &quot;HASH&quot; to be empty, see
       the &quot;_HASH0&quot; function.

       Returns the &quot;HASH&quot; reference itself as a convenience, or &quot;undef&quot; if the
       value provided is not an &quot;HASH&quot; reference.

   _HASH0 $value
       The &quot;_HASH0&quot; function is intended to be imported into your package, and
       provides a convenient way to test for a raw and unblessed &quot;HASH&quot;
       reference, regardless of the &quot;HASH&quot; content.

       For a simpler &quot;A hash of something&quot; version that requires at least one
       element, see the &quot;_HASH&quot; function.

       Returns the &quot;HASH&quot; reference itself as a convenience, or &quot;undef&quot; if the
       value provided is not an &quot;HASH&quot; reference.

   _HASHLIKE $value
       The &quot;_HASHLIKE&quot; function tests whether a given scalar value can respond
       to hash dereferencing.  If it can, the value is returned.  If it cannot,
       &quot;_HASHLIKE&quot; returns &quot;undef&quot;.

   _CODE $value
       The &quot;_CODE&quot; function is intended to be imported into your package, and
       provides a convenient way to test for a raw and unblessed &quot;CODE&quot;
       reference.

       Returns the &quot;CODE&quot; reference itself as a convenience, or &quot;undef&quot; if the
       value provided is not an &quot;CODE&quot; reference.

   _CODELIKE $value
       The &quot;_CODELIKE&quot; is the more generic version of &quot;_CODE&quot;. Unlike &quot;_CODE&quot;,
       which checks for an explicit &quot;CODE&quot; reference, the &quot;_CODELIKE&quot; function
       also includes things that act like them, such as blessed objects that
       overload &apos;&amp;{}&apos;.

       Please note that in the case of objects overloaded with &apos;&amp;{}&apos;, you will
       almost always end up also testing it in &apos;bool&apos; context at some stage.

       For example:

         sub foo {
             my $code1 = _CODELIKE(shift) or die &quot;No code param provided&quot;;
             my $code2 = _CODELIKE(shift);
             if ( $code2 ) {
                  print &quot;Got optional second code param&quot;;
             }
         }
&#12;       As such, you will most likely always want to make sure your class has at
       least the following to allow it to evaluate to true in boolean context.

         # Always evaluate to true in boolean context
         use overload &apos;bool&apos; =&gt; sub () { 1 };

       Returns the callable value as a convenience, or &quot;undef&quot; if the value
       provided is not callable.

       Note - This function was formerly known as _CALLABLE but has been renamed
       for greater symmetry with the other _XXXXLIKE functions.

       The use of _CALLABLE has been deprecated. It will continue to work, but
       with a warning, until end-2006, then will be removed.

       I apologise for any inconvenience caused.

   _INVOCANT $value
       This routine tests whether the given value is a valid method invocant.
       This can be either an instance of an object, or a class name.

       If so, the value itself is returned.  Otherwise, &quot;_INVOCANT&quot; returns
       &quot;undef&quot;.

   _INSTANCE $object, $class
       The &quot;_INSTANCE&quot; function is intended to be imported into your package,
       and provides a convenient way to test for an object of a particular class
       in a strictly correct manner.

       Returns the object itself as a convenience, or &quot;undef&quot; if the value
       provided is not an object of that type.

   _INSTANCEDOES $object, $role
       This routine behaves exactly like &quot;_INSTANCE&quot;, but checks with &quot;-&gt;DOES&quot;
       rather than &quot;-&gt;isa&quot;.  This is probably only a good idea to use on Perl
       5.10 or later, when UNIVERSAL::DOES has been implemented.

   _REGEX $value
       The &quot;_REGEX&quot; function is intended to be imported into your package, and
       provides a convenient way to test for a regular expression.

       Returns the value itself as a convenience, or &quot;undef&quot; if the value
       provided is not a regular expression.

   _SET \@array, $class
       The &quot;_SET&quot; function is intended to be imported into your package, and
       provides a convenient way to test for set of at least one object of a
       particular class in a strictly correct manner.

       The set is provided as a reference to an &quot;ARRAY&quot; of objects of the class
       provided.

       For an alternative function that allows zero-length sets, see the &quot;_SET0&quot;
       function.

       Returns the &quot;ARRAY&quot; reference itself as a convenience, or &quot;undef&quot; if the
       value provided is not a set of that class.

   _SET0 \@array, $class
       The &quot;_SET0&quot; function is intended to be imported into your package, and
       provides a convenient way to test for a set of objects of a particular
       class in a strictly correct manner, allowing for zero objects.

       The set is provided as a reference to an &quot;ARRAY&quot; of objects of the class
       provided.

       For an alternative function that requires at least one object, see the
       &quot;_SET&quot; function.

       Returns the &quot;ARRAY&quot; reference itself as a convenience, or &quot;undef&quot; if the
       value provided is not a set of that class.

   _HANDLE
       The &quot;_HANDLE&quot; function is intended to be imported into your package, and
       provides a convenient way to test whether or not a single scalar value is
       a file handle.

       Unfortunately, in Perl the definition of a file handle can be a little
       bit fuzzy, so this function is likely to be somewhat imperfect (at first
       anyway).

       That said, it is implement as well or better than the other file handle
       detectors in existance (and we stole from the best of them).

   _DRIVER $string
         sub foo {
           my $class = _DRIVER(shift, &apos;My::Driver::Base&apos;) or die &quot;Bad driver&quot;;
           ...
         }

       The &quot;_DRIVER&quot; function is intended to be imported into your package, and
       provides a convenient way to load and validate a driver class.

       The most common pattern when taking a driver class as a parameter is to
       check that the name is a class (i.e. check against _CLASS) and then to
       load the class (if it exists) and then ensure that the class returns true
       for the isa method on some base driver name.

       Return the value as a convenience, or &quot;undef&quot; if the value is not a class
       name, the module does not exist, the module does not load, or the class
       fails the isa test.

TO DO
       - Add _CAN to help resolve the UNIVERSAL::can debacle

       - Would be even nicer if someone would demonstrate how the hell to build
       a Module::Install dist of the ::Util dual Perl/XS type. :/

       - Implement an assertion-like version of this module, that dies on error.

       - Implement a Test:: version of this module, for use in testing

SUPPORT
       Bugs should be reported via the CPAN bug tracker at

       http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Util
       &lt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Util&gt;

       For other issues, contact the author.

AUTHOR
       Adam Kennedy &lt;adamk@cpan.org&gt;

SEE ALSO
       Params::Validate

COPYRIGHT
       Copyright 2005 - 2012 Adam Kennedy.

       This program is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.

       The full text of the license can be found in the LICENSE file included
       with this module.



perl v5.14.2                       2012-03-11                  Params::Util(3pm)

</pre></body></html>
