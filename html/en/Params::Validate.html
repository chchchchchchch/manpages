<html>
<head><meta charset=utf-8/>
<title>Params::Validate - Validate method/function parameters</title></head>
<body><pre>

Params::Validate(3pm)  User Contributed Perl Documentation Params::Validate(3pm)



NAME
       Params::Validate - Validate method/function parameters

VERSION
       version 1.06

SYNOPSIS
           use Params::Validate qw(:all);

           # takes named params (hash or hashref)
           sub foo {
               validate(
                   @_, {
                       foo =&gt; 1,    # mandatory
                       bar =&gt; 0,    # optional
                   }
               );
           }

           # takes positional params
           sub bar {
               # first two are mandatory, third is optional
               validate_pos( @_, 1, 1, 0 );
           }

           sub foo2 {
               validate(
                   @_, {
                       foo =&gt;
                           # specify a type
                           { type =&gt; ARRAYREF },
                       bar =&gt;
                           # specify an interface
                           { can =&gt; [ &apos;print&apos;, &apos;flush&apos;, &apos;frobnicate&apos; ] },
                       baz =&gt; {
                           type      =&gt; SCALAR,     # a scalar ...
                                                    # ... that is a plain integer ...
                           regex     =&gt; qr/^\d+$/,
                           callbacks =&gt; {           # ... and smaller than 90
                               &apos;less than 90&apos; =&gt; sub { shift() &lt; 90 },
                           },
                       }
                   }
               );
           }

           sub with_defaults {
               my %p = validate(
                   @_, {
                       # required
                       foo =&gt; 1,
                       # $p{bar} will be 99 if bar is not given.  bar is now
                       # optional.
                       bar =&gt; { default =&gt; 99 }
                   }
               );
           }

           sub pos_with_defaults {
               my @p = validate_pos( @_, 1, { default =&gt; 99 } );
           }
&#12;           sub sets_options_on_call {
               my %p = validate_with(
                   params =&gt; \@_,
                   spec   =&gt; { foo =&gt; { type =&gt; SCALAR, default =&gt; 2 } },
                   normalize_keys =&gt; sub { $_[0] =~ s/^-//; lc $_[0] },
               );
           }

DESCRIPTION
       The Params::Validate module allows you to validate method or function
       call parameters to an arbitrary level of specificity.  At the simplest
       level, it is capable of validating the required parameters were given and
       that no unspecified additional parameters were passed in.

       It is also capable of determining that a parameter is of a specific type,
       that it is an object of a certain class hierarchy, that it possesses
       certain methods, or applying validation callbacks to arguments.

   EXPORT
       The module always exports the &quot;validate()&quot; and &quot;validate_pos()&quot;
       functions.

       It also has an additional function available for export, &quot;validate_with&quot;,
       which can be used to validate any type of parameters, and set various
       options on a per-invocation basis.

       In addition, it can export the following constants, which are used as
       part of the type checking.  These are &quot;SCALAR&quot;, &quot;ARRAYREF&quot;, &quot;HASHREF&quot;,
       &quot;CODEREF&quot;, &quot;GLOB&quot;, &quot;GLOBREF&quot;, and &quot;SCALARREF&quot;, &quot;UNDEF&quot;, &quot;OBJECT&quot;,
       &quot;BOOLEAN&quot;, and &quot;HANDLE&quot;.  These are explained in the section on Type
       Validation.

       The constants are available via the export tag &quot;:types&quot;.  There is also
       an &quot;:all&quot; tag which includes all of the constants as well as the
       &quot;validation_options()&quot; function.

PARAMETER VALIDATION
       The validation mechanisms provided by this module can handle both named
       or positional parameters.  For the most part, the same features are
       available for each.  The biggest difference is the way that the
       validation specification is given to the relevant subroutine.  The other
       difference is in the error messages produced when validation checks fail.

       When handling named parameters, the module will accept either a hash or a
       hash reference.

       Subroutines expecting named parameters should call the &quot;validate()&quot;
       subroutine like this:

           validate(
               @_, {
                   parameter1 =&gt; validation spec,
                   parameter2 =&gt; validation spec,
                   ...
               }
           );

       Subroutines expecting positional parameters should call the
       &quot;validate_pos()&quot; subroutine like this:

           validate_pos( @_, { validation spec }, { validation spec } );

   Mandatory/Optional Parameters
       If you just want to specify that some parameters are mandatory and others
       are optional, this can be done very simply.
&#12;       For a subroutine expecting named parameters, you would do this:

           validate( @_, { foo =&gt; 1, bar =&gt; 1, baz =&gt; 0 } );

       This says that the &quot;foo&quot; and &quot;bar&quot; parameters are mandatory and that the
       &quot;baz&quot; parameter is optional.  The presence of any other parameters will
       cause an error.

       For a subroutine expecting positional parameters, you would do this:

           validate_pos( @_, 1, 1, 0, 0 );

       This says that you expect at least 2 and no more than 4 parameters.  If
       you have a subroutine that has a minimum number of parameters but can
       take any maximum number, you can do this:

           validate_pos( @_, 1, 1, (0) x (@_ - 2) );

       This will always be valid as long as at least two parameters are given.
       A similar construct could be used for the more complex validation
       parameters described further on.

       Please note that this:

           validate_pos( @_, 1, 1, 0, 1, 1 );

       makes absolutely no sense, so don&apos;t do it.  Any zeros must come at the
       end of the validation specification.

       In addition, if you specify that a parameter can have a default, then it
       is considered optional.

   Type Validation
       This module supports the following simple types, which can be exported as
       constants:

       &#183;   SCALAR

           A scalar which is not a reference, such as 10 or &apos;hello&apos;.  A
           parameter that is undefined is not treated as a scalar.  If you want
           to allow undefined values, you will have to specify &quot;SCALAR | UNDEF&quot;.

       &#183;   ARRAYREF

           An array reference such as &quot;[1, 2, 3]&quot; or &quot;\@foo&quot;.

       &#183;   HASHREF

           A hash reference such as &quot;{ a =&gt; 1, b =&gt; 2 }&quot; or &quot;\%bar&quot;.

       &#183;   CODEREF

           A subroutine reference such as &quot;\&amp;foo_sub&quot; or &quot;sub { print &quot;hello&quot;
           }&quot;.

       &#183;   GLOB

           This one is a bit tricky.  A glob would be something like *FOO, but
           not &quot;\*FOO&quot;, which is a glob reference.  It should be noted that this
           trick:

               my $fh = do { local *FH; };

           makes $fh a glob, not a glob reference.  On the other hand, the
           return value from &quot;Symbol::gensym&quot; is a glob reference.  Either can
           be used as a file or directory handle.

       &#183;   GLOBREF

           A glob reference such as &quot;\*FOO&quot;.  See the GLOB entry above for more
           details.

       &#183;   SCALARREF

           A reference to a scalar such as &quot;\$x&quot;.

       &#183;   UNDEF

           An undefined value

       &#183;   OBJECT

           A blessed reference.

       &#183;   BOOLEAN

           This is a special option, and is just a shortcut for &quot;UNDEF |
           SCALAR&quot;.

       &#183;   HANDLE

           This option is also special, and is just a shortcut for &quot;GLOB |
           GLOBREF&quot;.  However, it seems likely that most people interested in
           either globs or glob references are likely to really be interested in
           whether the parameter in question could be a valid file or directory
           handle.

       To specify that a parameter must be of a given type when using named
       parameters, do this:

           validate(
               @_, {
                   foo =&gt; { type =&gt; SCALAR },
                   bar =&gt; { type =&gt; HASHREF }
               }
           );

       If a parameter can be of more than one type, just use the bitwise or
       (&quot;|&quot;) operator to combine them.

           validate( @_, { foo =&gt; { type =&gt; GLOB | GLOBREF } );

       For positional parameters, this can be specified as follows:

           validate_pos( @_, { type =&gt; SCALAR | ARRAYREF }, { type =&gt; CODEREF } );

   Interface Validation
       To specify that a parameter is expected to have a certain set of methods,
       we can do the following:

           validate(
               @_, {
                   foo =&gt;
                       # just has to be able to -&gt;bar
                       { can =&gt; &apos;bar&apos; }
               }
           );

        ... or ...

           validate(
               @_, {
                   foo =&gt;
                       # must be able to -&gt;bar and -&gt;print
                       { can =&gt; [qw( bar print )] }
               }
           );

   Class Validation
       A word of warning.  When constructing your external interfaces, it is
       probably better to specify what methods you expect an object to have
       rather than what class it should be of (or a child of).  This will make
       your API much more flexible.

       With that said, if you want to validate that an incoming parameter
       belongs to a class (or child class) or classes, do:

           validate(
               @_,
               { foo =&gt; { isa =&gt; &apos;My::Frobnicator&apos; } }
           );

        ... or ...

           validate(
               @_,
               # must be both, not either!
               { foo =&gt; { isa =&gt; [qw( My::Frobnicator IO::Handle )] } }
           );

   Regex Validation
       If you want to specify that a given parameter must match a specific
       regular expression, this can be done with &quot;regex&quot; spec key.  For example:

           validate(
               @_,
               { foo =&gt; { regex =&gt; qr/^\d+$/ } }
           );

       The value of the &quot;regex&quot; key may be either a string or a pre-compiled
       regex created via &quot;qr&quot;.

       If the value being checked against a regex is undefined, the regex is
       explicitly checked against the empty string (&apos;&apos;) instead, in order to
       avoid &quot;Use of uninitialized value&quot; warnings.

       The &quot;Regexp::Common&quot; module on CPAN is an excellent source of regular
       expressions suitable for validating input.

   Callback Validation
       If none of the above are enough, it is possible to pass in one or more
       callbacks to validate the parameter.  The callback will be given the
       value of the parameter as its first argument.  Its second argument will
       be all the parameters, as a reference to either a hash or array.
       Callbacks are specified as hash reference.  The key is an id for the
       callback (used in error messages) and the value is a subroutine
       reference, such as:

           validate(
               @_, {
                   foo =&gt; {
                       callbacks =&gt; {
                           &apos;smaller than a breadbox&apos; =&gt; sub { shift() &lt; $breadbox },
                           &apos;green or blue&apos; =&gt;
                               sub { $_[0] eq &apos;green&apos; || $_[0] eq &apos;blue&apos; }
                       }
                   }
               );
&#12;           validate(
               @_, {
                   foo =&gt; {
                       callbacks =&gt; {
                           &apos;bigger than baz&apos; =&gt; sub { $_[0] &gt; $_[1]-&gt;{baz} }
                       }
                   }
               }
           );

   Untainting
       If you want values untainted, set the &quot;untaint&quot; key in a spec hashref to
       a true value, like this:

           my %p = validate(
               @_, {
                   foo =&gt; { type =&gt; SCALAR, untaint =&gt; 1 },
                   bar =&gt; { type =&gt; ARRAYREF }
               }
           );

       This will untaint the &quot;foo&quot; parameter if the parameters are valid.

       Note that untainting is only done if all parameters are valid.  Also,
       only the return values are untainted, not the original values passed into
       the validation function.

       Asking for untainting of a reference value will not do anything, as
       &quot;Params::Validate&quot; will only attempt to untaint the reference itself.

   Mandatory/Optional Revisited
       If you want to specify something such as type or interface, plus the fact
       that a parameter can be optional, do this:

           validate(
               @_, {
                   foo =&gt; { type =&gt; SCALAR },
                   bar =&gt; { type =&gt; ARRAYREF, optional =&gt; 1 }
               }
           );

       or this for positional parameters:

           validate_pos(
               @_,
               { type =&gt; SCALAR },
               { type =&gt; ARRAYREF, optional =&gt; 1 }
           );

       By default, parameters are assumed to be mandatory unless specified as
       optional.

   Dependencies
       It also possible to specify that a given optional parameter depends on
       the presence of one or more other optional parameters.

           validate(
               @_, {
                   cc_number =&gt; {
                       type     =&gt; SCALAR,
                       optional =&gt; 1,
                       depends  =&gt; [ &apos;cc_expiration&apos;, &apos;cc_holder_name&apos; ],
                   },
                   cc_expiration  { type =&gt; SCALAR, optional =&gt; 1 },
                   cc_holder_name { type =&gt; SCALAR, optional =&gt; 1 },
               }
           );
&#12;       In this case, &quot;cc_number&quot;, &quot;cc_expiration&quot;, and &quot;cc_holder_name&quot; are all
       optional.  However, if &quot;cc_number&quot; is provided, then &quot;cc_expiration&quot; and
       &quot;cc_holder_name&quot; must be provided as well.

       This allows you to group together sets of parameters that all must be
       provided together.

       The &quot;validate_pos()&quot; version of dependencies is slightly different, in
       that you can only depend on one other parameter.  Also, if for example,
       the second parameter 2 depends on the fourth parameter, then it implies a
       dependency on the third parameter as well.  This is because if the fourth
       parameter is required, then the user must also provide a third parameter
       so that there can be four parameters in total.

       &quot;Params::Validate&quot; will die if you try to depend on a parameter not
       declared as part of your parameter specification.

   Specifying defaults
       If the &quot;validate()&quot; or &quot;validate_pos()&quot; functions are called in a list
       context, they will return a hash or containing the original parameters
       plus defaults as indicated by the validation spec.

       If the function is not called in a list context, providing a default in
       the validation spec still indicates that the parameter is optional.

       The hash or array returned from the function will always be a copy of the
       original parameters, in order to leave @_ untouched for the calling
       function.

       Simple examples of defaults would be:

           my %p = validate( @_, { foo =&gt; 1, bar =&gt; { default =&gt; 99 } } );

           my @p = validate_pos( @_, 1, { default =&gt; 99 } );

       In scalar context, a hash reference or array reference will be returned,
       as appropriate.

USAGE NOTES
   Validation failure
       By default, when validation fails &quot;Params::Validate&quot; calls
       &quot;Carp::confess()&quot;.  This can be overridden by setting the &quot;on_fail&quot;
       option, which is described in the &quot;GLOBAL&quot; OPTIONS section.

   Method calls
       When using this module to validate the parameters passed to a method
       call, you will probably want to remove the class/object from the
       parameter list before calling &quot;validate()&quot; or &quot;validate_pos()&quot;.  If your
       method expects named parameters, then this is necessary for the
       &quot;validate()&quot; function to actually work, otherwise @_ will not be usable
       as a hash, because it will first have your object (or class) followed by
       a set of keys and values.

       Thus the idiomatic usage of &quot;validate()&quot; in a method call will look
       something like this:

           sub method {
               my $self = shift;

               my %params = validate(
                   @_, {
                       foo =&gt; 1,
                       bar =&gt; { type =&gt; ARRAYREF },
                   }
               );
           }

   Speeding Up Validation
       In most cases, the validation spec will remain the same for each call to
       a subroutine. In that case, you can speed up validation by defining the
       validation spec just once, rather than on each call to the subroutine:

           my %spec = ( ... );
           sub foo {
               my %params = validate( @_, \%spec );
           }

       You can also use the &quot;state&quot; feature to do this:

           use feature &apos;state&apos;;

           sub foo {
               state %spec = ( ... );
               my %params = validate( @_, \%spec );
           }

&quot;GLOBAL&quot; OPTIONS
       Because the API for the &quot;validate()&quot; and &quot;validate_pos()&quot; functions does
       not make it possible to specify any options other than the validation
       spec, it is possible to set some options as pseudo-&apos;globals&apos;.  These
       allow you to specify such things as whether or not the validation of
       named parameters should be case sensitive, for one example.

       These options are called pseudo-&apos;globals&apos; because these settings are only
       applied to calls originating from the package that set the options.

       In other words, if I am in package &quot;Foo&quot; and I call
       &quot;validation_options()&quot;, those options are only in effect when I call
       &quot;validate()&quot; from package &quot;Foo&quot;.

       While this is quite different from how most other modules operate, I feel
       that this is necessary in able to make it possible for one
       module/application to use Params::Validate while still using other
       modules that also use Params::Validate, perhaps with different options
       set.

       The downside to this is that if you are writing an app with a standard
       calling style for all functions, and your app has ten modules, each
       module must include a call to &quot;validation_options()&quot;. You could of course
       write a module that all your modules use which uses various trickery to
       do this when imported.

   Options
       &#183;   normalize_keys =&gt; $callback

           This option is only relevant when dealing with named parameters.

           This callback will be used to transform the hash keys of both the
           parameters and the parameter spec when &quot;validate()&quot; or
           &quot;validate_with()&quot; are called.

           Any alterations made by this callback will be reflected in the
           parameter hash that is returned by the validation function.  For
           example:

               sub foo {
                   return validate_with(
                       params =&gt; \@_,
                       spec   =&gt; { foo =&gt; { type =&gt; SCALAR } },
                       normalize_keys =&gt;
                           sub { my $k = shift; $k =~ s/^-//; return uc $k },
                   );

               }

               %p = foo( foo =&gt; 20 );

               # $p{FOO} is now 20

               %p = foo( -fOo =&gt; 50 );

               # $p{FOO} is now 50

           The callback must return a defined value.

           If a callback is given then the deprecated &quot;ignore_case&quot; and
           &quot;strip_leading&quot; options are ignored.

       &#183;   allow_extra =&gt; $boolean

           If true, then the validation routine will allow extra parameters not
           named in the validation specification.  In the case of positional
           parameters, this allows an unlimited number of maximum parameters
           (though a minimum may still be set).  Defaults to false.

       &#183;   on_fail =&gt; $callback

           If given, this callback will be called whenever a validation check
           fails.  It will be called with a single parameter, which will be a
           string describing the failure.  This is useful if you wish to have
           this module throw exceptions as objects rather than as strings, for
           example.

           This callback is expected to &quot;die()&quot; internally.  If it does not, the
           validation will proceed onwards, with unpredictable results.

           The default is to simply use the Carp module&apos;s &quot;confess()&quot; function.

       &#183;   stack_skip =&gt; $number

           This tells Params::Validate how many stack frames to skip when
           finding a subroutine name to use in error messages.  By default, it
           looks one frame back, at the immediate caller to &quot;validate()&quot; or
           &quot;validate_pos()&quot;.  If this option is set, then the given number of
           frames are skipped instead.

       &#183;   ignore_case =&gt; $boolean

           DEPRECATED

           This is only relevant when dealing with named parameters.  If it is
           true, then the validation code will ignore the case of parameter
           names.  Defaults to false.

       &#183;   strip_leading =&gt; $characters

           DEPRECATED

           This too is only relevant when dealing with named parameters.  If
           this is given then any parameters starting with these characters will
           be considered equivalent to parameters without them entirely.  For
           example, if this is specified as &apos;-&apos;, then &quot;-foo&quot; and &quot;foo&quot; would be
           considered identical.

PER-INVOCATION OPTIONS
       The &quot;validate_with()&quot; function can be used to set the options listed
       above on a per-invocation basis.  For example:

           my %p = validate_with(
               params =&gt; \@_,
               spec   =&gt; {
                   foo =&gt; { type    =&gt; SCALAR },
                   bar =&gt; { default =&gt; 10 }
               },
               allow_extra =&gt; 1,
           );

       In addition to the options listed above, it is also possible to set the
       option &quot;called&quot;, which should be a string.  This string will be used in
       any error messages caused by a failure to meet the validation spec.

       This subroutine will validate named parameters as a hash if the &quot;spec&quot;
       parameter is a hash reference.  If it is an array reference, the
       parameters are assumed to be positional.

           my %p = validate_with(
               params =&gt; \@_,
               spec   =&gt; {
                   foo =&gt; { type    =&gt; SCALAR },
                   bar =&gt; { default =&gt; 10 }
               },
               allow_extra =&gt; 1,
               called      =&gt; &apos;The Quux::Baz class constructor&apos;,
           );

           my @p = validate_with(
               params =&gt; \@_,
               spec   =&gt; [
                   { type    =&gt; SCALAR },
                   { default =&gt; 10 }
               ],
               allow_extra =&gt; 1,
               called      =&gt; &apos;The Quux::Baz class constructor&apos;,
           );

DISABLING VALIDATION
       If the environment variable &quot;PERL_NO_VALIDATION&quot; is set to something
       true, then validation is turned off.  This may be useful if you only want
       to use this module during development but don&apos;t want the speed hit during
       production.

       The only error that will be caught will be when an odd number of
       parameters are passed into a function/method that expects a hash.

       If you want to selectively turn validation on and off at runtime, you can
       directly set the $Params::Validate::NO_VALIDATION global variable.  It is
       strongly recommended that you localize any changes to this variable,
       because other modules you are using may expect validation to be on when
       they execute.  For example:

           {
               local $Params::Validate::NO_VALIDATION = 1;

               # no error
               foo( bar =&gt; 2 );
           }

           # error
           foo( bar =&gt; 2 );

           sub foo {
               my %p = validate( @_, { foo =&gt; 1 } );
               ...;
           }

       But if you want to shoot yourself in the foot and just turn it off, go
       ahead!

LIMITATIONS
       Right now there is no way (short of a callback) to specify that something
       must be of one of a list of classes, or that it must possess one of a
       list of methods.  If this is desired, it can be added in the future.

       Ideally, there would be only one validation function.  If someone figures
       out how to do this, please let me know.

SUPPORT
       Please submit bugs and patches to the CPAN RT system at
       http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params%3A%3AValidate or
       via email at bug-params-validate@rt.cpan.org.

       Support questions can be sent to Dave at autarch@urth.org.

DONATIONS
       If you&apos;d like to thank me for the work I&apos;ve done on this module, please
       consider making a &quot;donation&quot; to me via PayPal. I spend a lot of free time
       creating free software, and would appreciate any support you&apos;d care to
       offer.

       Please note that I am not suggesting that you must do this in order for
       me to continue working on this particular software. I will continue to do
       so, inasmuch as I have in the past, for as long as it interests me.

       Similarly, a donation made in this way will probably not make me work on
       this software much more, unless I get so many donations that I can
       consider working on free software full time, which seems unlikely at
       best.

       To donate, log into PayPal and send money to autarch@urth.org or use the
       button on this page: http://www.urth.org/~autarch/fs-donation.html
       &lt;http://www.urth.org/~autarch/fs-donation.html&gt;

AUTHOR
       Dave Rolsky, &lt;autarch@urth.org&gt; and Ilya Martynov &lt;ilya@martynov.org&gt;

COPYRIGHT AND LICENSE
       This software is Copyright (c) 2012 by Dave Rolsky and Ilya Martynov.

       This is free software, licensed under:

         The Artistic License 2.0 (GPL Compatible)



perl v5.14.2                       2012-02-12              Params::Validate(3pm)

</pre></body></html>
