<html>
<head><meta charset=utf-8/>
<title>Readonly - Facility for creating read-only scalars, arrays, hashes.</title></head>
<body><pre>

Readonly(3pm)          User Contributed Perl Documentation         Readonly(3pm)



NAME
       Readonly - Facility for creating read-only scalars, arrays, hashes.

VERSION
       This documentation describes version 1.03 of Readonly.pm, April 20, 2004.

SYNOPSIS
        use Readonly;

        # Read-only scalar
        Readonly::Scalar     $sca =&gt; $initial_value;
        Readonly::Scalar  my $sca =&gt; $initial_value;

        # Read-only array
        Readonly::Array      @arr =&gt; @values;
        Readonly::Array   my @arr =&gt; @values;

        # Read-only hash
        Readonly::Hash       %has =&gt; (key =&gt; value, key =&gt; value, ...);
        Readonly::Hash    my %has =&gt; (key =&gt; value, key =&gt; value, ...);
        # or:
        Readonly::Hash       %has =&gt; {key =&gt; value, key =&gt; value, ...};

        # You can use the read-only variables like any regular variables:
        print $sca;
        $something = $sca + $arr[2];
        next if $has{$some_key};

        # But if you try to modify a value, your program will die:
        $sca = 7;
        push @arr, &apos;seven&apos;;
        delete $has{key};
        # The error message is &quot;Modification of a read-only value
       attempted&quot;

        # Alternate form (Perl 5.8 and later)
        Readonly    $sca =&gt; $initial_value;
        Readonly my $sca =&gt; $initial_value;
        Readonly    @arr =&gt; @values;
        Readonly my @arr =&gt; @values;
        Readonly    %has =&gt; (key =&gt; value, key =&gt; value, ...);
        Readonly my %has =&gt; (key =&gt; value, key =&gt; value, ...);
        # Alternate form (for Perls earlier than v5.8)
        Readonly    \$sca =&gt; $initial_value;
        Readonly \my $sca =&gt; $initial_value;
        Readonly    \@arr =&gt; @values;
        Readonly \my @arr =&gt; @values;
        Readonly    \%has =&gt; (key =&gt; value, key =&gt; value, ...);
        Readonly \my %has =&gt; (key =&gt; value, key =&gt; value, ...);

DESCRIPTION
       This is a facility for creating non-modifiable variables.  This is useful
       for configuration files, headers, etc.  It can also be useful as a
       development and debugging tool, for catching updates to variables that
       should not be changed.

       If any of the values you pass to &quot;Scalar&quot;, &quot;Array&quot;, or &quot;Hash&quot; are
       references, then those functions recurse over the data structures,
       marking everything as Readonly.  Usually, this is what you want: the
       entire structure nonmodifiable.  If you want only the top level to be
       Readonly, use the alternate &quot;Scalar1&quot;, &quot;Array1&quot; and &quot;Hash1&quot; functions.
&#12;       Please note that most users of Readonly will also want to install a
       companion module Readonly::XS.  See the &quot;CONS&quot; section below for more
       details.

COMPARISON WITH &quot;use constant&quot;
       Perl provides a facility for creating constant values, via the &quot;use
       constant&quot; pragma.  There are several problems with this pragma.

       &#183; The constants created have no leading $ or @ character.

       &#183; These constants cannot be interpolated into strings.

       &#183; Syntax can get dicey sometimes.  For example:

          use constant CARRAY =&gt; (2, 3, 5, 7, 11, 13);
          $a_prime = CARRAY[2];        # wrong!
          $a_prime = (CARRAY)[2];      # right -- MUST use parentheses

       &#183; You have to be very careful in places where barewords are allowed.  For
         example:

          use constant SOME_KEY =&gt; &apos;key&apos;;
          %hash = (key =&gt; &apos;value&apos;, other_key =&gt; &apos;other_value&apos;);
          $some_value = $hash{SOME_KEY};        # wrong!
          $some_value = $hash{+SOME_KEY};       # right

         (who thinks to use a unary plus when using a hash?)

       &#183; &quot;use constant&quot; works for scalars and arrays, not hashes.

       &#183; These constants are global ot the package in which they&apos;re declared;
         cannot be lexically scoped.

       &#183; Works only at compile time.

       &#183; Can be overridden:

          use constant PI =&gt; 3.14159;
          ...
          use constant PI =&gt; 2.71828;

         (this does generate a warning, however, if you have warnings enabled).

       &#183; It is very difficult to make and use deep structures (complex data
         structures) with &quot;use constant&quot;.

COMPARISON WITH TYPEGLOB CONSTANTS
       Another popular way to create read-only scalars is to modify the symbol
       table entry for the variable by using a typeglob:

        *a = \&apos;value&apos;;

       This works fine, but it only works for global variables (&quot;my&quot; variables
       have no symbol table entry).  Also, the following similar constructs do
       not work:

        *a = [1, 2, 3];      # Does NOT create a read-only array
        *a = { a =&gt; &apos;A&apos;};    # Does NOT create a read-only hash

PROS
       Readonly.pm, on the other hand, will work with global variables and with
       lexical (&quot;my&quot;) variables.  It will create scalars, arrays, or hashes, all
       of which look and work like normal, read-write Perl variables.  You can
       use them in scalar context, in list context; you can take references to
       them, pass them to functions, anything.
&#12;       Readonly.pm also works well with complex data structures, allowing you to
       tag the whole structure as nonmodifiable, or just the top level.

       Also, Readonly variables may not be reassigned.  The following code will
       die:

        Readonly::Scalar $pi =&gt; 3.14159;
        ...
        Readonly::Scalar $pi =&gt; 2.71828;

CONS
       Readonly.pm does impose a performance penalty.  It&apos;s pretty slow.  How
       slow?  Run the &quot;benchmark.pl&quot; script that comes with Readonly.  On my
       test system, &quot;use constant&quot;, typeglob constants, and regular read/write
       Perl variables were all about the same speed, and Readonly.pm constants
       were about 1/20 the speed.

       However, there is relief.  There is a companion module available,
       Readonly::XS.  If it is installed on your system, Readonly.pm uses it to
       make read-only scalars much faster.  With Readonly::XS, Readonly scalars
       are as fast as the other types of variables.  Readonly arrays and hashes
       will still be relatively slow.  But it&apos;s likely that most of your
       Readonly variables will be scalars.

       If you can&apos;t use Readonly::XS (for example, if you don&apos;t have a C
       compiler, or your perl is statically linked and you don&apos;t want to re-link
       it), you have to decide whether the benefits of Readonly variables
       outweigh the speed issue. For most configuration variables (and other
       things that Readonly is likely to be useful for), the speed issue is
       probably not really a big problem.  But benchmark your program if it
       might be.  If it turns out to be a problem, you may still want to use
       Readonly.pm during development, to catch changes to variables that should
       not be changed, and then remove it for production:

        # For testing:
        Readonly::Scalar  $Foo_Directory =&gt; &apos;/usr/local/foo&apos;;
        Readonly::Scalar  $Bar_Directory =&gt; &apos;/usr/local/bar&apos;;
        # $Foo_Directory = &apos;/usr/local/foo&apos;;
        # $Bar_Directory = &apos;/usr/local/bar&apos;;

        # For production:
        # Readonly::Scalar  $Foo_Directory =&gt; &apos;/usr/local/foo&apos;;
        # Readonly::Scalar  $Bar_Directory =&gt; &apos;/usr/local/bar&apos;;
        $Foo_Directory = &apos;/usr/local/foo&apos;;
        $Bar_Directory = &apos;/usr/local/bar&apos;;

FUNCTIONS
       Readonly::Scalar $var =&gt; $value;
           Creates a nonmodifiable scalar, $var, and assigns a value of $value
           to it.  Thereafter, its value may not be changed.  Any attempt to
           modify the value will cause your program to die.

           A value must be supplied.  If you want the variable to have &quot;undef&quot;
           as its value, you must specify &quot;undef&quot;.

           If $value is a reference to a scalar, array, or hash, then this
           function will mark the scalar, array, or hash it points to as being
           Readonly as well, and it will recursively traverse the structure,
           marking the whole thing as Readonly.  Usually, this is what you want.
           However, if you want only the $value marked as Readonly, use
           &quot;Scalar1&quot;.

           If $var is already a Readonly variable, the program will die with an
           error about reassigning Readonly variables.

       Readonly::Array @arr =&gt; (value, value, ...);
           Creates a nonmodifiable array, @arr, and assigns the specified list
           of values to it.  Thereafter, none of its values may be changed; the
           array may not be lengthened or shortened or spliced.  Any attempt to
           do so will cause your program to die.

           If any of the values passed is a reference to a scalar, array, or
           hash, then this function will mark the scalar, array, or hash it
           points to as being Readonly as well, and it will recursively traverse
           the structure, marking the whole thing as Readonly.  Usually, this is
           what you want.  However, if you want only the hash %@arr itself
           marked as Readonly, use &quot;Array1&quot;.

           If @arr is already a Readonly variable, the program will die with an
           error about reassigning Readonly variables.

       Readonly::Hash %h =&gt; (key =&gt; value, key =&gt; value, ...);
       Readonly::Hash %h =&gt; {key =&gt; value, key =&gt; value, ...};
           Creates a nonmodifiable hash, %h, and assigns the specified keys and
           values to it.  Thereafter, its keys or values may not be changed.
           Any attempt to do so will cause your program to die.

           A list of keys and values may be specified (with parentheses in the
           synopsis above), or a hash reference may be specified (curly braces
           in the synopsis above).  If a list is specified, it must have an even
           number of elements, or the function will die.

           If any of the values is a reference to a scalar, array, or hash, then
           this function will mark the scalar, array, or hash it points to as
           being Readonly as well, and it will recursively traverse the
           structure, marking the whole thing as Readonly.  Usually, this is
           what you want.  However, if you want only the hash %h itself marked
           as Readonly, use &quot;Hash1&quot;.

           If %h is already a Readonly variable, the program will die with an
           error about reassigning Readonly variables.

       Readonly $var =&gt; $value;
       Readonly @arr =&gt; (value, value, ...);
       Readonly %h =&gt; (key =&gt; value, ...);
       Readonly %h =&gt; {key =&gt; value, ...};
           The &quot;Readonly&quot; function is an alternate to the &quot;Scalar&quot;, &quot;Array&quot;, and
           &quot;Hash&quot; functions.  It has the advantage (if you consider it an
           advantage) of being one function.  That may make your program look
           neater, if you&apos;re initializing a whole bunch of constants at once.
           You may or may not prefer this uniform style.

           It has the disadvantage of having a slightly different syntax for
           versions of Perl prior to 5.8.  For earlier versions, you must supply
           a backslash, because it requires a reference as the first parameter.

             Readonly \$var =&gt; $value;
             Readonly \@arr =&gt; (value, value, ...);
             Readonly \%h =&gt; (key =&gt; value, ...);
             Readonly \%h =&gt; {key =&gt; value, ...};

           You may or may not consider this ugly.

       Readonly::Scalar1 $var =&gt; $value;
       Readonly::Array1 @arr =&gt; (value, value, ...);
       Readonly::Hash1 %h =&gt; (key =&gt; value, key =&gt; value, ...);
       Readonly::Hash1 %h =&gt; {key =&gt; value, key =&gt; value, ...};
           These alternate functions create shallow Readonly variables, instead
           of deep ones.  For example:

            Readonly::Array1 @shal =&gt; (1, 2, {perl=&gt;&apos;Rules&apos;, java=&gt;&apos;Bites&apos;}, 4, 5);
            Readonly::Array  @deep =&gt; (1, 2, {perl=&gt;&apos;Rules&apos;, java=&gt;&apos;Bites&apos;}, 4, 5);

            $shal[1] = 7;           # error
            $shal[2]{APL}=&apos;Weird&apos;;  # Allowed! since the hash isn&apos;t Readonly
            $deep[1] = 7;           # error
            $deep[2]{APL}=&apos;Weird&apos;;  # error, since the hash is Readonly

EXAMPLES
        # SCALARS:

        # A plain old read-only value
        Readonly::Scalar $a =&gt; &quot;A string value&quot;;

        # The value need not be a compile-time constant:
        Readonly::Scalar $a =&gt; $computed_value;


        # ARRAYS:

        # A read-only array:
        Readonly::Array @a =&gt; (1, 2, 3, 4);

        # The parentheses are optional:
        Readonly::Array @a =&gt; 1, 2, 3, 4;

        # You can use Perl&apos;s built-in array quoting syntax:
        Readonly::Array @a =&gt; qw/1 2 3 4/;

        # You can initialize a read-only array from a variable one:
        Readonly::Array @a =&gt; @computed_values;

        # A read-only array can be empty, too:
        Readonly::Array @a =&gt; ();
        Readonly::Array @a;        # equivalent


        # HASHES

        # Typical usage:
        Readonly::Hash %a =&gt; (key1 =&gt; &apos;value1&apos;, key2 =&gt; &apos;value2&apos;);

        # A read-only hash can be initialized from a variable one:
        Readonly::Hash %a =&gt; %computed_values;

        # A read-only hash can be empty:
        Readonly::Hash %a =&gt; ();
        Readonly::Hash %a;        # equivalent

        # If you pass an odd number of values, the program will die:
        Readonly::Hash %a =&gt; (key1 =&gt; &apos;value1&apos;, &quot;value2&quot;);
            --&gt; dies with &quot;May not store an odd number of values in a hash&quot;

EXPORTS
       By default, this module exports the following symbol into the calling
       program&apos;s namespace:

        Readonly

       The following symbols are available for import into your program, if you
       like:

        Scalar  Scalar1
        Array   Array1
        Hash    Hash1

REQUIREMENTS
        Perl 5.000
        Carp.pm (included with Perl)
        Exporter.pm (included with Perl)

        Readonly::XS is recommended but not required.

ACKNOWLEDGEMENTS
       Thanks to Slaven Rezic for the idea of one common function (Readonly) for
       all three types of variables (13 April 2002).

       Thanks to Ernest Lergon for the idea (and initial code) for deeply-
       Readonly data structures (21 May 2002).

       Thanks to Damian Conway for the idea (and code) for making the Readonly
       function work a lot smoother under perl 5.8+.

AUTHOR / COPYRIGHT
       Eric J. Roode, roode@cpan.org

       Copyright (c) 2001-2004 by Eric J. Roode. All Rights Reserved.  This
       module is free software; you can redistribute it and/or modify it under
       the same terms as Perl itself.

       If you have suggestions for improvement, please drop me a line.  If you
       make improvements to this software, I ask that you please send me a copy
       of your changes. Thanks.

       Readonly.pm is made from 100% recycled electrons.  No animals were harmed
       during the development and testing of this module.  Not sold in stores!
       Readonly::XS sold separately.  Void where prohibited.



perl v5.14.2                       2012-06-11                      Readonly(3pm)

</pre></body></html>
