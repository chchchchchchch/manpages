<html>
<head><meta charset=utf-8/>
<title>Regexp::Assemble - Assemble multiple Regular Expressions into a single RE</title></head>
<body><pre>

Assemble(3pm)          User Contributed Perl Documentation         Assemble(3pm)



NAME
       Regexp::Assemble - Assemble multiple Regular Expressions into a single RE

VERSION
       This document describes version 0.35 of Regexp::Assemble, released
       2011-04-07.

SYNOPSIS
         use Regexp::Assemble;

         my $ra = Regexp::Assemble-&gt;new;
         $ra-&gt;add( &apos;ab+c&apos; );
         $ra-&gt;add( &apos;ab+-&apos; );
         $ra-&gt;add( &apos;a\w\d+&apos; );
         $ra-&gt;add( &apos;a\d+&apos; );
         print $ra-&gt;re; # prints a(?:\w?\d+|b+[-c])

DESCRIPTION
       Regexp::Assemble takes an arbitrary number of regular expressions and
       assembles them into a single regular expression (or RE) that matches all
       that the individual REs match.

       As a result, instead of having a large list of expressions to loop over,
       a target string only needs to be tested against one expression.  This is
       interesting when you have several thousand patterns to deal with. Serious
       effort is made to produce the smallest pattern possible.

       It is also possible to track the original patterns, so that you can
       determine which, among the source patterns that form the assembled
       pattern, was the one that caused the match to occur.

       You should realise that large numbers of alternations are processed in
       perl&apos;s regular expression engine in O(n) time, not O(1). If you are still
       having performance problems, you should look at using a trie. Note that
       Perl&apos;s own regular expression engine will implement trie optimisations in
       perl 5.10 (they are already available in perl 5.9.3 if you want to try
       them out). &quot;Regexp::Assemble&quot; will do the right thing when it knows it&apos;s
       running on a trie&apos;d perl.  (At least in some version after this one).

       Some more examples of usage appear in the accompanying README. If that
       file isn&apos;t easy to access locally, you can find it on a web repository
       such as http://search.cpan.org/dist/Regexp-Assemble/README
       &lt;http://search.cpan.org/dist/Regexp-Assemble/README&gt; or
       http://cpan.uwinnipeg.ca/htdocs/Regexp-Assemble/README.html
       &lt;http://cpan.uwinnipeg.ca/htdocs/Regexp-Assemble/README.html&gt;.

METHODS
       new     Creates a new &quot;Regexp::Assemble&quot; object. The following optional
               key/value parameters may be employed. All keys have a
               corresponding method that can be used to change the behaviour
               later on. As a general rule, especially if you&apos;re just starting
               out, you don&apos;t have to bother with any of these.

               anchor_*, a family of optional attributes that allow anchors
               (&quot;^&quot;, &quot;\b&quot;, &quot;\Z&quot;...) to be added to the resulting pattern.

               flags, sets the &quot;imsx&quot; flags to add to the assembled regular
               expression.  Warning: no error checking is done, you should
               ensure that the flags you pass are understood by the version of
               Perl you are using. modifiers exists as an alias, for users
               familiar with Regexp::List.
&#12;               chomp, controls whether the pattern should be chomped before
               being lexed. Handy if you are reading patterns from a file. By
               default, &quot;chomp&quot;ing is performed (this behaviour changed as of
               version 0.24, prior versions did not chomp automatically).  See
               also the &quot;file&quot; attribute and the &quot;add_file&quot; method.

               file, slurp the contents of the specified file and add them to
               the assembly. Multiple files may be processed by using a list.

                 my $r = Regexp::Assemble-&gt;new(file =&gt; &apos;re.list&apos;);

                 my $r = Regexp::Assemble-&gt;new(file =&gt; [&apos;re.1&apos;, &apos;re.2&apos;]);

               If you really don&apos;t want chomping to occur, you will have to set
               the &quot;chomp&quot; attribute to 0 (zero). You may also want to look at
               the &quot;input_record_separator&quot; attribute, as well.

               input_record_separator, controls what constitutes a record
               separator when using the &quot;file&quot; attribute or the &quot;add_file&quot;
               method. May be abbreviated to rs. See the $/ variable in perlvar.

               lookahead, controls whether the pattern should contain zero-width
               lookahead assertions (For instance:
               (?=[abc])(?:bob|alice|charles).  This is not activated by
               default, because in many circumstances the cost of processing the
               assertion itself outweighs the benefit of its faculty for short-
               circuiting a match that will fail. This is sensitive to the
               probability of a match succeeding, so if you&apos;re worried about
               performance you&apos;ll have to benchmark a sample population of
               targets to see which way the benefits lie.

               track, controls whether you want know which of the initial
               patterns was the one that matched. See the &quot;matched&quot; method for
               more details. Note for version 5.8 of Perl and below, in this
               mode of operation YOU SHOULD BE AWARE OF THE SECURITY
               IMPLICATIONS that this entails. Perl 5.10 does not suffer from
               any such restriction.

               indent, the number of spaces used to indent nested grouping of a
               pattern. Use this to produce a pretty-printed pattern. See the
               &quot;as_string&quot; method for a more detailed explanation.

               pre_filter, allows you to add a callback to enable sanity checks
               on the pattern being loaded. This callback is triggered before
               the pattern is split apart by the lexer. In other words, it
               operates on the entire pattern. If you are loading patterns from
               a file, this would be an appropriate place to remove comments.

               filter, allows you to add a callback to enable sanity checks on
               the pattern being loaded. This callback is triggered after the
               pattern has been split apart by the lexer.

               unroll_plus, controls whether to unroll, for example, &quot;x+&quot; into
               &quot;x&quot;, &quot;x*&quot;, which may allow additional reductions in the resulting
               assembled pattern.

               reduce, controls whether tail reduction occurs or not. If set,
               patterns like &quot;a(?:bc+d|ec+d)&quot; will be reduced to &quot;a[be]c+d&quot;.
               That is, the end of the pattern in each part of the b... and d...
               alternations is identical, and hence is hoisted out of the
               alternation and placed after it. On by default. Turn it off if
               you&apos;re really pressed for short assembly times.

               lex, specifies the pattern used to lex the input lines into
               tokens. You could replace the default pattern by a more
               sophisticated version that matches arbitrarily nested
               parentheses, for example.

               debug, controls whether copious amounts of output is produced
               during the loading stage or the reducing stage of assembly.

                 my $ra = Regexp::Assemble-&gt;new;
                 my $rb = Regexp::Assemble-&gt;new( chomp =&gt; 1, debug =&gt; 3 );

               mutable, controls whether new patterns can be added to the object
               after the assembled pattern is generated. DEPRECATED.

               This method/attribute will be removed in a future release. It
               doesn&apos;t really serve any purpose, and may be more effectively
               replaced by cloning an existing &quot;Regexp::Assemble&quot; object and
               spinning out a pattern from that instead.

               A more detailed explanation of these attributes follows.

       clone   Clones the contents of a Regexp::Assemble object and creates a
               new object (in other words it performs a deep copy).

               If the Storable module is installed, its dclone method will be
               used, otherwise the cloning will be performed using a pure perl
               approach.

               You can use this method to take a snapshot of the patterns that
               have been added so far to an object, and generate an assembly
               from the clone. Additional patterns may to be added to the
               original object afterwards.

                 my $re = $main-&gt;clone-&gt;re();
                 $main-&gt;add( &apos;another-pattern-\\d+&apos; );

       add(LIST)
               Takes a string, breaks it apart into a set of tokens (respecting
               meta characters) and inserts the resulting list into the &quot;R::A&quot;
               object. It uses a naive regular expression to lex the string that
               may be fooled complex expressions (specifically, it will fail to
               lex nested parenthetical expressions such as &quot;ab(cd(ef)?gh)ij&quot;
               correctly). If this is the case, the end of the string will not
               be tokenised correctly and returned as one long string.

               On the one hand, this may indicate that the patterns you are
               trying to feed the &quot;R::A&quot; object are too complex. Simpler
               patterns might allow the algorithm to work more effectively and
               perform more reductions in the resulting pattern.

               On the other hand, you can supply your own pattern to perform the
               lexing if you need. The test suite contains an example of a lexer
               pattern that will match one level of nested parentheses.

               Note that there is an internal optimisation that will bypass a
               much of the lexing process. If a string contains no &quot;\&quot;
               (backslash), &quot;[&quot; (open square bracket), &quot;(&quot; (open paren), &quot;?&quot;
               (question mark), &quot;+&quot; (plus), &quot;*&quot; (star) or &quot;{&quot; (open curly), a
               character split will be performed directly.

               A list of strings may be supplied, thus you can pass it a file
               handle of a file opened for reading:

                   $re-&gt;add( &apos;\d+-\d+-\d+-\d+\.example\.com&apos; );
                   $re-&gt;add( &lt;IN&gt; );

               If the file is very large, it may be more efficient to use a
               &quot;while&quot; loop, to read the file line-by-line:
&#12;                   $re-&gt;add($_) while &lt;IN&gt;;

               The &quot;add&quot; method will chomp the lines automatically. If you do
               not want this to occur (you want to keep the record separator),
               then disable &quot;chomp&quot;ing.

                   $re-&gt;chomp(0);
                   $re-&gt;add($_) while &lt;IN&gt;;

               This method is chainable.

       add_file(FILENAME [...])
               Takes a list of file names. Each file is opened and read line by
               line. Each line is added to the assembly.

                 $r-&gt;add_file( &apos;file.1&apos;, &apos;file.2&apos; );

               If a file cannot be opened, the method will croak. If you cannot
               afford to let this happen then you should wrap the call in a
               &quot;eval&quot; block.

               Chomping happens automatically unless you the chomp(0) method to
               disable it. By default, input lines are read according to the
               value of the &quot;input_record_separator&quot; attribute (if defined), and
               will otherwise fall back to the current setting of the system $/
               variable. The record separator may also be specified on each call
               to &quot;add_file&quot;. Internally, the routine &quot;local&quot;ises the value of
               $/ to whatever is required, for the duration of the call.

               An alternate calling mechanism using a hash reference is
               available.  The recognised keys are:

               file
                   Reference to a list of file names, or the name of a single
                   file.

                     $r-&gt;add_file({file =&gt; [&apos;file.1&apos;, &apos;file.2&apos;, &apos;file.3&apos;]});
                     $r-&gt;add_file({file =&gt; &apos;file.n&apos;});

               input_record_separator
                   If present, indicates what constitutes a line

                     $r-&gt;add_file({file =&gt; &apos;data.txt&apos;, input_record_separator =&gt; &apos;:&apos; });

               rs  An alias for input_record_separator (mnemonic: same as the
                   English variable names).

                 $r-&gt;add_file( {
                   file =&gt; [ &apos;pattern.txt&apos;, &apos;more.txt&apos; ],
                   input_record_separator  =&gt; &quot;\r\n&quot;,
                 });

       insert(LIST)
               Takes a list of tokens representing a regular expression and
               stores them in the object. Note: you should not pass it a bare
               regular expression, such as &quot;ab+c?d*e&quot;. You must pass it as a
               list of tokens, e.g. &quot;(&apos;a&apos;, &apos;b+&apos;, &apos;c?&apos;, &apos;d*&apos;, &apos;e&apos;)&quot;.

               This method is chainable, e.g.:

                 my $ra = Regexp::Assemble-&gt;new
                   -&gt;insert( qw[ a b+ c? d* e ] )
                   -&gt;insert( qw[ a c+ d+ e* f ] );

               Lexing complex patterns with metacharacters and so on can consume
               a significant proportion of the overall time to build an
               assembly.  If you have the information available in a tokenised
               form, calling &quot;insert&quot; directly can be a big win.

       lexstr  Use the &quot;lexstr&quot; method if you are curious to see how a pattern
               gets tokenised. It takes a scalar on input, representing a
               pattern, and returns a reference to an array, containing the
               tokenised pattern. You can recover the original pattern by
               performing a &quot;join&quot;:

                 my @token = $re-&gt;lexstr($pattern);
                 my $new_pattern = join( &apos;&apos;, @token );

               If the original pattern contains unnecessary backslashes, or
               &quot;\x4b&quot; escapes, or quotemeta escapes (&quot;\Q&quot;...&quot;\E&quot;) the resulting
               pattern may not be identical.

               Call &quot;lexstr&quot; does not add the pattern to the object, it is
               merely for exploratory purposes. It will, however, update various
               statistical counters.

       pre_filter(CODE)
               Allows you to install a callback to check that the pattern being
               loaded contains valid input. It receives the pattern as a whole
               to be added, before it been tokenised by the lexer. It may to
               return 0 or &quot;undef&quot; to indicate that the pattern should not be
               added, any true value indicates that the contents are fine.

               A filter to strip out trailing comments (marked by #):

                 $re-&gt;pre_filter( sub { $_[0] =~ s/\s*#.*$//; 1 } );

               A filter to ignore blank lines:

                 $re-&gt;pre_filter( sub { length(shift) } );

               If you want to remove the filter, pass &quot;undef&quot; as a parameter.

                 $ra-&gt;pre_filter(undef);

               This method is chainable.

       filter(CODE)
               Allows you to install a callback to check that the pattern being
               loaded contains valid input. It receives a list on input, after
               it has been tokenised by the lexer. It may to return 0 or undef
               to indicate that the pattern should not be added, any true value
               indicates that the contents are fine.

               If you know that all patterns you expect to assemble contain a
               restricted set of of tokens (e.g. no spaces), you could do the
               following:

                 $ra-&gt;filter(sub { not grep { / / } @_ });

               or

                 sub only_spaces_and_digits {
                   not grep { ![\d ] } @_
                 }
                 $ra-&gt;filter( \&amp;only_spaces_and_digits );

               These two examples will silently ignore faulty patterns, If you
               want the user to be made aware of the problem you should raise an
               error (via &quot;warn&quot; or &quot;die&quot;), log an error message, whatever is
               best. If you want to remove a filter, pass &quot;undef&quot; as a
               parameter.

                 $ra-&gt;filter(undef);

               This method is chainable.

       as_string
               Assemble the expression and return it as a string. You may want
               to do this if you are writing the pattern to a file. The
               following arguments can be passed to control the aspect of the
               resulting pattern:

               indent, the number of spaces used to indent nested grouping of a
               pattern. Use this to produce a pretty-printed pattern (for some
               definition of &quot;pretty&quot;). The resulting output is rather verbose.
               The reason is to ensure that the metacharacters &quot;(?:&quot; and &quot;)&quot;
               always occur on otherwise empty lines. This allows you grep the
               result for an even more synthetic view of the pattern:

                 egrep -v &apos;^ *[()]&apos; &lt;regexp.file&gt;

               The result of the above is quite readable. Remember to backslash
               the spaces appearing in your own patterns if you wish to use an
               indented pattern in an &quot;m/.../x&quot; construct. Indenting is ignored
               if tracking is enabled.

               The indent argument takes precedence over the &quot;indent&quot;
               method/attribute of the object.

               Calling this method will drain the internal data structure. Large
               numbers of patterns can eat a significant amount of memory, and
               this lets perl recover the memory used for other purposes.

               If you want to reduce the pattern and continue to add new
               patterns, clone the object and reduce the clone, leaving the
               original object intact.

       re      Assembles the pattern and return it as a compiled RE, using the
               &quot;qr//&quot; operator.

               As with &quot;as_string&quot;, calling this method will reset the internal
               data structures to free the memory used in assembling the RE.

               The indent attribute, documented in the &quot;as_string&quot; method, can
               be used here (it will be ignored if tracking is enabled).

               With method chaining, it is possible to produce a RE without
               having a temporary &quot;Regexp::Assemble&quot; object lying around, e.g.:

                 my $re = Regexp::Assemble-&gt;new
                   -&gt;add( q[ab+cd+e] )
                   -&gt;add( q[ac\\d+e] )
                   -&gt;add( q[c\\d+e] )
                   -&gt;re;

               The $re variable now contains a Regexp object that can be used
               directly:

                 while( &lt;&gt; ) {
                   /$re/ and print &quot;Something in [$_] matched\n&quot;;
                 )

               The &quot;re&quot; method is called when the object is used in string
               context (hence, within an &quot;m//&quot; operator), so by and large you do
               not even need to save the RE in a separate variable. The
               following will work as expected:
&#12;                 my $re = Regexp::Assemble-&gt;new-&gt;add( qw[ fee fie foe fum ] );
                 while( &lt;IN&gt; ) {
                   if( /($re)/ ) {
                     print &quot;Here be giants: $1\n&quot;;
                   }
                 }

               This approach does not work with tracked patterns. The &quot;match&quot;
               and &quot;matched&quot; methods must be used instead, see below.

       match(SCALAR)
               The following information applies to Perl 5.8 and below. See the
               section that follows for information on Perl 5.10.

               If pattern tracking is in use, you must &quot;use re &apos;eval&apos;&quot; in order
               to make things work correctly. At a minimum, this will make your
               code look like this:

                   my $did_match = do { use re &apos;eval&apos;; $target =~ /$ra/ }
                   if( $did_match ) {
                       print &quot;matched &quot;, $ra-&gt;matched, &quot;\n&quot;;
                   }

               (The main reason is that the $^R variable is currently broken and
               an ugly workaround that runs some Perl code during the match is
               required, in order to simulate what $^R should be doing. See Perl
               bug #32840 for more information if you are curious. The README
               also contains more information). This bug has been fixed in 5.10.

               The important thing to note is that with &quot;use re &apos;eval&apos;&quot;, THERE
               ARE SECURITY IMPLICATIONS WHICH YOU IGNORE AT YOUR PERIL. The
               problem is this: if you do not have strict control over the
               patterns being fed to &quot;Regexp::Assemble&quot; when tracking is
               enabled, and someone slips you a pattern such as &quot;/^(?{system &apos;rm
               -rf /&apos;})/&quot; and you attempt to match a string against the
               resulting pattern, you will know Fear and Loathing.

               What is more, the $^R workaround means that that tracking does
               not work if you perform a bare &quot;/$re/&quot; pattern match as shown
               above. You have to instead call the &quot;match&quot; method, in order to
               supply the necessary context to take care of the tracking
               housekeeping details.

                  if( defined( my $match = $ra-&gt;match($_)) ) {
                      print &quot;  $_ matched by $match\n&quot;;
                  }

               In the case of a successful match, the original matched pattern
               is returned directly. The matched pattern will also be available
               through the &quot;matched&quot; method.

               (Except that the above is not true for 5.6.0: the &quot;match&quot; method
               returns true or undef, and the &quot;matched&quot; method always returns
               undef).

               If you are capturing parts of the pattern e.g. &quot;foo(bar)rat&quot; you
               will want to get at the captures. See the &quot;mbegin&quot;, &quot;mend&quot;,
               &quot;mvar&quot; and &quot;capture&quot; methods. If you are not using captures then
               you may safely ignore this section.

               In 5.10, since the bug concerning $^R has been resolved, there is
               no need to use &quot;re &apos;eval&apos;&quot; and the assembled pattern does not
               require any Perl code to be executed during the match.

       source  When using tracked mode, after a successful match is made,
               returns the original source pattern that caused the match. In
               Perl 5.10, the $^R variable can be used to as an index to fetch
               the correct pattern from the object.

               If no successful match has been performed, or the object is not
               in tracked mode, this method returns &quot;undef&quot;.

                 my $r = Regexp::Assemble-&gt;new-&gt;track(1)-&gt;add(qw(foo? bar{2} [Rr]at));

                 for my $w (qw(this food is rather barren)) {
                   if ($w =~ /$r/) {
                     print &quot;$w matched by &quot;, $r-&gt;source($^R), $/;
                   }
                   else {
                     print &quot;$w no match\n&quot;;
                   }
                 }

       mbegin  This method returns a copy of &quot;@-&quot; at the moment of the last
               match. You should ordinarily not need to bother with this, &quot;mvar&quot;
               should be able to supply all your needs.

       mend    This method returns a copy of &quot;@+&quot; at the moment of the last
               match.

       mvar(NUMBER)
               The &quot;mvar&quot; method returns the captures of the last match.
               mvar(1) corresponds to $1, mvar(2) to $2, and so on.  mvar(0)
               happens to return the target string matched, as a byproduct of
               walking down the &quot;@-&quot; and &quot;@+&quot; arrays after the match.

               If called without a parameter, &quot;mvar&quot; will return a reference to
               an array containing all captures.

       capture The &quot;capture&quot; method returns the the captures of the last match
               as an array. Unlink &quot;mvar&quot;, this method does not include the
               matched string. It is equivalent to getting an array back that
               contains &quot;$1, $2, $3, ...&quot;.

               If no captures were found in the match, an empty array is
               returned, rather than &quot;undef&quot;. You are therefore guaranteed to be
               able to use &quot;for my $c ($re-&gt;capture) { ...&quot;  without have to
               check whether anything was captured.

       matched If pattern tracking has been set, via the &quot;track&quot; attribute, or
               through the &quot;track&quot; method, this method will return the original
               pattern of the last successful match. Returns undef match has yet
               been performed, or tracking has not been enabled.

               See below in the NOTES section for additional subtleties of which
               you should be aware of when tracking patterns.

               Note that this method is not available in 5.6.0, due to
               limitations in the implementation of &quot;(?{...})&quot; at the time.

   Statistics/Reporting routines
       stats_add
               Returns the number of patterns added to the assembly (whether by
               &quot;add&quot; or &quot;insert&quot;). Duplicate patterns are not included in this
               total.

       stats_dup
               Returns the number of duplicate patterns added to the assembly.
               If non-zero, this may be a sign that something is wrong with your
               data (or at the least, some needless redundancy). This may occur
               when you have two patterns (for instance, &quot;a\-b&quot; and &quot;a-b&quot;) which
               map to the same result.

       stats_raw
               Returns the raw number of bytes in the patterns added to the
               assembly. This includes both original and duplicate patterns.
               For instance, adding the two patterns &quot;ab&quot; and &quot;ab&quot; will count as
               4 bytes.

       stats_cooked
               Return the true number of bytes added to the assembly. This will
               not include duplicate patterns. Furthermore, it may differ from
               the raw bytes due to quotemeta treatment. For instance,
               &quot;abc\,def&quot; will count as 7 (not 8) bytes, because &quot;\,&quot; will be
               stored as &quot;,&quot;. Also, &quot;\Qa.b\E&quot; is 7 bytes long, however, after
               the quotemeta directives are processed, &quot;a\.b&quot; will be stored,
               for a total of 4 bytes.

       stats_length
               Returns the length of the resulting assembled expression.  Until
               &quot;as_string&quot; or &quot;re&quot; have been called, the length will be 0 (since
               the assembly will have not yet been performed). The length
               includes only the pattern, not the additional (&quot;(?-xism...&quot;)
               fluff added by the compilation.

       dup_warn(NUMBER|CODEREF)
               Turns warnings about duplicate patterns on or off. By default, no
               warnings are emitted. If the method is called with no parameters,
               or a true parameter, the object will carp about patterns it has
               already seen. To turn off the warnings, use 0 as a parameter.

                 $r-&gt;dup_warn();

               The method may also be passed a code block. In this case the code
               will be executed and it will receive a reference to the object in
               question, and the lexed pattern.

                 $r-&gt;dup_warn(
                   sub {
                     my $self = shift;
                     print $self-&gt;stats_add, &quot; patterns added at line $.\n&quot;,
                         join( &apos;&apos;, @_ ), &quot; added previously\n&quot;;
                   }
                 )

   Anchor routines
       Suppose you wish to assemble a series of patterns that all begin with &quot;^&quot;
       and end with &quot;$&quot; (anchor pattern to the beginning and end of line).
       Rather than add the anchors to each and every pattern (and possibly
       forget to do so when a new entry is added), you may specify the anchors
       in the object, and they will appear in the resulting pattern, and you no
       longer need to (or should) put them in your source patterns. For example,
       the two following snippets will produce identical patterns:

         $r-&gt;add(qw(^this ^that ^them))-&gt;as_string;

         $r-&gt;add(qw(this that them))-&gt;anchor_line_begin-&gt;as_string;

         # both techniques will produce ^th(?:at|em|is)

       All anchors are possible word (&quot;\b&quot;) boundaries, line boundaries (&quot;^&quot; and
       &quot;$&quot;) and string boundaries (&quot;\A&quot; and &quot;\Z&quot; (or &quot;\z&quot; if you absolutely need
       it)).

       The shortcut &quot;anchor_mumble&quot; implies both &quot;anchor_mumble_begin&quot;
       &quot;anchor_mumble_end&quot; is also available. If different anchors are specified
       the most specific anchor wins. For instance, if both &quot;anchor_word_begin&quot;
       and &quot;anchor_line_begin&quot; are specified, &quot;anchor_word_begin&quot; takes
       precedence.

       All the anchor methods are chainable.

       anchor_word_begin
               The resulting pattern will be prefixed with a &quot;\b&quot; word boundary
               assertion when the value is true. Set to 0 to disable.

                 $r-&gt;add(&apos;pre&apos;)-&gt;anchor_word_begin-&gt;as_string;
                 # produces &apos;\bpre&apos;

       anchor_word_end
               The resulting pattern will be suffixed with a &quot;\b&quot; word boundary
               assertion when the value is true. Set to 0 to disable.

                 $r-&gt;add(qw(ing tion))
                   -&gt;anchor_word_end
                   -&gt;as_string; # produces &apos;(?:tion|ing)\b&apos;

       anchor_word
               The resulting pattern will be have &quot;\b&quot; word boundary assertions
               at the beginning and end of the pattern when the value is true.
               Set to 0 to disable.

                 $r-&gt;add(qw(cat carrot)
                   -&gt;anchor_word(1)
                   -&gt;as_string; # produces &apos;\bca(?:rro)t\b&apos;

       anchor_line_begin
               The resulting pattern will be prefixed with a &quot;^&quot; line boundary
               assertion when the value is true. Set to 0 to disable.

                 $r-&gt;anchor_line_begin;
                 # or
                 $r-&gt;anchor_line_begin(1);

       anchor_line_end
               The resulting pattern will be suffixed with a &quot;$&quot; line boundary
               assertion when the value is true. Set to 0 to disable.

                 # turn it off
                 $r-&gt;anchor_line_end(0);

       anchor_line
               The resulting pattern will be have the &quot;^&quot; and &quot;$&quot; line boundary
               assertions at the beginning and end of the pattern, respectively,
               when the value is true. Set to 0 to disable.

                 $r-&gt;add(qw(cat carrot)
                   -&gt;anchor_line
                   -&gt;as_string; # produces &apos;^ca(?:rro)t$&apos;

       anchor_string_begin
               The resulting pattern will be prefixed with a &quot;\A&quot; string
               boundary assertion when the value is true. Set to 0 to disable.

                 $r-&gt;anchor_string_begin(1);

       anchor_string_end
               The resulting pattern will be suffixed with a &quot;\Z&quot; string
               boundary assertion when the value is true. Set to 0 to disable.

                 # disable the string boundary end anchor
                 $r-&gt;anchor_string_end(0);

       anchor_string_end_absolute
               The resulting pattern will be suffixed with a &quot;\z&quot; string
               boundary assertion when the value is true. Set to 0 to disable.

                 # disable the string boundary absolute end anchor
                 $r-&gt;anchor_string_end_absolute(0);

               If you don&apos;t understand the difference between &quot;\Z&quot; and &quot;\z&quot;, the
               former will probably do what you want.

       anchor_string
               The resulting pattern will be have the &quot;\A&quot; and &quot;\Z&quot; string
               boundary assertions at the beginning and end of the pattern,
               respectively, when the value is true. Set to 0 to disable.

                 $r-&gt;add(qw(cat carrot)
                   -&gt;anchor_string
                   -&gt;as_string; # produces &apos;\Aca(?:rro)t\Z&apos;

       anchor_string_absolute
               The resulting pattern will be have the &quot;\A&quot; and &quot;\z&quot; string
               boundary assertions at the beginning and end of the pattern,
               respectively, when the value is true. Set to 0 to disable.

                 $r-&gt;add(qw(cat carrot)
                   -&gt;anchor_string_absolute
                   -&gt;as_string; # produces &apos;\Aca(?:rro)t\z&apos;

       debug(NUMBER)
               Turns debugging on or off. Statements are printed to the
               currently selected file handle (STDOUT by default).  If you are
               already using this handle, you will have to arrange to select an
               output handle to a file of your own choosing, before call the
               &quot;add&quot;, &quot;as_string&quot; or &quot;re&quot;) functions, otherwise it will scribble
               all over your carefully formatted output.

               0       Off. Turns off all debugging output.

               1       Add. Trace the addition of patterns.

               2       Reduce. Trace the process of reduction and assembly.

               4       Lex. Trace the lexing of the input patterns into its
                       constituent tokens.

               8       Time. Print to STDOUT the time taken to load all the
                       patterns. This is nothing more than the difference
                       between the time the object was instantiated and the time
                       reduction was initiated.

                         # load=&lt;num&gt;

                       Any lengthy computation performed in the client code will
                       be reflected in this value. Another line will be printed
                       after reduction is complete.

                         # reduce=&lt;num&gt;

                       The above output lines will be changed to &quot;load-epoch&quot;
                       and &quot;reduce-epoch&quot; if the internal state of the object is
                       corrupted and the initial timestamp is lost.

                       The code attempts to load Time::HiRes in order to report
                       fractional seconds. If this is not successful, the
                       elapsed time is displayed in whole seconds.

               Values can be added (or or&apos;ed together) to trace everything

                 $r-&gt;debug(7)-&gt;add( &apos;\\d+abc&apos; );

               Calling &quot;debug&quot; with no arguments turns debugging off.

       dump    Produces a synthetic view of the internal data structure. How to
               interpret the results is left as an exercise to the reader.

                 print $r-&gt;dump;

       chomp(0|1)
               Turns chomping on or off.

               IMPORTANT: As of version 0.24, chomping is now on by default as
               it makes &quot;add_file&quot; Just Work. The only time you may run into
               trouble is with &quot;add(&quot;\\$/&quot;)&quot;. So don&apos;t do that, or else
               explicitly turn off chomping.

               To avoid incorporating (spurious) record separators (such as &quot;\n&quot;
               on Unix) when reading from a file, &quot;add()&quot; &quot;chomp&quot;s its input. If
               you don&apos;t want this to happen, call &quot;chomp&quot; with a false value.

                 $re-&gt;chomp(0); # really want the record separators
                 $re-&gt;add(&lt;DATA&gt;);

       fold_meta_pairs(NUMBER)
               Determines whether &quot;\s&quot;, &quot;\S&quot; and &quot;\w&quot;, &quot;\W&quot; and &quot;\d&quot;, &quot;\D&quot; are
               folded into a &quot;.&quot; (dot). Folding happens by default (for reasons
               of backwards compatibility, even though it is wrong when the &quot;/s&quot;
               expression modifier is active).

               Call this method with a false value to prevent this behaviour
               (which is only a problem when dealing with &quot;\n&quot; if the &quot;/s&quot;
               expression modifier is also set).

                 $re-&gt;add( &apos;\\w&apos;, &apos;\\W&apos; );
                 my $clone = $re-&gt;clone;

                 $clone-&gt;fold_meta_pairs(0);
                 print $clone-&gt;as_string; # prints &apos;.&apos;
                 print $re-&gt;as_string;    # print &apos;[\W\w]&apos;

       indent(NUMBER)
               Sets the level of indent for pretty-printing nested groups within
               a pattern. See the &quot;as_string&quot; method for more details.  When
               called without a parameter, no indenting is performed.

                 $re-&gt;indent( 4 );
                 print $re-&gt;as_string;

       lookahead(0|1)
               Turns on zero-width lookahead assertions. This is usually
               beneficial when you expect that the pattern will usually fail.
               If you expect that the pattern will usually match you will
               probably be worse off.

       flags(STRING)
               Sets the flags that govern how the pattern behaves (for versions
               of Perl up to 5.9 or so, these are &quot;imsx&quot;). By default no flags
               are enabled.

       modifiers(STRING)
               An alias of the &quot;flags&quot; method, for users familiar with
               &quot;Regexp::List&quot;.

       track(0|1)
               Turns tracking on or off. When this attribute is enabled,
               additional housekeeping information is inserted into the
               assembled expression using &quot;({...}&quot; embedded code constructs.
               This provides the necessary information to determine which, of
               the original patterns added, was the one that caused the match.
&#12;                 $re-&gt;track( 1 );
                 if( $target =~ /$re/ ) {
                   print &quot;$target matched by &quot;, $re-&gt;matched, &quot;\n&quot;;
                 }

               Note that when this functionality is enabled, no reduction is
               performed and no character classes are generated. In other words,
               &quot;brag|tag&quot; is not reduced down to &quot;(?:br|t)ag&quot; and &quot;dig|dim&quot; is
               not reduced to &quot;di[gm]&quot;.

       unroll_plus(0|1)
               Turns the unrolling of plus metacharacters on or off. When a
               pattern is broken up, &quot;a+&quot; becomes &quot;a&quot;, &quot;a*&quot; (and &quot;b+?&quot; becomes
               &quot;b&quot;, &quot;b*?&quot;. This may allow the freed &quot;a&quot; to assemble with other
               patterns. Not enabled by default.

       lex(SCALAR)
               Change the pattern used to break a string apart into tokens.  You
               can examine the &quot;eg/naive&quot; script as a starting point.

       reduce(0|1)
               Turns pattern reduction on or off. A reduced pattern may be
               considerably shorter than an unreduced pattern. Consider
               &quot;/sl(?:ip|op|ap)/&quot; versus &quot;/sl[aio]p/&quot;. An unreduced pattern will
               be very similar to those produced by &quot;Regexp::Optimizer&quot;.
               Reduction is on by default. Turning it off speeds assembly (but
               assembly is pretty fast -- it&apos;s the breaking up of the initial
               patterns in the lexing stage that can consume a non-negligible
               amount of time).

       mutable(0|1)
               This method has been marked as DEPRECATED. It will be removed in
               a future release. See the &quot;clone&quot; method for a technique to
               replace its functionality.

       reset   Empties out the patterns that have been &quot;add&quot;ed or &quot;insert&quot;-ed
               into the object. Does not modify the state of controller
               attributes such as &quot;debug&quot;, &quot;lex&quot;, &quot;reduce&quot; and the like.

       Default_Lexer
               Warning: the &quot;Default_Lexer&quot; function is a class method, not an
               object method. It is a fatal error to call it as an object
               method.

               The &quot;Default_Lexer&quot; method lets you replace the default pattern
               used for all subsequently created &quot;Regexp::Assemble&quot; objects. It
               will not have any effect on existing objects. (It is also
               possible to override the lexer pattern used on a per-object
               basis).

               The parameter should be an ordinary scalar, not a compiled
               pattern. If the pattern fails to match all parts of the string,
               the missing parts will be returned as single chunks. Therefore
               the following pattern is legal (albeit rather cork-brained):

                   Regexp::Assemble::Default_Lexer( &apos;\\d&apos; );

               The above pattern will split up input strings digit by digit, and
               all non-digit characters as single chunks.

DIAGNOSTICS
         &quot;Cannot pass a C&lt;refname&gt; to Default_Lexer&quot;

       You tried to replace the default lexer pattern with an object instead of
       a scalar. Solution: You probably tried to call &quot;$obj-&gt;Default_Lexer&quot;.
       Call the qualified class method instead
       &quot;Regexp::Assemble::Default_Lexer&quot;.
&#12;         &quot;filter method not passed a coderef&quot;

         &quot;pre_filter method not passed a coderef&quot;

       A reference to a subroutine (anonymous or otherwise) was expected.
       Solution: read the documentation for the &quot;filter&quot; method.

         &quot;duplicate pattern added: /.../&quot;

       The &quot;dup_warn&quot; attribute is active, and a duplicate pattern was added
       (well duh!). Solution: clean your data.

         &quot;cannot open [file] for input: [reason]&quot;

       The &quot;add_file&quot; method was unable to open the specified file for whatever
       reason. Solution: make sure the file exists and the script has the
       required privileges to read it.

NOTES
       This module has been tested successfully with a range of versions of
       perl, from 5.005_03 to 5.9.3. Use of 5.6.0 is not recommended.

       The expressions produced by this module can be used with the PCRE
       library.

       Remember to &quot;double up&quot; your backslashes if the patterns are hard-coded
       as constants in your program. That is, you should literally
       &quot;add(&apos;a\\d+b&apos;)&quot; rather than &quot;add(&apos;a\d+b&apos;)&quot;. It usually will work either
       way, but it&apos;s good practice to do so.

       Where possible, supply the simplest tokens possible. Don&apos;t add
       &quot;X(?-\d+){2})Y&quot; when &quot;X-\d+-\d+Y&quot; will do. The reason is that if you also
       add &quot;X\d+Z&quot; the resulting assembly changes dramatically:
       &quot;X(?:(?:-\d+){2}Y|-\d+Z)&quot; versus &quot;X-\d+(?:-\d+Y|Z)&quot;. Since R::A doesn&apos;t
       perform enough analysis, it won&apos;t &quot;unroll&quot; the &quot;{2}&quot; quantifier, and will
       fail to notice the divergence after the first &quot;-d\d+&quot;.

       Furthermore, when the string &apos;X-123000P&apos; is matched against the first
       assembly, the regexp engine will have to backtrack over each alternation
       (the one that ends in Y and the one that ends in Z) before determining
       that there is no match. No such backtracking occurs in the second
       pattern: as soon as the engine encounters the &apos;P&apos; in the target string,
       neither of the alternations at that point (&quot;-\d+Y&quot; or &quot;Z&quot;) could succeed
       and so the match fails.

       &quot;Regexp::Assemble&quot; does, however, know how to build character classes.
       Given &quot;a-b&quot;, &quot;axb&quot; and &quot;a\db&quot;, it will assemble these into &quot;a[-\dx]b&quot;.
       When &quot;-&quot; (dash) appears as a candidate for a character class it will be
       the first character in the class. When &quot;^&quot; (circumflex) appears as a
       candidate for a character class it will be the last character in the
       class.

       It also knows about meta-characters than can &quot;absorb&quot; regular characters.
       For instance, given &quot;X\d&quot; and &quot;X5&quot;, it knows that 5 can be represented by
       &quot;\d&quot; and so the assembly is just &quot;X\d&quot;.  The &quot;absorbent&quot; meta-characters
       it deals with are &quot;.&quot;, &quot;\d&quot;, &quot;\s&quot; and &quot;\W&quot; and their complements. It will
       replace &quot;\d&quot;/&quot;\D&quot;, &quot;\s&quot;/&quot;\S&quot; and &quot;\w&quot;/&quot;\W&quot; by &quot;.&quot; (dot), and it will drop
       &quot;\d&quot; if &quot;\w&quot; is also present (as will &quot;\D&quot; in the presence of &quot;\W&quot;).

       &quot;Regexp::Assemble&quot; deals correctly with &quot;quotemeta&quot;&apos;s propensity to
       backslash many characters that have no need to be. Backslashes on non-
       metacharacters will be removed. Similarly, in character classes, a number
       of characters lose their magic and so no longer need to be backslashed
       within a character class. Two common examples are &quot;.&quot;  (dot) and &quot;$&quot;.
       Such characters will lose their backslash.

       At the same time, it will also process &quot;\Q...\E&quot; sequences. When such a
       sequence is encountered, the inner section is extracted and &quot;quotemeta&quot;
       is applied to the section. The resulting quoted text is then used in
       place of the original unquoted text, and the &quot;\Q&quot; and &quot;\E&quot; metacharacters
       are thrown away. Similar processing occurs with the &quot;\U...\E&quot; and
       &quot;\L...\E&quot; sequences. This may have surprising effects when using a
       dispatch table. In this case, you will need to know exactly what the
       module makes of your input. Use the &quot;lexstr&quot; method to find out what&apos;s
       going on:

         $pattern = join( &apos;&apos;, @{$re-&gt;lexstr($pattern)} );

       If all the digits 0..9 appear in a character class, &quot;Regexp::Assemble&quot;
       will replace them by &quot;\d&quot;. I&apos;d do it for letters as well, but thinking
       about accented characters and other glyphs hurts my head.

       In an alternation, the longest paths are chosen first (for example,
       &quot;horse|bird|dog&quot;). When two paths have the same length, the path with the
       most subpaths will appear first. This aims to put the &quot;busiest&quot; paths to
       the front of the alternation. For example, the list &quot;bad&quot;, &quot;bit&quot;, &quot;few&quot;,
       &quot;fig&quot; and &quot;fun&quot; will produce the pattern &quot;(?:f(?:ew|ig|un)|b(?:ad|it))&quot;.
       See eg/tld for a real-world example of how alternations are sorted. Once
       you have looked at that, everything should be crystal clear.

       When tracking is in use, no reduction is performed. nor are character
       classes formed. The reason is that it is too difficult to determine the
       original pattern afterwards. Consider the two patterns &quot;pale&quot; and &quot;palm&quot;.
       These should be reduced to &quot;pal[em]&quot;. The final character matches one of
       two possibilities.  To resolve whether it matched an &apos;e&apos; or &apos;m&apos; would
       require keeping track of the fact that the pattern finished up in a
       character class, which would the require a whole lot more work to figure
       out which character of the class matched. Without character classes it
       becomes much easier. Instead, &quot;pal(?:e|m)&quot; is produced, which lets us
       find out more simply where we ended up.

       Similarly, &quot;dogfood&quot; and &quot;seafood&quot; should form &quot;(?:dog|sea)food&quot;.  When
       the pattern is being assembled, the tracking decision needs to be made at
       the end of the grouping, but the tail of the pattern has not yet been
       visited. Deferring things to make this work correctly is a vast hassle.
       In this case, the pattern becomes merely &quot;(?:dogfood|seafood&quot;. Tracked
       patterns will therefore be bulkier than simple patterns.

       There is an open bug on this issue:

       &lt;http://rt.perl.org/rt3/Ticket/Display.html?id=32840&gt;

       If this bug is ever resolved, tracking would become much easier to deal
       with (none of the &quot;match&quot; hassle would be required - you could just match
       like a regular RE and it would Just Work).

SEE ALSO
       perlre  General information about Perl&apos;s regular expressions.

       re      Specific information about &quot;use re &apos;eval&apos;&quot;.

       Regex::PreSuf
               &quot;Regex::PreSuf&quot; takes a string and chops it itself into tokens of
               length 1. Since it can&apos;t deal with tokens of more than one
               character, it can&apos;t deal with meta-characters and thus no regular
               expressions.  Which is the main reason why I wrote this module.

       Regexp::Optimizer
               &quot;Regexp::Optimizer&quot; produces regular expressions that are similar
               to those produced by R::A with reductions switched off. It&apos;s
               biggest drawback is that it is exponentially slower than
               Regexp::Assemble on very large sets of patterns.

       Regexp::Parser
               Fine grained analysis of regular expressions.
&#12;       Regexp::Trie
               Funnily enough, this was my working name for &quot;Regexp::Assemble&quot;
               during its development. I changed the name because I thought it
               was too obscure. Anyway, &quot;Regexp::Trie&quot; does much the same as
               &quot;Regexp::Optimizer&quot; and &quot;Regexp::Assemble&quot; except that it runs
               much faster (according to the author). It does not recognise meta
               characters (that is, &apos;a+b&apos; is interpreted as &apos;a\+b&apos;).

       Text::Trie
               &quot;Text::Trie&quot; is well worth investigating. Tries can outperform
               very bushy (read: many alternations) patterns.

       Tree::Trie
               &quot;Tree::Trie&quot; is another module that builds tries. The algorithm
               that &quot;Regexp::Assemble&quot; uses appears to be quite similar to the
               algorithm described therein, except that &quot;R::A&quot; solves its end-
               marker problem without having to rewrite the leaves.

LIMITATIONS
       &quot;Regexp::Assemble&quot; does not attempt to find common substrings. For
       instance, it will not collapse &quot;/cabababc/&quot; down to &quot;/c(?:ab){3}c/&quot;.  If
       there&apos;s a module out there that performs this sort of string analysis I&apos;d
       like to know about it. But keep in mind that the algorithms that do this
       are very expensive: quadratic or worse.

       &quot;Regexp::Assemble&quot; does not interpret meta-character modifiers.  For
       instance, if the following two patterns are given: &quot;X\d&quot; and &quot;X\d+&quot;, it
       will not determine that &quot;\d&quot; can be matched by &quot;\d+&quot;. Instead, it will
       produce &quot;X(?:\d|\d+)&quot;. Along a similar line of reasoning, it will not
       determine that &quot;Z&quot; and &quot;Z\d+&quot; is equivalent to &quot;Z\d*&quot; (It will produce
       &quot;Z(?:\d+)?&quot;  instead).

       You cannot remove a pattern that has been added to an object. You&apos;ll just
       have to start over again. Adding a pattern is difficult enough, I&apos;d need
       a solid argument to convince me to add a &quot;remove&quot; method.  If you need to
       do this you should read the documentation for the &quot;clone&quot; method.

       &quot;Regexp::Assemble&quot; does not (yet)? employ the &quot;(?&gt;...)&quot;  construct.

       The module does not produce POSIX-style regular expressions. This would
       be quite easy to add, if there was a demand for it.

BUGS
       Patterns that generate look-ahead assertions sometimes produce incorrect
       patterns in certain obscure corner cases. If you suspect that this is
       occurring in your pattern, disable lookaheads.

       Tracking doesn&apos;t really work at all with 5.6.0. It works better in
       subsequent 5.6 releases. For maximum reliability, the use of a 5.8
       release is strongly recommended. Tracking barely works with 5.005_04. Of
       note, using &quot;\d&quot;-style meta-characters invariably causes panics. Tracking
       really comes into its own in Perl 5.10.

       If you feed &quot;Regexp::Assemble&quot; patterns with nested parentheses, there is
       a chance that the resulting pattern will be uncompilable due to
       mismatched parentheses (not enough closing parentheses). This is normal,
       so long as the default lexer pattern is used. If you want to find out
       which pattern among a list of 3000 patterns are to blame (speaking from
       experience here), the eg/debugging script offers a strategy for
       pinpointing the pattern at fault. While you may not be able to use the
       script directly, the general approach is easy to implement.

       The algorithm used to assemble the regular expressions makes extensive
       use of mutually-recursive functions (that is, A calls B, B calls A, ...)
       For deeply similar expressions, it may be possible to provoke &quot;Deep
       recursion&quot; warnings.

       The module has been tested extensively, and has an extensive test suite
       (that achieves close to 100% statement coverage), but you never know...
       A bug may manifest itself in two ways: creating a pattern that cannot be
       compiled, such as &quot;a\(bc)&quot;, or a pattern that compiles correctly but that
       either matches things it shouldn&apos;t, or doesn&apos;t match things it should. It
       is assumed that Such problems will occur when the reduction algorithm
       encounters some sort of edge case. A temporary work-around is to disable
       reductions:

         my $pattern = $assembler-&gt;reduce(0)-&gt;re;

       A discussion about implementation details and where bugs might lurk
       appears in the README file. If this file is not available locally, you
       should be able to find a copy on the Web at your nearest CPAN mirror.

       Seriously, though, a number of people have been using this module to
       create expressions anywhere from 140Kb to 600Kb in size, and it seems to
       be working according to spec. Thus, I don&apos;t think there are any serious
       bugs remaining.

       If you are feeling brave, extensive debugging traces are available to
       figure out where assembly goes wrong.

       Please report all bugs at
       http://rt.cpan.org/NoAuth/Bugs.html?Dist=Regexp-Assemble
       &lt;http://rt.cpan.org/NoAuth/Bugs.html?Dist=Regexp-Assemble&gt;

       Make sure you include the output from the following two commands:

         perl -MRegexp::Assemble -le &apos;print $Regexp::Assemble::VERSION&apos;
         perl -V

       There is a mailing list for the discussion of &quot;Regexp::Assemble&quot;.
       Subscription details are available at
       http://listes.mongueurs.net/mailman/listinfo/regexp-assemble
       &lt;http://listes.mongueurs.net/mailman/listinfo/regexp-assemble&gt;.

ACKNOWLEDGEMENTS
       This module grew out of work I did building access maps for Postfix, a
       modern SMTP mail transfer agent. See &lt;http://www.postfix.org/&gt; for more
       information. I used Perl to build large regular expressions for blocking
       dynamic/residential IP addresses to cut down on spam and viruses. Once I
       had the code running for this, it was easy to start adding stuff to block
       really blatant spam subject lines, bogus HELO strings, spammer mailer-ids
       and more...

       I presented the work at the French Perl Workshop in 2004, and the thing
       most people asked was whether the underlying mechanism for assembling the
       REs was available as a module. At that time it was nothing more that a
       twisty maze of scripts, all different. The interest shown indicated that
       a module was called for. I&apos;d like to thank the people who showed
       interest. Hey, it&apos;s going to make my messy scripts smaller, in any case.

       Thomas Drugeon was a valuable sounding board for trying out early ideas.
       Jean Forget and Philippe Blayo looked over an early version. H.Merijn
       Brandt stopped over in Paris one evening, and discussed things over a few
       beers.

       Nicholas Clark pointed out that while what this module does (?:c|sh)ould
       be done in perl&apos;s core, as per the 2004 TODO, he encouraged me to
       continue with the development of this module. In any event, this module
       allows one to gauge the difficulty of undertaking the endeavour in C. I&apos;d
       rather gouge my eyes out with a blunt pencil.

       Paul Johnson settled the question as to whether this module should live
       in the Regex:: namespace, or Regexp:: namespace. If you&apos;re not convinced,
       try running the following one-liner:

         perl -le &apos;print ref qr//&apos;
&#12;       Philippe Bruhat found a couple of corner cases where this module could
       produce incorrect results. Such feedback is invaluable, and only improves
       the module&apos;s quality.

AUTHOR
       David Landgren

       Copyright (C) 2004-2011. All rights reserved.

         http://www.landgren.net/perl/

       If you use this module, I&apos;d love to hear about what you&apos;re using it for.
       If you want to be informed of updates, send me a note.

       You can look at the latest working copy in the following Subversion
       repository:

         http://svnweb.mongueurs.net/Regexp-Assemble

LICENSE
       This library is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.



perl v5.14.2                       2012-06-30                      Assemble(3pm)

</pre></body></html>
