<html>
<head><meta charset=utf-8/>
<title>SDL_PixelFormat - Stores surface format information</title></head>
<body><pre>

SDL_PixelFormat(3)              SDL API Reference             SDL_PixelFormat(3)



NAME
       SDL_PixelFormat - Stores surface format information

STRUCTURE DEFINITION
       typedef struct SDL_PixelFormat {
         SDL_Palette *palette;
         Uint8  BitsPerPixel;
         Uint8  BytesPerPixel;
         Uint8  Rloss, Gloss, Bloss, Aloss;
         Uint8  Rshift, Gshift, Bshift, Ashift;
         Uint32 Rmask, Gmask, Bmask, Amask;
         Uint32 colorkey;
         Uint8  alpha;
       } SDL_PixelFormat;

STRUCTURE DATA
       palette             Pointer to the palette, or NULL if the BitsPerPixel&gt;8

       BitsPerPixel        The  number of bits used to represent each pixel in a
                           surface. Usually 8, 16, 24 or 32.

       BytesPerPixel       The number of bytes used to represent each pixel in a
                           surface. Usually one to four.

       [RGBA]mask          Binary mask used to retrieve individual color values

       [RGBA]loss          Precision loss of each color component (2^[RGBA]loss)

       [RGBA]shift         Binary  left  shift  of  each  color component in the
                           pixel value

       colorkey            Pixel value of transparent pixels

       alpha               Overall surface alpha value

DESCRIPTION
       A SDL_PixelFormat describes the format of the pixel data  stored  at  the
       pixels  field of a SDL_Surface. Every surface stores a SDL_PixelFormat in
       the format field.

       If you wish to do pixel level modifications on  a  surface,  then  under&#8208;
       standing how SDL stores its color information is essential.

       8-bit  pixel  formats  are  the easiest to understand. Since its an 8-bit
       format, we have 8 BitsPerPixel and 1 BytesPerPixel.  Since  BytesPerPixel
       is  1, all pixels are represented by a Uint8 which contains an index into
       palette-&gt;colors. So, to determine the color of a pixel in  a  8-bit  sur&#8208;
       face:  we read the color index from surface-&gt;pixels and we use that index
       to read the SDL_Color  structure  from  surface-&gt;format-&gt;palette-&gt;colors.
       Like so:

       SDL_Surface *surface;
       SDL_PixelFormat *fmt;
       SDL_Color *color;
       Uint8 index;

       .
       .

       /* Create surface */
       .
       .
       fmt=surface-&gt;format;

       /* Check the bitdepth of the surface */
       if(fmt-&gt;BitsPerPixel!=8){
         fprintf(stderr, &quot;Not an 8-bit surface.
       &quot;);
         return(-1);
       }

       /* Lock the surface */
       SDL_LockSurface(surface);

       /* Get the topleft pixel */
       index=*(Uint8 *)surface-&gt;pixels;
       color=fmt-&gt;palette-&gt;colors[index];

       /* Unlock the surface */
       SDL_UnlockSurface(surface);
       printf(&quot;Pixel Color-&gt; Red: %d, Green: %d, Blue: %d. Index: %d
       &quot;,
                 color-&gt;r, color-&gt;g, color-&gt;b, index);
       .
       .

       Pixel  formats above 8-bit are an entirely different experience. They are
       considered to be &quot;TrueColor&quot; formats and the color information is  stored
       in  the  pixels  themselves,  not  in a palette. The mask, shift and loss
       fields tell us how the color information  is  encoded.  The  mask  fields
       allow  us  to  isolate each color component, the shift fields tell us the
       number of bits to the right of each component in the pixel value and  the
       loss  fields  tell  us  the  number of bits lost from each component when
       packing 8-bit color component in a pixel.

       /* Extracting color components from a 32-bit color value */
       SDL_PixelFormat *fmt;
       SDL_Surface *surface;
       Uint32 temp, pixel;
       Uint8 red, green, blue, alpha;
       .
       .
       .
       fmt=surface-&gt;format;
       SDL_LockSurface(surface);
       pixel=*((Uint32*)surface-&gt;pixels);
       SDL_UnlockSurface(surface);

       /* Get Red component */
       temp=pixel&amp;fmt-&gt;Rmask; /* Isolate red component */
       temp=temp&gt;&gt;fmt-&gt;Rshift;/* Shift it down to 8-bit */
       temp=temp&lt;&lt;fmt-&gt;Rloss; /* Expand to a full 8-bit number */
       red=(Uint8)temp;

       /* Get Green component */
       temp=pixel&amp;fmt-&gt;Gmask; /* Isolate green component */
       temp=temp&gt;&gt;fmt-&gt;Gshift;/* Shift it down to 8-bit */
       temp=temp&lt;&lt;fmt-&gt;Gloss; /* Expand to a full 8-bit number */
       green=(Uint8)temp;

       /* Get Blue component */
       temp=pixel&amp;fmt-&gt;Bmask; /* Isolate blue component */
       temp=temp&gt;&gt;fmt-&gt;Bshift;/* Shift it down to 8-bit */
       temp=temp&lt;&lt;fmt-&gt;Bloss; /* Expand to a full 8-bit number */
       blue=(Uint8)temp;

       /* Get Alpha component */
       temp=pixel&amp;fmt-&gt;Amask; /* Isolate alpha component */
       temp=temp&gt;&gt;fmt-&gt;Ashift;/* Shift it down to 8-bit */
       temp=temp&lt;&lt;fmt-&gt;Aloss; /* Expand to a full 8-bit number */
       alpha=(Uint8)temp;

       printf(&quot;Pixel Color -&gt; R: %d,  G: %d,  B: %d,  A: %d
       &quot;, red, green, blue, alpha);
       .
       .
       .

SEE ALSO
       SDL_Surface, SDL_MapRGB



SDL                          Tue 11 Sep 2001, 23:01           SDL_PixelFormat(3)

</pre></body></html>
