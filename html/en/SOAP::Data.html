<html>
<head><meta charset=utf-8/>
<title>SOAP::Data - this class provides the means by which to explicitly manipulate and control all aspects of the way in which Perl data gets expressed as SOAP data entities.</title></head>
<body><pre>

SOAP::Data(3pm)        User Contributed Perl Documentation       SOAP::Data(3pm)



NAME
       SOAP::Data - this class provides the means by which to explicitly
       manipulate and control all aspects of the way in which Perl data gets
       expressed as SOAP data entities.

DESCRIPTION
       The SOAP::Data class provides the means by which to explicitly manipulate
       and control all aspects of the way in which Perl data gets expressed as
       SOAP data entities. Most of the methods are accessors, which like those
       in SOAP::Lite are designed to return the current value if no new one is
       passed, while returning the object reference otherwise (allowing for
       chained method calls). Note that most accessors (except value) accept a
       new value for the data object as a second argument.

METHODS
       new(optional key/value pairs)
               $obj = SOAP::Data-&gt;new(name =&gt; &apos;idx&apos;, value =&gt; 5);

           This is the class constructor. Almost all of the attributes related
           to the class may be passed to the constructor as key/value pairs.
           This method isn&apos;t often used directly because SOAP::Data objects are
           generally created for temporary use. It is available for those
           situations that require it.

       name(new name, optional value)
               $obj-&gt;name(&apos;index&apos;);

           Gets or sets the current value of the name, as the object regards it.
           The name is what the serializer will use for the tag when generating
           the XML for this object. It is what will become the accessor for the
           data element. Optionally, the object&apos;s value may be updated if passed
           as a second argument.

       type(new type, optional value)
               $obj-&gt;type(&apos;int&apos;);

           Gets or sets the type associated with the current value in the
           object. This is useful for those cases where the SOAP::Data object is
           used to explicitly specify the type of data that would otherwise be
           interpreted as a different type completely (such as perceiving the
           string 123 as an integer, instead). Allows the setting of the
           object&apos;s value, if passed as a second argument to the method.

       uri(new uri, optional value)
               $obj-&gt;uri(&apos;http://www.perl.com/SOAP&apos;);

           Gets or sets the URI that will be used as the namespace for the
           resulting XML entity, if one is desired. This doesn&apos;t set the label
           for the namespace. If one isn&apos;t provided by means of the prefix
           method, one is generated automatically when needed. Also allows the
           setting of the object&apos;s value, if passed as a second argument to the
           method.

       prefix(new prefix, optional value)
               $obj-&gt;prefix(&apos;perl&apos;);

           Provides the prefix, or label, for use when associating the data
           object with a specific namespace. Also allows the setting of the
           object&apos;s value, if passed as a second argument to the method.

       attr(hash reference of attributes, optional value)
               $obj-&gt;attr({ attr1 =&gt; &apos;value&apos; });
&#12;           Allows for the setting of arbitrary attributes on the data object.
           Keep in mind the requirement that any attributes not natively known
           to SOAP must be namespace-qualified. Also allows the setting of the
           object&apos;s value, if passed as a second argument to the method.

       value(new value)
               $obj-&gt;value(10);

           Fetches the current value encapsulated by the object, or explicitly
           sets it.

       The last four methods are convenience shortcuts for the attributes that
       SOAP itself supports. Each also permits inclusion of a new value, as an
       optional second argument.

       actor(new actor, optional value)
               $obj-&gt;actor($new_actor_name);

           Gets or sets the value of the actor attribute; useful only when the
           object generates an entity for the message header.

       mustUnderstand(boolean, optional value)
               $obj-&gt;mustUnderstand(0);

           Manipulates the mustUnderstand attribute, which tells the SOAP
           processor whether it is required to understand the entity in
           question.

       encodingStyle(new encoding URN, optional value)
               $obj-&gt;encodingStyle($soap_11_encoding);

           This method is most likely to be used in places outside the header
           creation. Sets encodingStyle, which specifies an encoding that
           differs from the one that would otherwise be defaulted to.

       root(boolean, optional value)
               $obj-&gt;root(1);

           When the application must explicitly specify which data element is to
           be regarded as the root element for the sake of generating the object
           model, this method provides the access to the root attribute.

TYPE DETECTION
       SOAP::Lite&apos;s serializer will detect the type of any scalar passed in as a
       SOAP::Data object&apos;s value. Because Perl is loosely typed, the serializer
       is only able to detect types based upon a predetermined set of regular
       expressions. Therefore, type detection is not always 100% accurate. In
       such a case you may need to explicitly set the type of the element being
       encoded. For example, by default the following code will be serialized as
       an integer:

         $elem = SOAP::Data-&gt;name(&apos;idx&apos;)-&gt;value(5);

       If, however, you need to serialize this into a long, then the following
       code will do so:

         $elem = SOAP::Data-&gt;name(&apos;idx&apos;)-&gt;value(5)-&gt;type(&apos;long&apos;);

EXAMPLES
   SIMPLE TYPES
       The following example will all produce the same XML:

           $elem1 = SOAP::Data-&gt;new(name =&gt; &apos;idx&apos;, value =&gt; 5);
           $elem2 = SOAP::Data-&gt;name(&apos;idx&apos; =&gt; 5);
           $elem3 = SOAP::Data-&gt;name(&apos;idx&apos;)-&gt;value(5);

   COMPLEX TYPES
       A common question is how to do you created nested XML elements using
       SOAP::Lite. The following example demonstrates how:

           SOAP::Data-&gt;name(&apos;foo&apos; =&gt; \SOAP::Data-&gt;value(
               SOAP::Data-&gt;name(&apos;bar&apos; =&gt; &apos;123&apos;)));

       The above code will produce the following XML:

           &lt;foo&gt;
             &lt;bar&gt;123&lt;/bar&gt;
           &lt;/foo&gt;

   ARRAYS
       The following code:

           $elem1 = SOAP::Data-&gt;name(&apos;item&apos; =&gt; 123)-&gt;type(&apos;SomeObject&apos;);
           $elem2 = SOAP::Data-&gt;name(&apos;item&apos; =&gt; 456)-&gt;type(&apos;SomeObject&apos;);
           push(@array,$elem1);
           push(@array,$elem2);

           my $client = SOAP::Lite
               -&gt;readable(1)
               -&gt;uri($NS)
               -&gt;proxy($HOST);

           $temp_elements = SOAP::Data
               -&gt;name(&quot;CallDetails&quot; =&gt; \SOAP::Data-&gt;value(
                     SOAP::Data-&gt;name(&quot;elem1&quot; =&gt; &apos;foo&apos;),
                     SOAP::Data-&gt;name(&quot;elem2&quot; =&gt; &apos;baz&apos;),
                     SOAP::Data-&gt;name(&quot;someArray&quot; =&gt; \SOAP::Data-&gt;value(
                         SOAP::Data-&gt;name(&quot;someArrayItem&quot; =&gt; @array)
                                   -&gt;type(&quot;SomeObject&quot;))
                              )-&gt;type(&quot;ArrayOf_SomeObject&quot;) ))

           -&gt;type(&quot;SomeObject&quot;);

           $response = $client-&gt;someMethod($temp_elements);

       Will produce the following XML:

           &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
           &lt;SOAP-ENV:Envelope
               xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
               xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;
               xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;
               xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
               xmlns:namesp2=&quot;http://namespaces.soaplite.com/perl&quot;
               SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;
             &lt;SOAP-ENV:Body&gt;
               &lt;namesp1:someMethod xmlns:namesp1=&quot;urn:TemperatureService&quot;&gt;
                 &lt;CallDetails xsi:type=&quot;namesp2:SomeObject&quot;&gt;
                   &lt;elem1 xsi:type=&quot;xsd:string&quot;&gt;foo&lt;/elem1&gt;
                   &lt;elem2 xsi:type=&quot;xsd:string&quot;&gt;baz&lt;/elem2&gt;
                   &lt;someArray xsi:type=&quot;namesp2:ArrayOf_SomeObject&quot;&gt;
                     &lt;item xsi:type=&quot;namesp2:SomeObject&quot;&gt;123&lt;/bar&gt;
                     &lt;item xsi:type=&quot;namesp2:SomeObject&quot;&gt;456&lt;/bar&gt;
                   &lt;/someArray&gt;
                 &lt;/CallDetails&gt;
               &lt;/namesp1:test&gt;
             &lt;/SOAP-ENV:Body&gt;
           &lt;/SOAP-ENV:Envelope&gt;

       In the code above, the @array variable can be an array of anything. If
       you pass in an array of numbers, then SOAP::Lite will properly serialize
       that into such.  If however you need to encode an array of complex types,
       then simply pass in an array of other SOAP::Data objects and you are all
       set.

   COMPOSING MESSAGES USING RAW XML
       In some circumstances you may need to encode a message using raw
       unserialized XML text. To instantiate a SOAP::Data object using raw XML,
       do the following:

           $xml_content = &quot;&lt;foo&gt;&lt;bar&gt;123&lt;/bar&gt;&lt;/foo&gt;&quot;;
           $elem = SOAP::Data-&gt;type(&apos;xml&apos; =&gt; $xml_content);

       SOAP::Lite&apos;s serializer simple takes whatever text is passed to it, and
       inserts into the encoded SOAP::Data element verbatim. The text input is
       NOT validated to ensure it is valid XML, nor is the resulting SOAP::Data
       element validated to ensure that it will produce valid XML. Therefore, it
       is incumbent upon the developer to ensure that any XML data used in this
       fashion is valid and will result in a valid XML document.

   MULTIPLE NAMESPACES
       When working with complex types it may be necessary to declare multiple
       namespaces. The following code demonstrates how to do so:

           $elem = SOAP::Data-&gt;name(&quot;myElement&quot; =&gt; &quot;myValue&quot;)
                             -&gt;attr( { &apos;xmlns:foo2&apos; =&gt; &apos;urn:Foo2&apos;,
                                       &apos;xmlns:foo3&apos; =&gt; &apos;urn:Foo3&apos; } );

       This will produce the following XML:

           &lt;myElement xmlns:foo2=&quot;urn:Foo2&quot; xmlns:foo3=&quot;urn:Foo3&quot;&gt;myValue&lt;/myElement&gt;

SEE ALSO
       SOAP::Header, SOAP::SOM, SOAP::Serializer

ACKNOWLEDGEMENTS
       Special thanks to O&apos;Reilly publishing which has graciously allowed
       SOAP::Lite to republish and redistribute large excerpts from Programming
       Web Services with Perl, mainly the SOAP::Lite reference found in Appendix
       B.

COPYRIGHT
       Copyright (C) 2000-2004 Paul Kulchenko. All rights reserved.

       This library is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.

AUTHORS
       Paul Kulchenko (paulclinger@yahoo.com)

       Randy J. Ray (rjray@blackperl.com)

       Byrne Reese (byrne@majordojo.com)



perl v5.12.4                       2011-08-15                    SOAP::Data(3pm)

</pre></body></html>
