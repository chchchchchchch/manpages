<html>
<head><meta charset=utf-8/>
<title>SOAP::Lite - Perl's Web Services Toolkit</title></head>
<body><pre>

SOAP::Lite(3pm)        User Contributed Perl Documentation       SOAP::Lite(3pm)



NAME
       SOAP::Lite - Perl&apos;s Web Services Toolkit

DESCRIPTION
       SOAP::Lite is a collection of Perl modules which provides a simple and
       lightweight interface to the Simple Object Access Protocol (SOAP) both on
       client and server side.

PERL VERSION WARNING
       SOAP::Lite 0.71 will be the last version of SOAP::Lite running on perl
       5.005

       Future versions of SOAP::Lite will require at least perl 5.6.0

       If you have not had the time to upgrad your perl, you should consider
       this now.

OVERVIEW OF CLASSES AND PACKAGES
       lib/SOAP/Lite.pm
           SOAP::Lite - Main class provides all logic

           SOAP::Transport - Transport backend

           SOAP::Data - Data objects

           SOAP::Header - Header Data Objects

           SOAP::Serializer - Serializes data structures to SOAP messages

           SOAP::Deserializer - Deserializes SOAP messages into SOAP::SOM
           objects

           SOAP::SOM - SOAP Message objects

           SOAP::Constants - Provides access to common constants and defaults

           SOAP::Trace - Tracing facilities

           SOAP::Schema - Provides access and stub(s) for schema(s)

           SOAP::Schema::WSDL - WSDL implementation for SOAP::Schema

           SOAP::Server - Handles requests on server side

           SOAP::Server::Object - Handles objects-by-reference

           SOAP::Fault - Provides support for Faults on server side

           SOAP::Utils - A set of private and public utility subroutines

       lib/SOAP/Packager.pm
           SOAP::Packager - Provides an abstract class for implementing custom
           packagers.

           SOAP::Packager::MIME - Provides MIME support to SOAP::Lite

           SOAP::Packager::DIME - Provides DIME support to SOAP::Lite

       lib/SOAP/Transport/HTTP.pm
           SOAP::Transport::HTTP::Client - Client interface to HTTP transport

           SOAP::Transport::HTTP::Server - Server interface to HTTP transport

           SOAP::Transport::HTTP::CGI - CGI implementation of server interface

           SOAP::Transport::HTTP::Daemon - Daemon implementation of server
           interface

           SOAP::Transport::HTTP::Apache - mod_perl implementation of server
           interface

       lib/SOAP/Transport/POP3.pm
           SOAP::Transport::POP3::Server - Server interface to POP3 protocol

       lib/SOAP/Transport/MAILTO.pm
           SOAP::Transport::MAILTO::Client - Client interface to SMTP/sendmail

       lib/SOAP/Transport/LOCAL.pm
           SOAP::Transport::LOCAL::Client - Client interface to local transport

       lib/SOAP/Transport/TCP.pm
           SOAP::Transport::TCP::Server - Server interface to TCP protocol

           SOAP::Transport::TCP::Client - Client interface to TCP protocol

       lib/SOAP/Transport/IO.pm
           SOAP::Transport::IO::Server - Server interface to IO transport

METHODS
       All accessor methods return the current value when called with no
       arguments, while returning the object reference itself when called with a
       new value.  This allows the set-attribute calls to be chained together.

       new(optional key/value pairs)
               $client = SOAP::Lite-&gt;new(proxy =&gt; $endpoint)

           Constructor. Many of the accessor methods defined here may be
           initialized at creation by providing their name as a key, followed by
           the desired value.  The example provides the value for the proxy
           element of the client.

       transport(optional transport object)
               $transp = $client-&gt;transport( );

           Gets or sets the transport object used for sending/receiving SOAP
           messages.

           See SOAP::Transport for details.

       serializer(optional serializer object)
               $serial = $client-&gt;serializer( )

           Gets or sets the serializer object used for creating XML messages.

           See SOAP::Serializer for details.

       packager(optional packager object)
               $packager = $client-&gt;packager( )

           Provides access to the &quot;SOAP::Packager&quot; object that the client uses
           to manage the use of attachments. The default packager is a MIME
           packager, but unless you specify parts to send, no MIME formatting
           will be done.

           See also: SOAP::Packager.

       proxy(endpoint, optional extra arguments)
               $client-&gt;proxy(&apos;http://soap.xml.info/ endPoint&apos;);
&#12;           The proxy is the server or endpoint to which the client is going to
           connect.  This method allows the setting of the endpoint, along with
           any extra information that the transport object may need when
           communicating the request.

           This method is actually an alias to the proxy method of
           SOAP::Transport.  It is the same as typing:

               $client-&gt;transport( )-&gt;proxy(...arguments);

           Extra parameters can be passed to proxy() - see below.

           compress_threshold
               See COMPRESSION in HTTP::Transport.

           All initialization options from the underlying transport layer
               The options for HTTP(S) are the same as for LWP::UserAgent&apos;s
               new() method.

               A common option is to create a instance of HTTP::Cookies and pass
               it as cookie_jar option:

                my $cookie_jar = HTTP::Cookies-&gt;new()
                $client-&gt;proxy(&apos;http://www.example.org/webservice&apos;,
                   cookie_jar =&gt; $cookie_jar,
                );

           For example, if you wish to set the HTTP timeout for a SOAP::Lite
           client to 5 seconds, use the following code:

             my $soap = SOAP::Lite
              -&gt;uri($uri)
              -&gt;proxy($proxyUrl, timeout =&gt; 5 );

           See LWP::UserAgent.

       endpoint(optional new endpoint address)
               $client-&gt;endpoint(&apos;http://soap.xml.info/ newPoint&apos;)

           It may be preferable to set a new endpoint without the additional
           work of examining the new address for protocol information and
           checking to ensure the support code is loaded and available. This
           method allows the caller to change the endpoint that the client is
           currently set to connect to, without reloading the relevant transport
           code. Note that the proxy method must have been called before this
           method is used.

       service(service URL)
               $client-&gt;service(&apos;http://svc.perl.org/Svc.wsdl&apos;);

           &quot;SOAP::Lite&quot; offers some support for creating method stubs from
           service descriptions. At present, only WSDL support is in place. This
           method loads the specified WSDL schema and uses it as the basis for
           generating stubs.

       outputxml(boolean)
               $client-&gt;outputxml(&apos;true&apos;);

           When set to a true value, the raw XML is returned by the call to a
           remote method.

           The default is to return the a SOAP::SOM object (false).

       autotype(boolean)
               $client-&gt;autotype(0);

           This method is a shortcut for:

               $client-&gt;serializer-&gt;autotype(boolean);

           By default, the serializer tries to automatically deduce types for
           the data being sent in a message. Setting a false value with this
           method disables the behavior.

       readable(boolean)
               $client-&gt;readable(1);

           This method is a shortcut for:

               $client-&gt;serializer-&gt;readable(boolean);

           When this is used to set a true value for this property, the
           generated XML sent to the endpoint has extra characters (spaces and
           new lines) added in to make the XML itself more readable to human
           eyes (presumably for debugging).  The default is to not send any
           additional characters.

       default_ns($uri)
           Sets the default namespace for the request to the specified uri. This
           overrides any previous namespace declaration that may have been set
           using a previous call to &quot;ns()&quot; or &quot;default_ns()&quot;. Setting the
           default namespace causes elements to be serialized without a
           namespace prefix, like this:

             &lt;soap:Envelope&gt;
               &lt;soap:Body&gt;
                 &lt;myMethod xmlns=&quot;http://www.someuri.com&quot;&gt;
                   &lt;foo /&gt;
                 &lt;/myMethod&gt;
               &lt;/soap:Body&gt;
             &lt;/soap:Envelope&gt;

           Some .NET web services have been reported to require this XML
           namespace idiom.

       ns($uri,$prefix=undef)
           Sets the namespace uri and optionally the namespace prefix for the
           request to the specified values. This overrides any previous
           namespace declaration that may have been set using a previous call to
           &quot;ns()&quot; or &quot;default_ns()&quot;.

           If a prefix is not specified, one will be generated for you
           automatically.  Setting the namespace causes elements to be
           serialized with a declared namespace prefix, like this:

             &lt;soap:Envelope&gt;
               &lt;soap:Body&gt;
                 &lt;my:myMethod xmlns:my=&quot;http://www.someuri.com&quot;&gt;
                   &lt;my:foo /&gt;
                 &lt;/my:myMethod&gt;
               &lt;/soap:Body&gt;
             &lt;/soap:Envelope&gt;

       use_prefix(boolean)
           Deprecated. Use the &quot;ns()&quot; and &quot;default_ns&quot; methods described above.

           Shortcut for &quot;serializer-&gt;use_prefix()&quot;. This lets you turn on/off
           the use of a namespace prefix for the children of the /Envelope/Body
           element.  Default is &apos;true&apos;.

           When use_prefix is set to &apos;true&apos;, serialized XML will look like this:

             &lt;SOAP-ENV:Envelope ...attributes skipped&gt;
               &lt;SOAP-ENV:Body&gt;
                 &lt;namesp1:mymethod xmlns:namesp1=&quot;urn:MyURI&quot; /&gt;
               &lt;/SOAP-ENV:Body&gt;
             &lt;/SOAP-ENV:Envelope&gt;
&#12;           When use_prefix is set to &apos;false&apos;, serialized XML will look like
           this:

             &lt;SOAP-ENV:Envelope ...attributes skipped&gt;
               &lt;SOAP-ENV:Body&gt;
                 &lt;mymethod xmlns=&quot;urn:MyURI&quot; /&gt;
               &lt;/SOAP-ENV:Body&gt;
             &lt;/SOAP-ENV:Envelope&gt;

           Some .NET web services have been reported to require this XML
           namespace idiom.

       soapversion(optional value)
               $client-&gt;soapversion(&apos;1.2&apos;);

           If no parameter is given, returns the current version of SOAP that is
           being used by the client object to encode requests. If a parameter is
           given, the method attempts to set that as the version of SOAP being
           used.

           The value should be either 1.1 or 1.2.

       envprefix(QName)
               $client-&gt;envprefix(&apos;env&apos;);

           This method is a shortcut for:

               $client-&gt;serializer-&gt;envprefix(QName);

           Gets or sets the namespace prefix for the SOAP namespace. The default
           is SOAP.

           The prefix itself has no meaning, but applications may wish to chose
           one explicitly to denote different versions of SOAP or the like.

       encprefix(QName)
               $client-&gt;encprefix(&apos;enc&apos;);

           This method is a shortcut for:

               $client-&gt;serializer-&gt;encprefix(QName);

           Gets or sets the namespace prefix for the encoding rules namespace.
           The default value is SOAP-ENC.

       While it may seem to be an unnecessary operation to set a value that
       isn&apos;t relevant to the message, such as the namespace labels for the
       envelope and encoding URNs, the ability to set these labels explicitly
       can prove to be a great aid in distinguishing and debugging messages on
       the server side of operations.

       encoding(encoding URN)
               $client-&gt;encoding($soap_12_encoding_URN);

           This method is a shortcut for:

               $client-&gt;serializer-&gt;encoding(args);

           Where the earlier method dealt with the label used for the attributes
           related to the SOAP encoding scheme, this method actually sets the
           URN to be specified as the encoding scheme for the message. The
           default is to specify the encoding for SOAP 1.1, so this is handy for
           applications that need to encode according to SOAP 1.2 rules.

       typelookup
               $client-&gt;typelookup;

           This method is a shortcut for:

               $client-&gt;serializer-&gt;typelookup;
&#12;           Gives the application access to the type-lookup table from the
           serializer object. See the section on SOAP::Serializer.

       uri(service specifier)
           Deprecated - the &quot;uri&quot; subroutine is deprecated in order to provide a
           more intuitive naming scheme for subroutines that set namespaces. In
           the future, you will be required to use either the &quot;ns()&quot; or
           &quot;default_ns()&quot; subroutines instead of &quot;uri()&quot;.

               $client-&gt;uri($service_uri);

           This method is a shortcut for:

               $client-&gt;serializer-&gt;uri(service);

           The URI associated with this accessor on a client object is the
           service-specifier for the request, often encoded for HTTP-based
           requests as the SOAPAction header. While the names may seem
           confusing, this method doesn&apos;t specify the endpoint itself. In most
           circumstances, the &quot;uri&quot; refers to the namespace used for the
           request.

           Often times, the value may look like a valid URL. Despite this, it
           doesn&apos;t have to point to an existing resource (and often doesn&apos;t).
           This method sets and retrieves this value from the object. Note that
           no transport code is triggered by this because it has no direct
           effect on the transport of the object.

       multirefinplace(boolean)
               $client-&gt;multirefinplace(1);

           This method is a shortcut for:

               $client-&gt;serializer-&gt;multirefinplace(boolean);

           Controls how the serializer handles values that have multiple
           references to them. Recall from previous SOAP chapters that a value
           may be tagged with an identifier, then referred to in several places.
           When this is the case for a value, the serializer defaults to putting
           the data element towards the top of the message, right after the
           opening tag of the method-specification. It is serialized as a
           standalone entity with an ID that is then referenced at the relevant
           places later on. If this method is used to set a true value, the
           behavior is different. When the multirefinplace attribute is true,
           the data is serialized at the first place that references it, rather
           than as a separate element higher up in the body. This is more
           compact but may be harder to read or trace in a debugging
           environment.

       parts( ARRAY )
           Used to specify an array of MIME::Entity&apos;s to be attached to the
           transmitted SOAP message. Attachments that are returned in a response
           can be accessed by &quot;SOAP::SOM::parts()&quot;.

       self
               $ref = SOAP::Lite-&gt;self;

           Returns an object reference to the default global object the
           &quot;SOAP::Lite&quot; package maintains. This is the object that processes
           many of the arguments when provided on the use line.

       The following method isn&apos;t an accessor style of method but neither does
       it fit with the group that immediately follows it:

       call(arguments)
               $client-&gt;call($method =&gt; @arguments);

           As has been illustrated in previous chapters, the &quot;SOAP::Lite&quot; client
           objects can manage remote calls with auto-dispatching using some of
           Perl&apos;s more elaborate features. call is used when the application
           wants a greater degree of control over the details of the call
           itself. The method may be built up from a SOAP::Data object, so as to
           allow full control over the namespace associated with the tag, as
           well as other attributes like encoding. This is also important for
           calling methods that contain characters not allowable in Perl
           function names, such as A.B.C.

       The next four methods used in the &quot;SOAP::Lite&quot; class are geared towards
       handling the types of events than can occur during the message lifecycle.
       Each of these sets up a callback for the event in question:

       on_action(callback)
               $client-&gt;on_action(sub { qq(&quot;$_[0]&quot;) });

           Triggered when the transport object sets up the SOAPAction header for
           an HTTP-based call. The default is to set the header to the string,
           uri#method, in which URI is the value set by the uri method described
           earlier, and method is the name of the method being called. When
           called, the routine referenced (or the closure, if specified as in
           the example) is given two arguments, uri and method, in that order.

           .NET web services usually expect &quot;/&quot; as separator for &quot;uri&quot; and
           &quot;method&quot;.  To change SOAP::Lite&apos;s behaviour to use uri/method as
           SOAPAction header, use the following code:

               $client-&gt;on_action( sub { join &apos;/&apos;, @_ } );
           =item on_fault(callback)

               $client-&gt;on_fault(sub { popup_dialog($_[1]) });

           Triggered when a method call results in a fault response from the
           server.  When it is called, the argument list is first the client
           object itself, followed by the object that encapsulates the fault. In
           the example, the fault object is passed (without the client object)
           to a hypothetical GUI function that presents an error dialog with the
           text of fault extracted from the object (which is covered shortly
           under the SOAP::SOM methods).

       on_nonserialized(callback)
               $client-&gt;on_nonserialized(sub { die &quot;$_[0]?!?&quot; });

           Occasionally, the serializer may be given data it can&apos;t turn into
           SOAP-savvy XML; for example, if a program bug results in a code
           reference or something similar being passed in as a parameter to
           method call. When that happens, this callback is activated, with one
           argument. That argument is the data item that could not be
           understood. It will be the only argument. If the routine returns, the
           return value is pasted into the message as the serialization.
           Generally, an error is in order, and this callback allows for control
           over signaling that error.

       on_debug(callback)
               $client-&gt;on_debug(sub { print @_ });

           Deprecated. Use the global +debug and +trace facilities described in
           SOAP::Trace

           Note that this method will not work as expected: Instead of affecting
           the debugging behaviour of the object called on, it will globally
           affect the debugging behaviour for all objects of that class.

WRITING A SOAP CLIENT
       This chapter guides you to writing a SOAP client by example.

       The SOAP service to be accessed is a simple variation of the well-known
       hello world program. It accepts two parameters, a name and a given name,
       and returns &quot;Hello $given_name $name&quot;.

       We will use &quot;Martin Kutter&quot; as the name for the call, so all variants
       will print the following message on success:

        Hello Martin Kutter!
&#12;   SOAP message styles
       There are three common (and one less common) variants of SOAP messages.

       These address the message style (positional parameters vs. specified
       message documents) and encoding (as-is vs. typed).

       The different message styles are:

       &#183;   rpc/encoded

           Typed, positional parameters. Widely used in scripting languages.
           The type of the arguments is included in the message.  Arrays and the
           like may be encoded using SOAP encoding rules (or others).

       &#183;   rpc/literal

           As-is, positional parameters. The type of arguments is defined by
           some pre-exchanged interface definition.

       &#183;   document/encoded

           Specified message with typed elements. Rarely used.

       &#183;   document/literal

           Specified message with as-is elements. The message specification and
           element types are defined by some pre-exchanged interface definition.

       As of 2008, document/literal has become the predominant SOAP message
       variant. rpc/literal and rpc/encoded are still in use, mainly with
       scripting languages, while document/encoded is hardly used at all.

       You will see clients for the rpc/encoded and document/literal SOAP
       variants in this section.

   Example implementations
       RPC/ENCODED

       Rpc/encoded is most popular with scripting languages like perl, php and
       python without the use of a WSDL. Usual method descriptions look like
       this:

        Method: sayHello(string, string)
        Parameters:
           name: string
           givenName: string

       Such a description usually means that you can call a method named
       &quot;sayHello&quot; with two positional parameters, &quot;name&quot; and &quot;givenName&quot;, which
       both are strings.

       The message corresponding to this description looks somewhat like this:

        &lt;sayHello xmlns=&quot;urn:HelloWorld&quot;&gt;
          &lt;s-gensym01 xsi:type=&quot;xsd:string&quot;&gt;Kutter&lt;/s-gensym01&gt;
          &lt;s-gensym02 xsi:type=&quot;xsd:string&quot;&gt;Martin&lt;/s-gensym02&gt;
        &lt;/sayHello&gt;

       Any XML tag names may be used instead of the &quot;s-gensym01&quot; stuff -
       parameters are positional, the tag names have no meaning.

       A client producing such a call is implemented like this:

        use SOAP::Lite;
        my $soap = SOAP::Lite-&gt;new( proxy =&gt; &apos;http://localhost:81/soap-wsdl-test/helloworld.pl&apos;);
        $soap-&gt;default_ns(&apos;urn:HelloWorld&apos;);
        my $som = $soap-&gt;call(&apos;sayHello&apos;, &apos;Kutter&apos;, &apos;Martin&apos;);
        die $som-&gt;faultstring if ($som-&gt;fault);
        print $som-&gt;result, &quot;\n&quot;;

       You can of course use a one-liner, too...
&#12;       Sometimes, rpc/encoded interfaces are described with WSDL definitions.  A
       WSDL accepting &quot;named&quot; parameters with rpc/encoded looks like this:

        &lt;definitions xmlns:soap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot;
          xmlns:s=&quot;http://www.w3.org/2001/XMLSchema&quot;
          xmlns:s0=&quot;urn:HelloWorld&quot;
          targetNamespace=&quot;urn:HelloWorld&quot;
          xmlns=&quot;http://schemas.xmlsoap.org/wsdl/&quot;&gt;
          &lt;types&gt;
            &lt;s:schema targetNamespace=&quot;urn:HelloWorld&quot;&gt;
            &lt;/s:schema&gt;
          &lt;/types&gt;
          &lt;message name=&quot;sayHello&quot;&gt;
            &lt;part name=&quot;name&quot; type=&quot;s:string&quot; /&gt;
            &lt;part name=&quot;givenName&quot; type=&quot;s:string&quot; /&gt;
          &lt;/message&gt;
          &lt;message name=&quot;sayHelloResponse&quot;&gt;
            &lt;part name=&quot;sayHelloResult&quot; type=&quot;s:string&quot; /&gt;
          &lt;/message&gt;

          &lt;portType name=&quot;Service1Soap&quot;&gt;
            &lt;operation name=&quot;sayHello&quot;&gt;
              &lt;input message=&quot;s0:sayHello&quot; /&gt;
              &lt;output message=&quot;s0:sayHelloResponse&quot; /&gt;
            &lt;/operation&gt;
          &lt;/portType&gt;

          &lt;binding name=&quot;Service1Soap&quot; type=&quot;s0:Service1Soap&quot;&gt;
            &lt;soap:binding transport=&quot;http://schemas.xmlsoap.org/soap/http&quot;
                style=&quot;rpc&quot; /&gt;
            &lt;operation name=&quot;sayHello&quot;&gt;
              &lt;soap:operation soapAction=&quot;urn:HelloWorld#sayHello&quot;/&gt;
              &lt;input&gt;
                &lt;soap:body use=&quot;encoded&quot;
                  encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;/&gt;
              &lt;/input&gt;
              &lt;output&gt;
                &lt;soap:body use=&quot;encoded&quot;
                  encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;/&gt;
              &lt;/output&gt;
            &lt;/operation&gt;
          &lt;/binding&gt;
          &lt;service name=&quot;HelloWorld&quot;&gt;
            &lt;port name=&quot;HelloWorldSoap&quot; binding=&quot;s0:Service1Soap&quot;&gt;
              &lt;soap:address location=&quot;http://localhost:81/soap-wsdl-test/helloworld.pl&quot; /&gt;
            &lt;/port&gt;
          &lt;/service&gt;
        &lt;/definitions&gt;

       The message corresponding to this schema looks like this:

        &lt;sayHello xmlns=&quot;urn:HelloWorld&quot;&gt;
          &lt;name xsi:type=&quot;xsd:string&quot;&gt;Kutter&lt;/name&gt;
          &lt;givenName xsi:type=&quot;xsd:string&quot;&gt;Martin&lt;/givenName&gt;
        &lt;/sayHello&gt;

       A web service client using this schema looks like this:

        use SOAP::Lite;
        my $soap = SOAP::Lite-&gt;service(&quot;file:say_hello_rpcenc.wsdl&quot;);
        eval { my $result = $soap-&gt;sayHello(&apos;Kutter&apos;, &apos;Martin&apos;); };
        if ($@) {
            die $@;
        }
        print $som-&gt;result();

       You may of course also use the following one-liner:

        perl -MSOAP::Lite -e &apos;print SOAP::Lite-&gt;service(&quot;file:say_hello_rpcenc.wsdl&quot;)\
          -&gt;sayHello(&apos;Kutter&apos;, &apos;Martin&apos;), &quot;\n&quot;;&apos;

       A web service client (without a service description) looks like this.

        use SOAP::Lite;
        my $soap = SOAP::Lite-&gt;new( proxy =&gt; &apos;http://localhost:81/soap-wsdl-test/helloworld.pl&apos;);
        $soap-&gt;default_ns(&apos;urn:HelloWorld&apos;);
        my $som = $soap-&gt;call(&apos;sayHello&apos;,
           SOAP::Data-&gt;name(&apos;name&apos;)-&gt;value(&apos;Kutter&apos;),
           SOAP::Data-&gt;name(&apos;givenName&apos;)-&gt;value(&apos;Martin&apos;)
        );
        die $som-&gt;faultstring if ($som-&gt;fault);
        print $som-&gt;result, &quot;\n&quot;;

       RPC/LITERAL

       SOAP web services using the document/literal message encoding are usually
       described by some Web Service Definition. Our web service has the
       following WSDL description:

        &lt;definitions xmlns:soap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot;
          xmlns:s=&quot;http://www.w3.org/2001/XMLSchema&quot;
          xmlns:s0=&quot;urn:HelloWorld&quot;
          targetNamespace=&quot;urn:HelloWorld&quot;
          xmlns=&quot;http://schemas.xmlsoap.org/wsdl/&quot;&gt;
          &lt;types&gt;
            &lt;s:schema targetNamespace=&quot;urn:HelloWorld&quot;&gt;
              &lt;s:complexType name=&quot;sayHello&quot;&gt;
                &lt;s:sequence&gt;
                  &lt;s:element minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot; name=&quot;name&quot;
                     type=&quot;s:string&quot; /&gt;
                  &lt;s:element minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot; name=&quot;givenName&quot;
                     type=&quot;s:string&quot; nillable=&quot;1&quot; /&gt;
                &lt;/s:sequence&gt;
              &lt;/s:complexType&gt;

              &lt;s:complexType name=&quot;sayHelloResponse&quot;&gt;
                &lt;s:sequence&gt;
                  &lt;s:element minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot; name=&quot;sayHelloResult&quot;
                     type=&quot;s:string&quot; /&gt;
                &lt;/s:sequence&gt;
              &lt;/s:complexType&gt;
            &lt;/s:schema&gt;
          &lt;/types&gt;
          &lt;message name=&quot;sayHello&quot;&gt;
            &lt;part name=&quot;parameters&quot; type=&quot;s0:sayHello&quot; /&gt;
          &lt;/message&gt;
          &lt;message name=&quot;sayHelloResponse&quot;&gt;
            &lt;part name=&quot;parameters&quot; type=&quot;s0:sayHelloResponse&quot; /&gt;
          &lt;/message&gt;

          &lt;portType name=&quot;Service1Soap&quot;&gt;
            &lt;operation name=&quot;sayHello&quot;&gt;
              &lt;input message=&quot;s0:sayHello&quot; /&gt;
              &lt;output message=&quot;s0:sayHelloResponse&quot; /&gt;
            &lt;/operation&gt;
          &lt;/portType&gt;

          &lt;binding name=&quot;Service1Soap&quot; type=&quot;s0:Service1Soap&quot;&gt;
            &lt;soap:binding transport=&quot;http://schemas.xmlsoap.org/soap/http&quot;
                style=&quot;rpc&quot; /&gt;
            &lt;operation name=&quot;sayHello&quot;&gt;
              &lt;soap:operation soapAction=&quot;urn:HelloWorld#sayHello&quot;/&gt;
              &lt;input&gt;
                &lt;soap:body use=&quot;literal&quot; namespace=&quot;urn:HelloWorld&quot;/&gt;
              &lt;/input&gt;
              &lt;output&gt;
                &lt;soap:body use=&quot;literal&quot; namespace=&quot;urn:HelloWorld&quot;/&gt;
              &lt;/output&gt;
            &lt;/operation&gt;
          &lt;/binding&gt;
          &lt;service name=&quot;HelloWorld&quot;&gt;
            &lt;port name=&quot;HelloWorldSoap&quot; binding=&quot;s0:Service1Soap&quot;&gt;
              &lt;soap:address location=&quot;http://localhost:80//helloworld.pl&quot; /&gt;
            &lt;/port&gt;
          &lt;/service&gt;
         &lt;/definitions&gt;

       The XML message (inside the SOAP Envelope) look like this:

        &lt;ns0:sayHello xmlns:ns0=&quot;urn:HelloWorld&quot;&gt;
           &lt;parameters&gt;
             &lt;name&gt;Kutter&lt;/name&gt;
             &lt;givenName&gt;Martin&lt;/givenName&gt;
           &lt;/parameters&gt;
        &lt;/ns0:sayHello&gt;

        &lt;sayHelloResponse xmlns:ns0=&quot;urn:HelloWorld&quot;&gt;
           &lt;parameters&gt;
               &lt;sayHelloResult&gt;Hello Martin Kutter!&lt;/sayHelloResult&gt;
           &lt;/parameters&gt;
        &lt;/sayHelloResponse&gt;

       This is the SOAP::Lite implementation for the web service client:

        use SOAP::Lite +trace;
        my $soap = SOAP::Lite-&gt;new( proxy =&gt; &apos;http://localhost:80/helloworld.pl&apos;);

        $soap-&gt;on_action( sub { &quot;urn:HelloWorld#sayHello&quot; });
        $soap-&gt;autotype(0)-&gt;readable(1);
        $soap-&gt;default_ns(&apos;urn:HelloWorld&apos;);

        my $som = $soap-&gt;call(&apos;sayHello&apos;, SOAP::Data-&gt;name(&apos;parameters&apos;)-&gt;value(
           \SOAP::Data-&gt;value([
               SOAP::Data-&gt;name(&apos;name&apos;)-&gt;value( &apos;Kutter&apos; ),
               SOAP::Data-&gt;name(&apos;givenName&apos;)-&gt;value(&apos;Martin&apos;),
           ]))
       );

        die $som-&gt;fault-&gt;{ faultstring } if ($som-&gt;fault);
        print $som-&gt;result, &quot;\n&quot;;

       DOCUMENT/LITERAL

       SOAP web services using the document/literal message encoding are usually
       described by some Web Service Definition. Our web service has the
       following WSDL description:

        &lt;definitions xmlns:soap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot;
           xmlns:s=&quot;http://www.w3.org/2001/XMLSchema&quot;
           xmlns:s0=&quot;urn:HelloWorld&quot;
           targetNamespace=&quot;urn:HelloWorld&quot;
           xmlns=&quot;http://schemas.xmlsoap.org/wsdl/&quot;&gt;
          &lt;types&gt;
            &lt;s:schema targetNamespace=&quot;urn:HelloWorld&quot;&gt;
              &lt;s:element name=&quot;sayHello&quot;&gt;
                &lt;s:complexType&gt;
                  &lt;s:sequence&gt;
                     &lt;s:element minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot; name=&quot;name&quot; type=&quot;s:string&quot; /&gt;
                      &lt;s:element minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot; name=&quot;givenName&quot; type=&quot;s:string&quot; nillable=&quot;1&quot; /&gt;
                  &lt;/s:sequence&gt;
                 &lt;/s:complexType&gt;
               &lt;/s:element&gt;

               &lt;s:element name=&quot;sayHelloResponse&quot;&gt;
                 &lt;s:complexType&gt;
                   &lt;s:sequence&gt;
                     &lt;s:element minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot; name=&quot;sayHelloResult&quot; type=&quot;s:string&quot; /&gt;
                   &lt;/s:sequence&gt;
               &lt;/s:complexType&gt;
             &lt;/s:element&gt;
           &lt;/types&gt;
           &lt;message name=&quot;sayHelloSoapIn&quot;&gt;
             &lt;part name=&quot;parameters&quot; element=&quot;s0:sayHello&quot; /&gt;
           &lt;/message&gt;
           &lt;message name=&quot;sayHelloSoapOut&quot;&gt;
             &lt;part name=&quot;parameters&quot; element=&quot;s0:sayHelloResponse&quot; /&gt;
           &lt;/message&gt;

           &lt;portType name=&quot;Service1Soap&quot;&gt;
             &lt;operation name=&quot;sayHello&quot;&gt;
               &lt;input message=&quot;s0:sayHelloSoapIn&quot; /&gt;
               &lt;output message=&quot;s0:sayHelloSoapOut&quot; /&gt;
             &lt;/operation&gt;
           &lt;/portType&gt;

           &lt;binding name=&quot;Service1Soap&quot; type=&quot;s0:Service1Soap&quot;&gt;
             &lt;soap:binding transport=&quot;http://schemas.xmlsoap.org/soap/http&quot;
                 style=&quot;document&quot; /&gt;
             &lt;operation name=&quot;sayHello&quot;&gt;
               &lt;soap:operation soapAction=&quot;urn:HelloWorld#sayHello&quot;/&gt;
               &lt;input&gt;
                 &lt;soap:body use=&quot;literal&quot; /&gt;
               &lt;/input&gt;
               &lt;output&gt;
                 &lt;soap:body use=&quot;literal&quot; /&gt;
               &lt;/output&gt;
             &lt;/operation&gt;
           &lt;/binding&gt;
           &lt;service name=&quot;HelloWorld&quot;&gt;
             &lt;port name=&quot;HelloWorldSoap&quot; binding=&quot;s0:Service1Soap&quot;&gt;
               &lt;soap:address location=&quot;http://localhost:80//helloworld.pl&quot; /&gt;
             &lt;/port&gt;
           &lt;/service&gt;
        &lt;/definitions&gt;

       The XML message (inside the SOAP Envelope) look like this:

        &lt;sayHello xmlns=&quot;urn:HelloWorld&quot;&gt;
          &lt;name&gt;Kutter&lt;/name&gt;
          &lt;givenName&gt;Martin&lt;/givenName&gt;
        &lt;/sayHello&gt;

        &lt;sayHelloResponse&gt;
          &lt;sayHelloResult&gt;Hello Martin Kutter!&lt;/sayHelloResult&gt;
        &lt;/sayHelloResponse&gt;

       You can call this web service with the following client code:

        use SOAP::Lite;
        my $soap = SOAP::Lite-&gt;new( proxy =&gt; &apos;http://localhost:80/helloworld.pl&apos;);

        $soap-&gt;on_action( sub { &quot;urn:HelloWorld#sayHello&quot; });
        $soap-&gt;autotype(0);
        $soap-&gt;default_ns(&apos;urn:HelloWorld&apos;);

        my $som = $soap-&gt;call(&quot;sayHello&quot;,
           SOAP::Data-&gt;name(&apos;name&apos;)-&gt;value( &apos;Kutter&apos; ),
           SOAP::Data-&gt;name(&apos;givenName&apos;)-&gt;value(&apos;Martin&apos;),
       );

        die $som-&gt;fault-&gt;{ faultstring } if ($som-&gt;fault);
        print $som-&gt;result, &quot;\n&quot;;

   Differences between the implementations
       You may have noticed that there&apos;s little difference between the
       rpc/encoded, rpc/literal and the document/literal example&apos;s
       implementation. In fact, from SOAP::Lite&apos;s point of view, the only
       differences between rpc/literal and document/literal that parameters are
       always named.

       In our example, the rpc/encoded variant already used named parameters (by
       using two messages), so there&apos;s no difference at all.

       You may have noticed the somewhat strange idiom for passing a list of
       named paraneters in the rpc/literal example:

        my $som = $soap-&gt;call(&apos;sayHello&apos;, SOAP::Data-&gt;name(&apos;parameters&apos;)-&gt;value(
           \SOAP::Data-&gt;value([
               SOAP::Data-&gt;name(&apos;name&apos;)-&gt;value( &apos;Kutter&apos; ),
               SOAP::Data-&gt;name(&apos;givenName&apos;)-&gt;value(&apos;Martin&apos;),
           ]))
        );
&#12;       While SOAP::Data provides full control over the XML generated, passing
       hash-like structures require additional coding.

WRITING A SOAP SERVER
       See SOAP::Server, or SOAP::Transport.

FEATURES
   ATTACHMENTS
       &quot;SOAP::Lite&quot; features support for the SOAP with Attachments
       specification.  Currently, SOAP::Lite only supports MIME based
       attachments. DIME based attachments are yet to be fully functional.

       EXAMPLES

       Client sending an attachment

       &quot;SOAP::Lite&quot; clients can specify attachments to be sent along with a
       request by using the &quot;SOAP::Lite::parts()&quot; method, which takes as an
       argument an ARRAY of &quot;MIME::Entity&quot;&apos;s.

         use SOAP::Lite;
         use MIME::Entity;
         my $ent = build MIME::Entity
           Type        =&gt; &quot;image/gif&quot;,
           Encoding    =&gt; &quot;base64&quot;,
           Path        =&gt; &quot;somefile.gif&quot;,
           Filename    =&gt; &quot;saveme.gif&quot;,
           Disposition =&gt; &quot;attachment&quot;;
         my $som = SOAP::Lite
           -&gt;uri($SOME_NAMESPACE)
           -&gt;parts([ $ent ])
           -&gt;proxy($SOME_HOST)
           -&gt;some_method(SOAP::Data-&gt;name(&quot;foo&quot; =&gt; &quot;bar&quot;));

       Client retrieving an attachment

       A client accessing attachments that were returned in a response by using
       the &quot;SOAP::SOM::parts()&quot; accessor.

         use SOAP::Lite;
         use MIME::Entity;
         my $soap = SOAP::Lite
           -&gt;uri($NS)
           -&gt;proxy($HOST);
         my $som = $soap-&gt;foo();
         foreach my $part (${$som-&gt;parts}) {
           print $part-&gt;stringify;
         }

       Server receiving an attachment

       Servers, like clients, use the SOAP::SOM module to access attachments
       transmitted to it.

         package Attachment;
         use SOAP::Lite;
         use MIME::Entity;
         use strict;
         use vars qw(@ISA);
         @ISA = qw(SOAP::Server::Parameters);
         sub someMethod {
           my $self = shift;
           my $envelope = pop;
           foreach my $part (@{$envelope-&gt;parts}) {
             print &quot;AttachmentService: attachment found! (&quot;.ref($part).&quot;)\n&quot;;
           }
           # do something
         }

       Server responding with an attachment

       Servers wishing to return an attachment to the calling client need only
       return &quot;MIME::Entity&quot; objects along with SOAP::Data elements, or any
       other data intended for the response.

         package Attachment;
         use SOAP::Lite;
         use MIME::Entity;
         use strict;
         use vars qw(@ISA);
         @ISA = qw(SOAP::Server::Parameters);
         sub someMethod {
           my $self = shift;
           my $envelope = pop;
           my $ent = build MIME::Entity
           &apos;Id&apos;          =&gt; &quot;&lt;1234&gt;&quot;,
           &apos;Type&apos;        =&gt; &quot;text/xml&quot;,
           &apos;Path&apos;        =&gt; &quot;some.xml&quot;,
           &apos;Filename&apos;    =&gt; &quot;some.xml&quot;,
           &apos;Disposition&apos; =&gt; &quot;attachment&quot;;
           return SOAP::Data-&gt;name(&quot;foo&quot; =&gt; &quot;blah blah blah&quot;),$ent;
         }

   DEFAULT SETTINGS
       Though this feature looks similar to autodispatch they have (almost)
       nothing in common. This capability allows you specify default settings so
       that all objects created after that will be initialized with the proper
       default settings.

       If you wish to provide common &quot;proxy()&quot; or &quot;uri()&quot; settings for all
       &quot;SOAP::Lite&quot; objects in your application you may do:

         use SOAP::Lite
           proxy =&gt; &apos;http://localhost/cgi-bin/soap.cgi&apos;,
           uri =&gt; &apos;http://my.own.com/My/Examples&apos;;

         my $soap1 = new SOAP::Lite; # will get the same proxy()/uri() as above
         print $soap1-&gt;getStateName(1)-&gt;result;

         my $soap2 = SOAP::Lite-&gt;new; # same thing as above
         print $soap2-&gt;getStateName(2)-&gt;result;

         # or you may override any settings you want
         my $soap3 = SOAP::Lite-&gt;proxy(&apos;http://localhost/&apos;);
         print $soap3-&gt;getStateName(1)-&gt;result;

       Any &quot;SOAP::Lite&quot; properties can be propagated this way. Changes in object
       copies will not affect global settings and you may still change global
       settings with &quot;SOAP::Lite-&gt;self&quot; call which returns reference to global
       object. Provided parameter will update this object and you can even set
       it to &quot;undef&quot;:

         SOAP::Lite-&gt;self(undef);

       The &quot;use SOAP::Lite&quot; syntax also lets you specify default event handlers
       for your code. If you have different SOAP objects and want to share the
       same &quot;on_action()&quot; (or &quot;on_fault()&quot; for that matter) handler. You can
       specify &quot;on_action()&quot; during initialization for every object, but you may
       also do:

         use SOAP::Lite
           on_action =&gt; sub {sprintf &apos;%s#%s&apos;, @_};

       and this handler will be the default handler for all your SOAP objects.
       You can override it if you specify a handler for a particular object. See
       t/*.t for example of on_fault() handler.

       Be warned, that since &quot;use ...&quot; is executed at compile time all &quot;use&quot;
       statements will be executed before script execution that can make
       unexpected results. Consider code:

         use SOAP::Lite proxy =&gt; &apos;http://localhost/&apos;;
         print SOAP::Lite-&gt;getStateName(1)-&gt;result;

         use SOAP::Lite proxy =&gt; &apos;http://localhost/cgi-bin/soap.cgi&apos;;
         print SOAP::Lite-&gt;getStateName(1)-&gt;result;

       Both SOAP calls will go to &apos;http://localhost/cgi-bin/soap.cgi&apos;. If you
       want to execute &quot;use&quot; at run-time, put it in &quot;eval&quot;:

         eval &quot;use SOAP::Lite proxy =&gt; &apos;http://localhost/cgi-bin/soap.cgi&apos;; 1&quot; or die;

       Or alternatively,

         SOAP::Lite-&gt;self-&gt;proxy(&apos;http://localhost/cgi-bin/soap.cgi&apos;);

   SETTING MAXIMUM MESSAGE SIZE
       One feature of &quot;SOAP::Lite&quot; is the ability to control the maximum size of
       a message a SOAP::Lite server will be allowed to process. To control this
       feature simply define $SOAP::Constants::MAX_CONTENT_SIZE in your code
       like so:

         use SOAP::Transport::HTTP;
         use MIME::Entity;
         $SOAP::Constants::MAX_CONTENT_SIZE = 10000;
         SOAP::Transport::HTTP::CGI
           -&gt;dispatch_to(&apos;TemperatureService&apos;)
           -&gt;handle;

   IN/OUT, OUT PARAMETERS AND AUTOBINDING
       &quot;SOAP::Lite&quot; gives you access to all parameters (both in/out and out) and
       also does some additional work for you. Lets consider following example:

         &lt;mehodResponse&gt;
           &lt;res1&gt;name1&lt;/res1&gt;
           &lt;res2&gt;name2&lt;/res2&gt;
           &lt;res3&gt;name3&lt;/res3&gt;
         &lt;/mehodResponse&gt;

       In that case:

         $result = $r-&gt;result; # gives you &apos;name1&apos;
         $paramout1 = $r-&gt;paramsout;      # gives you &apos;name2&apos;, because of scalar context
         $paramout1 = ($r-&gt;paramsout)[0]; # gives you &apos;name2&apos; also
         $paramout2 = ($r-&gt;paramsout)[1]; # gives you &apos;name3&apos;

       or

         @paramsout = $r-&gt;paramsout; # gives you ARRAY of out parameters
         $paramout1 = $paramsout[0]; # gives you &apos;res2&apos;, same as ($r-&gt;paramsout)[0]
         $paramout2 = $paramsout[1]; # gives you &apos;res3&apos;, same as ($r-&gt;paramsout)[1]

       Generally, if server returns &quot;return (1,2,3)&quot; you will get 1 as the
       result and 2 and 3 as out parameters.

       If the server returns &quot;return [1,2,3]&quot; you will get an ARRAY reference
       from &quot;result()&quot; and &quot;undef&quot; from &quot;paramsout()&quot;.

       Results can be arbitrary complex: they can be an array references, they
       can be objects, they can be anything and still be returned by &quot;result()&quot;
       . If only one parameter is returned, &quot;paramsout()&quot; will return &quot;undef&quot;.

       Furthermore, if you have in your output parameters a parameter with the
       same signature (name+type) as in the input parameters this parameter will
       be mapped into your input automatically. For example:

       Server Code:

         sub mymethod {
           shift; # object/class reference
           my $param1 = shift;
           my $param2 = SOAP::Data-&gt;name(&apos;myparam&apos; =&gt; shift() * 2);
           return $param1, $param2;
         }

       Client Code:

         $a = 10;
         $b = SOAP::Data-&gt;name(&apos;myparam&apos; =&gt; 12);
         $result = $soap-&gt;mymethod($a, $b);

       After that, &quot;$result == 10 and $b-&gt;value == 24&quot;! Magic? Sort of.

       Autobinding gives it to you. That will work with objects also with one
       difference: you do not need to worry about the name and the type of
       object parameter. Consider the &quot;PingPong&quot; example
       (examples/My/PingPong.pm and examples/pingpong.pl):

       Server Code:

         package My::PingPong;

         sub new {
           my $self = shift;
           my $class = ref($self) || $self;
           bless {_num=&gt;shift} =&gt; $class;
         }

         sub next {
           my $self = shift;
           $self-&gt;{_num}++;
         }

       Client Code:

         use SOAP::Lite +autodispatch =&gt;
           uri =&gt; &apos;urn:&apos;,
           proxy =&gt; &apos;http://localhost/&apos;;

         my $p = My::PingPong-&gt;new(10); # $p-&gt;{_num} is 10 now, real object returned
         print $p-&gt;next, &quot;\n&quot;;          # $p-&gt;{_num} is 11 now!, object autobinded

   STATIC AND DYNAMIC SERVICE DEPLOYMENT
       Let us scrutinize the deployment process. When designing your SOAP server
       you can consider two kind of deployment: static and dynamic. For both,
       static and dynamic,  you should specify &quot;MODULE&quot;, &quot;MODULE::method&quot;,
       &quot;method&quot; or &quot;PATH/&quot; when creating &quot;use&quot;ing the SOAP::Lite module. The
       difference between static and dynamic deployment is that in case of
       &apos;dynamic&apos;, any module which is not present will be loaded on demand. See
       the &quot;SECURITY&quot; section for detailed description.

       When statically deploying a SOAP Server, you need to know all modules
       handling SOAP requests before.

       Dynamic deployment allows extending your SOAP Server&apos;s interface by just
       installing another module into the dispatch_to path (see below).

       STATIC DEPLOYMENT EXAMPLE

         use SOAP::Transport::HTTP;
         use My::Examples;           # module is preloaded

         SOAP::Transport::HTTP::CGI
            # deployed module should be present here or client will get
            # &apos;access denied&apos;
           -&gt; dispatch_to(&apos;My::Examples&apos;)
           -&gt; handle;

       For static deployment you should specify the MODULE name directly.

       You should also use static binding when you have several different
       classes in one file and want to make them available for SOAP calls.

       DYNAMIC DEPLOYMENT EXAMPLE

         use SOAP::Transport::HTTP;
         # name is unknown, module will be loaded on demand

         SOAP::Transport::HTTP::CGI
           # deployed module should be present here or client will get &apos;access denied&apos;
           -&gt; dispatch_to(&apos;/Your/Path/To/Deployed/Modules&apos;, &apos;My::Examples&apos;)
           -&gt; handle;

       For dynamic deployment you can specify the name either directly (in that
       case it will be &quot;require&quot;d without any restriction) or indirectly, with a
       PATH. In that case, the ONLY path that will be available will be the PATH
       given to the dispatch_to() method). For information how to handle this
       situation see &quot;SECURITY&quot; section.

       SUMMARY

         dispatch_to(
           # dynamic dispatch that allows access to ALL modules in specified directory
           PATH/TO/MODULES
           # 1. specifies directory
           # -- AND --
           # 2. gives access to ALL modules in this directory without limits

           # static dispatch that allows access to ALL methods in particular MODULE
           MODULE
           #  1. gives access to particular module (all available methods)
           #  PREREQUISITES:
           #    module should be loaded manually (for example with &apos;use ...&apos;)
           #    -- OR --
           #    you can still specify it in PATH/TO/MODULES

           # static dispatch that allows access to particular method ONLY
           MODULE::method
           # same as MODULE, but gives access to ONLY particular method,
           # so there is not much sense to use both MODULE and MODULE::method
           # for the same MODULE
         );

       In addition to this &quot;SOAP::Lite&quot; also supports an experimental syntax
       that allows you to bind a specific URL or SOAPAction to a CLASS/MODULE or
       object.

       For example:

         dispatch_with({
           URI =&gt; MODULE,        # &apos;http://www.soaplite.com/&apos; =&gt; &apos;My::Class&apos;,
           SOAPAction =&gt; MODULE, # &apos;http://www.soaplite.com/method&apos; =&gt; &apos;Another::Class&apos;,
           URI =&gt; object,        # &apos;http://www.soaplite.com/obj&apos; =&gt; My::Class-&gt;new,
         })

       &quot;URI&quot; is checked before &quot;SOAPAction&quot;. You may use both the
       &quot;dispatch_to()&quot; and &quot;dispatch_with()&quot; methods in the same server, but
       note that &quot;dispatch_with()&quot; has a higher order of precedence.
       &quot;dispatch_to()&quot; will be checked only after &quot;URI&quot; and &quot;SOAPAction&quot; has
       been checked.

       See also: EXAMPLE APACHE::REGISTRY USAGE, &quot;SECURITY&quot;

   COMPRESSION
       &quot;SOAP::Lite&quot; provides you option to enable transparent compression over
       the wire. Compression can be enabled by specifying a threshold value (in
       the form of kilobytes) for compression on both the client and server
       sides:

       Note: Compression currently only works for HTTP based servers and
       clients.

       Client Code

         print SOAP::Lite
           -&gt;uri(&apos;http://localhost/My/Parameters&apos;)
           -&gt;proxy(&apos;http://localhost/&apos;, options =&gt; {compress_threshold =&gt; 10000})
           -&gt;echo(1 x 10000)
           -&gt;result;

       Server Code

         my $server = SOAP::Transport::HTTP::CGI
           -&gt;dispatch_to(&apos;My::Parameters&apos;)
           -&gt;options({compress_threshold =&gt; 10000})
           -&gt;handle;

       For more information see COMPRESSION in HTTP::Transport.

SECURITY
       For security reasons, the exisiting path for Perl modules (@INC) will be
       disabled once you have chosen dynamic deployment and specified your own
       &quot;PATH/&quot;. If you wish to access other modules in your included package you
       have several options:

       1.  Switch to static linking:

              use MODULE;
              $server-&gt;dispatch_to(&apos;MODULE&apos;);

           Which can also be useful when you want to import something specific
           from the deployed modules:

              use MODULE qw(import_list);

       2.  Change &quot;use&quot; to &quot;require&quot;. The path is only unavailable during the
           initialization phase. It is available once more during execution.
           Therefore, if you utilize &quot;require&quot; somewhere in your package, it
           will work.

       3.  Wrap &quot;use&quot; in an &quot;eval&quot; block:

              eval &apos;use MODULE qw(import_list)&apos;; die if $@;

       4.  Set your include path in your package and then specify &quot;use&quot;. Don&apos;t
           forget to put @INC in a &quot;BEGIN{}&quot; block or it won&apos;t work. For
           example,

              BEGIN { @INC = qw(my_directory); use MODULE }

INTEROPERABILITY
   Microsoft .NET client with SOAP::Lite Server
       In order to use a .NET client with a SOAP::Lite server, be sure you use
       fully qualified names for your return values. For example:

         return SOAP::Data-&gt;name(&apos;myname&apos;)
                          -&gt;type(&apos;string&apos;)
                          -&gt;uri($MY_NAMESPACE)
                          -&gt;value($output);

       In addition see comment about default incoding in .NET Web Services
       below.

   SOAP::Lite client with a .NET server
       If experiencing problems when using a SOAP::Lite client to call a .NET
       Web service, it is recommended you check, or adhere to all of the
       following recommendations:

       Declare a proper soapAction in your call
           For example, use &quot;on_action( sub {
           &apos;http://www.myuri.com/WebService.aspx#someMethod&apos;; } )&quot;.

       Disable charset definition in Content-type header
           Some users have said that Microsoft .NET prefers the value of the
           Content-type header to be a mimetype exclusively, but SOAP::Lite
           specifies a character set in addition to the mimetype. This results
           in an error similar to:

             Server found request content type to be &apos;text/xml; charset=utf-8&apos;,
             but expected &apos;text/xml&apos;

           To turn off this behavior specify use the following code:

             use SOAP::Lite;
             $SOAP::Constants::DO_NOT_USE_CHARSET = 1;
             # The rest of your code
&#12;       Use fully qualified name for method parameters
           For example, the following code is preferred:

             SOAP::Data-&gt;name(Query  =&gt; &apos;biztalk&apos;)
                       -&gt;uri(&apos;http://tempuri.org/&apos;)

           As opposed to:

             SOAP::Data-&gt;name(&apos;Query&apos;  =&gt; &apos;biztalk&apos;)

       Place method in default namespace
           For example, the following code is preferred:

             my $method = SOAP::Data-&gt;name(&apos;add&apos;)
                                    -&gt;attr({xmlns =&gt; &apos;http://tempuri.org/&apos;});
             my @rc = $soap-&gt;call($method =&gt; @parms)-&gt;result;

           As opposed to:

             my @rc = $soap-&gt;call(add =&gt; @parms)-&gt;result;
             # -- OR --
             my @rc = $soap-&gt;add(@parms)-&gt;result;

       Disable use of explicit namespace prefixes
           Some user&apos;s have reported that .NET will simply not parse messages
           that use namespace prefixes on anything but SOAP elements themselves.
           For example, the following XML would not be parsed:

             &lt;SOAP-ENV:Envelope ...attributes skipped&gt;
               &lt;SOAP-ENV:Body&gt;
                 &lt;namesp1:mymethod xmlns:namesp1=&quot;urn:MyURI&quot; /&gt;
               &lt;/SOAP-ENV:Body&gt;
             &lt;/SOAP-ENV:Envelope&gt;

           SOAP::Lite allows users to disable the use of explicit namespaces
           through the &quot;use_prefix()&quot; method. For example, the following code:

             $som = SOAP::Lite-&gt;uri(&apos;urn:MyURI&apos;)
                              -&gt;proxy($HOST)
                              -&gt;use_prefix(0)
                              -&gt;myMethod();

           Will result in the following XML, which is more pallatable by .NET:

             &lt;SOAP-ENV:Envelope ...attributes skipped&gt;
               &lt;SOAP-ENV:Body&gt;
                 &lt;mymethod xmlns=&quot;urn:MyURI&quot; /&gt;
               &lt;/SOAP-ENV:Body&gt;
             &lt;/SOAP-ENV:Envelope&gt;

       Modify your .NET server, if possible
           Stefan Pharies &lt;stefanph@microsoft.com&gt;:

           SOAP::Lite uses the SOAP encoding (section 5 of the soap 1.1 spec),
           and the default for .NET Web Services is to use a literal encoding.
           So elements in the request are unqualified, but your service expects
           them to be qualified. .Net Web Services has a way for you to change
           the expected message format, which should allow you to get your
           interop working.  At the top of your class in the asmx, add this
           attribute (for Beta 1):

             [SoapService(Style=SoapServiceStyle.RPC)]

           Another source said it might be this attribute (for Beta 2):

             [SoapRpcService]

           Full Web Service text may look like:

             &lt;%@ WebService Language=&quot;C#&quot; Class=&quot;Test&quot; %&gt;
             using System;
             using System.Web.Services;
             using System.Xml.Serialization;

             [SoapService(Style=SoapServiceStyle.RPC)]
             public class Test : WebService {
               [WebMethod]
               public int add(int a, int b) {
                 return a + b;
               }
             }

           Another example from Kirill Gavrylyuk &lt;kirillg@microsoft.com&gt;:

           &quot;You can insert [SoapRpcService()] attribute either on your class or
           on operation level&quot;.

             &lt;%@ WebService Language=CS class=&quot;DataType.StringTest&quot;%&gt;

             namespace DataType {
&#12;               using System;
               using System.Web.Services;
               using System.Web.Services.Protocols;
               using System.Web.Services.Description;

              [SoapRpcService()]
              public class StringTest: WebService {
                [WebMethod]
                [SoapRpcMethod()]
                public string RetString(string x) {
                  return(x);
                }
              }
            }

           Example from Yann Christensen &lt;yannc@microsoft.com&gt;:

             using System;
             using System.Web.Services;
             using System.Web.Services.Protocols;

             namespace Currency {
               [WebService(Namespace=&quot;http://www.yourdomain.com/example&quot;)]
               [SoapRpcService]
               public class Exchange {
                 [WebMethod]
                 public double getRate(String country, String country2) {
                   return 122.69;
                 }
               }
             }

       Special thanks goes to the following people for providing the above
       description and details on .NET interoperability issues:

       Petr Janata &lt;petr.janata@i.cz&gt;,

       Stefan Pharies &lt;stefanph@microsoft.com&gt;,

       Brian Jepson &lt;bjepson@jepstone.net&gt;, and others

TROUBLESHOOTING
       SOAP::Lite serializes &quot;18373&quot; as an integer, but I want it to be a
       string!
           SOAP::Lite guesses datatypes from the content provided, using a set
           of common-sense rules. These rules are not 100% reliable, though they
           fit for most data.

           You may force the type by passing a SOAP::Data object with a type
           specified:

            my $proxy = SOAP::Lite-&gt;proxy(&apos;http://www.example.org/soapservice&apos;);
            my $som = $proxy-&gt;myMethod(
                SOAP::Data-&gt;name(&apos;foo&apos;)-&gt;value(12345)-&gt;type(&apos;string&apos;)
            );

           You may also change the precedence of the type-guessing rules. Note
           that this means fiddling with SOAP::Lite&apos;s internals - this may not
           work as expected in future versions.

           The example above forces everything to be encoded as string (this is
           because the string test is normally last and allways returns true):

             my @list = qw(-1 45 foo bar 3838);
             my $proxy = SOAP::Lite-&gt;uri($uri)-&gt;proxy($proxyUrl);
             $proxy-&gt;serializer-&gt;typelookup-&gt;{string}-&gt;[0] = 0;
             $proxy-&gt;myMethod(\@list);

           See SOAP::Serializer for more details.

       &quot;+autodispatch&quot; doesn&apos;t work in Perl 5.8
           There is a bug in Perl 5.8&apos;s &quot;UNIVERSAL::AUTOLOAD&quot; functionality that
           prevents the &quot;+autodispatch&quot; functionality from working properly. The
           workaround is to use &quot;dispatch_from&quot; instead. Where you might
           normally do something like this:

              use Some::Module;
              use SOAP::Lite +autodispatch =&gt;
                  uri =&gt; &apos;urn:Foo&apos;
                  proxy =&gt; &apos;http://...&apos;;

           You would do something like this:

              use SOAP::Lite dispatch_from(Some::Module) =&gt;
                  uri =&gt; &apos;urn:Foo&apos;
                  proxy =&gt; &apos;http://...&apos;;

       Problems using SOAP::Lite&apos;s COM Interface
           Can&apos;t call method &quot;server&quot; on undefined value
               You probably did not register Lite.dll using &quot;regsvr32 Lite.dll&quot;
&#12;           Failed to load PerlCtrl Runtime
               It is likely that you have install Perl in two different
               locations and the location of ActiveState&apos;s Perl is not the first
               instance of Perl specified in your PATH. To rectify, rename the
               directory in which the non-ActiveState Perl is installed, or be
               sure the path to ActiveState&apos;s Perl is specified prior to any
               other instance of Perl in your PATH.

       Dynamic libraries are not found
           If you are using the Apache web server, and you are seeing something
           like the following in your webserver log file:

             Can&apos;t load &apos;/usr/local/lib/perl5/site_perl/.../XML/Parser/Expat/Expat.so&apos;
               for module XML::Parser::Expat: dynamic linker: /usr/local/bin/perl:
               libexpat.so.0 is NEEDED, but object does not exist at
               /usr/local/lib/perl5/.../DynaLoader.pm line 200.

           Then try placing the following into your httpd.conf file and see if
           it fixes your problem.

            &lt;IfModule mod_env.c&gt;
                PassEnv LD_LIBRARY_PATH
            &lt;/IfModule&gt;

       SOAP client reports &quot;500 unexpected EOF before status line seen
           See &quot;Apache is crashing with segfaults&quot;

       Apache is crashing with segfaults
           Using &quot;SOAP::Lite&quot; (or XML::Parser::Expat) in combination with
           mod_perl causes random segmentation faults in httpd processes. To
           fix, try configuring Apache with the following:

            RULE_EXPAT=no

           If you are using Apache 1.3.20 and later, try configuring Apache with
           the following option:

            ./configure --disable-rule=EXPAT

           See http://archive.covalent.net/modperl/2000/04/0185.xml for more
           details and lot of thanks to Robert Barta &lt;rho@bigpond.net.au&gt; for
           explaining this weird behavior.

           If this doesn&apos;t address the problem, you may wish to try
           &quot;-Uusemymalloc&quot;, or a similar option in order to instruct Perl to use
           the system&apos;s own &quot;malloc&quot;.

           Thanks to Tim Bunce &lt;Tim.Bunce@pobox.com&gt;.

       CGI scripts do not work under Microsoft Internet Information Server (IIS)
           CGI scripts may not work under IIS unless scripts use the &quot;.pl&quot;
           extension, opposed to &quot;.cgi&quot;.

       Java SAX parser unable to parse message composed by SOAP::Lite
           In some cases SOAP messages created by &quot;SOAP::Lite&quot; may not be parsed
           properly by a SAX2/Java XML parser. This is due to a known bug in
           &quot;org.xml.sax.helpers.ParserAdapter&quot;. This bug manifests itself when
           an attribute in an XML element occurs prior to the XML namespace
           declaration on which it depends. However, according to the XML
           specification, the order of these attributes is not significant.

           http://www.megginson.com/SAX/index.html

           Thanks to Steve Alpert (Steve_Alpert@idx.com) for pointing on it.

PERFORMANCE
       Processing of XML encoded fragments
           &quot;SOAP::Lite&quot; is based on XML::Parser which is basically wrapper
           around James Clark&apos;s expat parser. Expat&apos;s behavior for parsing XML
           encoded string can affect processing messages that have lot of
           encoded entities, like XML fragments, encoded as strings. Providing
           low-level details, parser will call char() callback for every portion
           of processed stream, but individually for every processed entity or
           newline. It can lead to lot of calls and additional memory manager
           expenses even for small messages. By contrast, XML messages which are
           encoded as base64Binary, don&apos;t have this problem and difference in
           processing time can be significant. For XML encoded string that has
           about 20 lines and 30 tags, number of call could be about 100 instead
           of one for the same string encoded as base64Binary.

           Since it is parser&apos;s feature there is NO fix for this behavior (let
           me know if you find one), especially because you need to parse
           message you already got (and you cannot control content of this
           message), however, if your are in charge for both ends of processing
           you can switch encoding to base64 on sender&apos;s side. It will
           definitely work with SOAP::Lite and it may work with other
           toolkits/implementations also, but obviously I cannot guarantee that.

           If you want to encode specific string as base64, just do
           &quot;SOAP::Data-&gt;type(base64 =&gt; $string)&quot; either on client or on server
           side. If you want change behavior for specific instance of
           SOAP::Lite, you may subclass &quot;SOAP::Serializer&quot;, override
           &quot;as_string()&quot; method that is responsible for string encoding (take a
           look into &quot;as_base64Binary()&quot;) and specify new serializer class for
           your SOAP::Lite object with:

             my $soap = new SOAP::Lite
               serializer =&gt; My::Serializer-&gt;new,
               ..... other parameters

           or on server side:

             my $server = new SOAP::Transport::HTTP::Daemon # or any other server
               serializer =&gt; My::Serializer-&gt;new,
               ..... other parameters

           If you want to change this behavior for all instances of SOAP::Lite,
           just substitute &quot;as_string()&quot; method with &quot;as_base64Binary()&quot;
           somewhere in your code after &quot;use SOAP::Lite&quot; and before actual
           processing/sending:

             *SOAP::Serializer::as_string = \&amp;SOAP::XMLSchema2001::Serializer::as_base64Binary;

           Be warned that last two methods will affect all strings and convert
           them into base64 encoded. It doesn&apos;t make any difference for
           SOAP::Lite, but it may make a difference for other toolkits.

BUGS AND LIMITATIONS
       &#183;   No support for multidimensional, partially transmitted and sparse
           arrays (however arrays of arrays are supported, as well as any other
           data structures, and you can add your own implementation with
           SOAP::Data).

       &#183;   Limited support for WSDL schema.

       &#183;   XML::Parser::Lite relies on Unicode support in Perl and doesn&apos;t do
           entity decoding.

       &#183;   Limited support for mustUnderstand and Actor attributes.

PLATFORM SPECIFICS
       MacOS
           Information about XML::Parser for MacPerl could be found here:

           http://bumppo.net/lists/macperl-modules/1999/07/msg00047.html

           Compiled XML::Parser for MacOS could be found here:

           http://www.perl.com/CPAN-local/authors/id/A/AS/ASANDSTRM/XML-Parser-2.27-bin-1-MacOS.tgz

RELATED MODULES
   Transport Modules
       SOAP::Lite allows one to add support for additional transport protocols,
       or server handlers, via separate modules implementing the
       SOAP::Transport::* interface. The following modules are available from
       CPAN:

       &#183;   SOAP-Transport-HTTP-Nginx

           SOAP::Transport::HTTP::Nginx provides a transport module for nginx
           (&lt;http://nginx.net/&gt;)

AVAILABILITY
       You can download the latest version SOAP::Lite for Unix or SOAP::Lite for
       Win32 from the following sources:

        * CPAN:                http://search.cpan.org/search?dist=SOAP-Lite
        * Sourceforge:         http://sourceforge.net/projects/soaplite/

       PPM packages are also available from sourceforge.

       You are welcome to send e-mail to the maintainers of SOAP::Lite with your
       comments, suggestions, bug reports and complaints.

ACKNOWLEDGEMENTS
       Special thanks to Randy J. Ray, author of Programming Web Services with
       Perl, who has contributed greatly to the documentation effort of
       SOAP::Lite.

       Special thanks to O&apos;Reilly publishing which has graciously allowed
       SOAP::Lite to republish and redistribute the SOAP::Lite reference manual
       found in Appendix B of Programming Web Services with Perl.

       And special gratitude to all the developers who have contributed patches,
       ideas, time, energy, and help in a million different forms to the
       development of this software.

HACKING
       SOAP::Lite&apos;s development takes place on sourceforge.net.

       There&apos;s a subversion repository set up at
&#12;        https://soaplite.svn.sourceforge.net/svnroot/soaplite/

REPORTING BUGS
       Please report all suspected SOAP::Lite bugs using Sourceforge. This
       ensures proper tracking of the issue and allows you the reporter to know
       when something gets fixed.

       http://sourceforge.net/tracker/?group_id=66000&amp;atid=513017

COPYRIGHT
       Copyright (C) 2000-2007 Paul Kulchenko. All rights reserved.

       Copyright (C) 2007-2008 Martin Kutter

LICENSE
       This library is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.

       This text and all associated documentation for this library is made
       available under the Creative Commons Attribution-NoDerivs 2.0 license.
       http://creativecommons.org/licenses/by-nd/2.0/

AUTHORS
       Paul Kulchenko (paulclinger@yahoo.com)

       Randy J. Ray (rjray@blackperl.com)

       Byrne Reese (byrne@majordojo.com)

       Martin Kutter (martin.kutter@fen-net.de)



perl v5.12.4                       2011-08-29                    SOAP::Lite(3pm)

</pre></body></html>
