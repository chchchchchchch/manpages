<html>
<head><meta charset=utf-8/>
<title>SOAP::Serializer - the means by which the toolkit manages the expression of data as XML</title></head>
<body><pre>

SOAP::Serializer(3pm)  User Contributed Perl Documentation SOAP::Serializer(3pm)



NAME
       SOAP::Serializer - the means by which the toolkit manages the expression
       of data as XML

DESCRIPTION
       The SOAP::Serializer class is the means by which the toolkit manages the
       expression of data as XML. The object that a SOAP::Lite instance uses by
       default is generally enough for the task, with no need for the
       application to create its own. The main purpose of this class is to
       provide a place for applications to extend the serializer by defining
       additional methods for handling new datatypes.

METHODS
       new(optional key/value pairs)
               $serialize = SOAP::Serializer-&gt;new( );

           This is the constructor method for the class. In addition to creating
           a basic object and initializing it with default values, the
           constructor can also take names and values for most of the accessor
           methods that the class supports.

       envelope(method, data arguments)
               $serialize-&gt;envelope(fault =&gt; $fault_obj);

           Provides the core purpose for the SOAP::Serializer class. It creates
           the full SOAP envelope based on the input passed in to it. The data
           arguments passed in the list of parameters to the method are divided
           into two sublists: any parameters that are SOAP::Header objects or
           derivatives of go into one list, while the remainder go into the
           other. The nonheader objects are used as the content for the message
           body, with the body itself being largely dependent on the value of
           the first argument in the list. This argument is expected to be a
           string and should be one of the following:

       context
               $serialize-&gt;context-&gt;packager();

           This provides access to the calling context of &quot;SOAP::Serializer&quot;. In
           a client side context the often means a reference to an instance of
           SOAP::Lite. In a server side context this means a reference to a
           SOAP::Server instance.

           method
               The envelope is being created to encapsulate a RPC-style method
               call.

           response
               The message being created is that of a response stemming from a
               RPC-style method call.

           fault
               For this specifier, the envelope being created is to transmit a
               fault.

           freeform
               This identifier is used as a general-case encoding style for
               messages that don&apos;t fit into any of the previous cases. The
               arguments are encoded into the envelope&apos;s Body tag without any
               sort of context sensitivity.

           Any value other than these four results in an error.
&#12;       envprefix(optional value)
               $serialize-&gt;envprefix(&apos;env&apos;);

           Gets or sets the prefix that labels the SOAP envelope namespace. This
           defaults to SOAP-ENV.

       encprefix(optional value)
               $serialize-&gt;envprefix(&apos;enc&apos;);

           Gets or sets the prefix that labels the SOAP encoding namespace.
           Defaults to SOAP-ENC.

       soapversion(optional value)
               $serialize-&gt;soapversion(&apos;1.2&apos;);

           If no parameter is given, returns the current version of SOAP that is
           being used as the basis for serializing messages. If a parameter is
           given, attempts to set that as the version of SOAP being used. The
           value should be either 1.1 or 1.2. When the SOAP version is being
           set, the package selects new URNs for envelope and encoding spaces
           and also calls the xmlschema method to set the appropriate schema
           definition.

       xmlschema(optional value)
               $serialize-&gt;xmlschema($xml_schema_1999);

           Gets or sets the URN for the schema being used to express the
           structure of the XML generated by the serializer. If setting the
           value, the input must be the full URN for the new schema and is
           checked against the list of known SOAP schemas.

       register_ns
           The register_ns subroutine allows users to register a global
           namespace with the SOAP Envelope. The first parameter is the
           namespace, the second parameter to this subroutine is an optional
           prefix. If a prefix is not provided, one will be generated
           automatically for you. All namespaces registered with the serializer
           get declared in the &lt;soap:Envelope /&gt; element.

       find_prefix
           The find_prefix subroutine takes a namespace as a parameter and
           returns the assigned prefix to that namespace. This eliminates the
           need to declare and redeclare namespaces within an envelope. This
           subroutine is especially helpful in determining the proper prefix
           when assigning a type to a SOAP::Data element. A good example of how
           this might be used is as follows:

               SOAP::Data-&gt;name(&quot;foo&quot; =&gt; $inputParams{&apos;foo&apos;})
                  -&gt;type($client-&gt;serializer-&gt;find_prefix(&apos;urn:Foo&apos;).&apos;:Foo&apos;);

CUSTOM DATA TYPES
       When serializing an object, or blessed hash reference, into XML,
       &quot;SOAP::Serializer&quot; first checks to see if a subroutine has been defined
       for the corresponding class name. For example, in the code below,
       &quot;SOAP::Serializer&quot; will check to see if a subroutine called
       &quot;as_MyModule__MyPackage&quot; has been defined. If so, then it will pass $foo
       to that subroutine along with other data known about the &quot;SOAP::Data&quot;
       element being encoded.

          $foo = MyModule::MyPackage-&gt;new;
          my $client = SOAP::Lite
             -&gt;uri($NS)
             -&gt;proxy($HOST);
          $som = $client-&gt;someMethod(SOAP::Data-&gt;name(&quot;foo&quot; =&gt; $foo));

as_TypeName SUBROUTINE REQUIREMENTS
       Naming Convention
           The subroutine should always be prepended with &quot;as_&quot; followed by the
           type&apos;s name. The type&apos;s name must have all colons (&apos;:&apos;) substituded
           with an underscore (&apos;_&apos;).

       Input
           The input to &quot;as_TypeName&quot; will have at least one parameter, and at
           most four parameters. The first parameter will always be the value or
           the object to be encoded. The following three parameters depend upon
           the context of the value/object being encoded.

           If the value/object being encoded was part of a &quot;SOAP::Data&quot; object
           (as in the above example), then the second, third and fourth
           parameter will be the &quot;SOAP::Data&quot; element&apos;s name, type, and
           attribute set respectively. If on the other hand, the value/object
           being encoded is not part of a &quot;SOAP::Data&quot; object, as in the code
           below:

              $foo = MyModule::MyPackage-&gt;new;
              my $client = SOAP::Lite
                 -&gt;uri($NS)
                 -&gt;proxy($HOST);
              $som = $client-&gt;someMethod($foo);

           Then the second and third parameters will be the class name of the
           value/object being encoded (e.g. &quot;MyModule::MyPackage&quot; in the example
           above), and the fourth parameter will be an empty hash.

       Output
           The encoding subroutine must return an array containing three
           elements: 1) the name of the XML element, 2) a hash containing the
           attributes to be placed into the element, and 3) the value of the
           element.

AUTOTYPING
       When the type of an element has not been declared explicitly, SOAP::Lite
       must &quot;guess&quot; at the object&apos;s type. That is due to the fact that the only
       form of introspection that Perl provides (through the use of the &quot;ref&quot;
       subroutine) does not provide enough information to &quot;SOAP::Serializer&quot; to
       allow SOAP::Lite to determine the exact type of an element being
       serialized.

       To work around this limitation, the &quot;SOAP::Serializer::typelookup&quot; hash
       was created. This hash is populated with all the data types that the
       current &quot;SOAP::Serializer&quot; can auto detect. Users and developers are free
       to modify the contents of this hash allowing them to register new data
       types with the system.

       When &quot;SOAP::Serializer&quot; is asked to encode an object into XML, it goes
       through the following steps. First, &quot;SOAP::Serializer&quot; checks to see if a
       type has been explicitly stated for the current object. If a type has
       been provided &quot;SOAP::Serializer&quot; checks to see if an &quot;as_TypeName&quot;
       subroutine as been defined for that type. If such a subroutine exists,
       then &quot;SOAP::Serializer&quot; passes the object to it to be encoded. If the
       subroutine does not exist, or the type has not been provided, then
       &quot;SOAP::Serializer&quot; must attempt to &quot;guess&quot; the type of the object being
       serialized.

       To do so, &quot;SOAP::Serializer&quot; runs in sequence a set of tests stored in
       the &quot;SOAP::Serializer::typelookup&quot; hash. &quot;SOAP::Serializer&quot; continues to
       run each test until one of the tests returns true, indicating that the
       type of the object has been detected. When the type of the object has
       been detected, then &quot;SOAP::Serializer&quot; passes the object to the encoding
       subroutine that corresponds with the test that was passed. If all the
       tests fail, and the type was not determined, then &quot;SOAP::Serializer&quot; will
       as a last resort encode the object based on one of the four basic data
       types known to Perl: REF, SCALAR, ARRAY and HASH.

       The following table contains the set of data types detectable by
       &quot;SOAP::Lite&quot; by default and the order in which their corresponding test
       subroutine will be run, according to their precedence value.
&#12;         Table 1 - Autotyping Precedence

         TYPENAME    PRECEDENCE VALUE
         ----------------------------
         base64      10
         int         20
         long        25
         float       30
         gMonth      35
         gDay        40
         gYear       45
         gMonthDay   50
         gYearMonth  55
         date        60
         time        70
         dateTime    75
         duration    80
         boolean     90
         anyURI      95
         string      100

   REGISTERING A NEW DATA TYPE
       To register a new data type that can be automatically detected by
       &quot;SOAP::Lite&quot; and then serialized into XML, the developer must provide the
       following four things:

       &#183;   The name of the new data type.

       &#183;   A subroutine that is capable of detecting whether a value passed to
           it is of the corresponding data type.

       &#183;   A number representing the test subroutine&apos;s precedence relative to
           all the other types&apos; test subroutinestypes. See Table 1 - Autotyping
           Precedence.

       &#183;   A subroutine that is capable of providing &quot;SOAP::Serializer&quot; with the
           information necessary to serialize an object of the corresponding
           data type into XML.

       EXAMPLE 1

       If, for example, you wish to create a new datatype called &quot;uriReference&quot;
       for which you would like Perl values to be automatically detected and
       serialized into, then you follow these steps.

       Step 1: Write a Test Subroutine

       The test subroutine will have passed to it by &quot;SOAP::Serializer&quot; a value
       to be tested. The test subroutine must return 1 if the value passed to it
       is of the corresponding type, or else it must return 0.

           sub SOAP::Serializer::uriReferenceTest {
             my ($value) = @_;
             return 1 if ($value =~ m!^http://!);
             return 0;
           }

       Step 2: Write an Encoding Subroutine

       The encoding subroutine provides &quot;SOAP::Serializer&quot; with the data
       necessary to encode the value passed to it into XML. The encoding
       subroutine name&apos;s should be of the following format: &quot;as_&quot;&lt;Type Name&gt;.

       The encoding subroutine will have passed to it by &quot;SOAP::Serializer&quot; four
       parameters: the value to be encoded, the name of the element being
       encoded, the assumed type of the element being encoded, and a reference
       to a hash containing the attributes of the element being encoded. The
       encoding subroutine must return an array representing the encoded
       datatype. &quot;SOAP::Serializer&quot; will use the contents of this array to
       generate the corresponding XML of the value being encoded, or serialized.
       This array contains the following 3 elements: the name of the XML
       element, a hash containing the attributes to be placed into the element,
       and the value of the element.

         sub SOAP::Serializer::as_uriReference {
           my $self = shift;
           my($value, $name, $type, $attr) = @_;
           return [$name, {&apos;xsi:type&apos; =&gt; &apos;xsd:uriReference&apos;, %$attr}, $value];
         }

       Step 3: Register the New Data Type

       To register the new data type, simply add the type to the
       &quot;SOAP::Serializer::typelookup&quot; hash using the type name as the key, and
       an array containing the precedence value, the test subroutine, and the
       encoding subroutine.

         $s-&gt;typelookup-&gt;{uriReference}
             = [11, \&amp;uriReferenceTest, &apos;as_uriReference&apos;];

       Tip: As a short hand, you could just as easily use an anonymous test
       subroutine when registering the new datatype in place of the
       &quot;urlReferenceTest&quot; subroutine above. For example:

         $s-&gt;typelookup-&gt;{uriReference}
             = [11, sub { $_[0] =~ m!^http://! }, &apos;as_uriReference&apos;];

       Once complete, &quot;SOAP::Serializer&quot; will be able to serialize the following
       &quot;SOAP::Data&quot; object into XML:

         $elem = SOAP::Data-&gt;name(&quot;someUri&quot; =&gt; &apos;http://yahoo.com&apos;)-&gt;type(&apos;uriReference&apos;);

       &quot;SOAP::Serializer&quot; will also be able to automatically determine and
       serialize the following untyped &quot;SOAP::Data&quot; object into XML:

         $elem = SOAP::Data-&gt;name(&quot;someUri&quot; =&gt; &apos;http://yahoo.com&apos;);

ACKNOWLEDGEMENTS
       Special thanks to O&apos;Reilly publishing which has graciously allowed
       SOAP::Lite to republish and redistribute large excerpts from Programming
       Web Services with Perl, mainly the SOAP::Lite reference found in Appendix
       B.

COPYRIGHT
       Copyright (C) 2000-2004 Paul Kulchenko. All rights reserved.

       This library is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.

AUTHORS
       Paul Kulchenko (paulclinger@yahoo.com)

       Randy J. Ray (rjray@blackperl.com)

       Byrne Reese (byrne@majordojo.com)



perl v5.12.4                       2011-08-15              SOAP::Serializer(3pm)

</pre></body></html>
