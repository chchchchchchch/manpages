<html>
<head><meta charset=utf-8/>
<title>SSL_alert_type_string, SSL_alert_type_string_long, SSL_alert_desc_string, SSL_alert_desc_string_long - get textual description of alert information</title></head>
<body><pre>

SSL_alert_type_string(3SSL)          OpenSSL         SSL_alert_type_string(3SSL)



NAME
       SSL_alert_type_string, SSL_alert_type_string_long, SSL_alert_desc_string,
       SSL_alert_desc_string_long - get textual description of alert information

SYNOPSIS
        #include &lt;openssl/ssl.h&gt;

        const char *SSL_alert_type_string(int value);
        const char *SSL_alert_type_string_long(int value);

        const char *SSL_alert_desc_string(int value);
        const char *SSL_alert_desc_string_long(int value);

DESCRIPTION
       SSL_alert_type_string() returns a one letter string indicating the type
       of the alert specified by value.

       SSL_alert_type_string_long() returns a string indicating the type of the
       alert specified by value.

       SSL_alert_desc_string() returns a two letter string as a short form
       describing the reason of the alert specified by value.

       SSL_alert_desc_string_long() returns a string describing the reason of
       the alert specified by value.

NOTES
       When one side of an SSL/TLS communication wants to inform the peer about
       a special situation, it sends an alert. The alert is sent as a special
       message and does not influence the normal data stream (unless its
       contents results in the communication being canceled).

       A warning alert is sent, when a non-fatal error condition occurs. The
       &quot;close notify&quot; alert is sent as a warning alert. Other examples for non-
       fatal errors are certificate errors (&quot;certificate expired&quot;, &quot;unsupported
       certificate&quot;), for which a warning alert may be sent.  (The sending party
       may however decide to send a fatal error.) The receiving side may cancel
       the connection on reception of a warning alert on it discretion.

       Several alert messages must be sent as fatal alert messages as specified
       by the TLS RFC. A fatal alert always leads to a connection abort.

RETURN VALUES
       The following strings can occur for SSL_alert_type_string() or
       SSL_alert_type_string_long():

       &quot;W&quot;/&quot;warning&quot;
       &quot;F&quot;/&quot;fatal&quot;
       &quot;U&quot;/&quot;unknown&quot;
           This indicates that no support is available for this alert type.
           Probably value does not contain a correct alert message.

       The following strings can occur for SSL_alert_desc_string() or
       SSL_alert_desc_string_long():

       &quot;CN&quot;/&quot;close notify&quot;
           The connection shall be closed. This is a warning alert.

       &quot;UM&quot;/&quot;unexpected message&quot;
           An inappropriate message was received. This alert is always fatal and
           should never be observed in communication between proper
           implementations.

       &quot;BM&quot;/&quot;bad record mac&quot;
           This alert is returned if a record is received with an incorrect MAC.
           This message is always fatal.

       &quot;DF&quot;/&quot;decompression failure&quot;
           The decompression function received improper input (e.g. data that
           would expand to excessive length). This message is always fatal.

       &quot;HF&quot;/&quot;handshake failure&quot;
           Reception of a handshake_failure alert message indicates that the
           sender was unable to negotiate an acceptable set of security
           parameters given the options available. This is a fatal error.

       &quot;NC&quot;/&quot;no certificate&quot;
           A client, that was asked to send a certificate, does not send a
           certificate (SSLv3 only).

       &quot;BC&quot;/&quot;bad certificate&quot;
           A certificate was corrupt, contained signatures that did not verify
           correctly, etc

       &quot;UC&quot;/&quot;unsupported certificate&quot;
           A certificate was of an unsupported type.

       &quot;CR&quot;/&quot;certificate revoked&quot;
           A certificate was revoked by its signer.

       &quot;CE&quot;/&quot;certificate expired&quot;
           A certificate has expired or is not currently valid.

       &quot;CU&quot;/&quot;certificate unknown&quot;
           Some other (unspecified) issue arose in processing the certificate,
           rendering it unacceptable.

       &quot;IP&quot;/&quot;illegal parameter&quot;
           A field in the handshake was out of range or inconsistent with other
           fields. This is always fatal.

       &quot;DC&quot;/&quot;decryption failed&quot;
           A TLSCiphertext decrypted in an invalid way: either it wasn&apos;t an even
           multiple of the block length or its padding values, when checked,
           weren&apos;t correct. This message is always fatal.

       &quot;RO&quot;/&quot;record overflow&quot;
           A TLSCiphertext record was received which had a length more than
           2^14+2048 bytes, or a record decrypted to a TLSCompressed record with
           more than 2^14+1024 bytes. This message is always fatal.

       &quot;CA&quot;/&quot;unknown CA&quot;
           A valid certificate chain or partial chain was received, but the
           certificate was not accepted because the CA certificate could not be
           located or couldn&apos;t be matched with a known, trusted CA.  This
           message is always fatal.

       &quot;AD&quot;/&quot;access denied&quot;
           A valid certificate was received, but when access control was
           applied, the sender decided not to proceed with negotiation.  This
           message is always fatal.

       &quot;DE&quot;/&quot;decode error&quot;
           A message could not be decoded because some field was out of the
           specified range or the length of the message was incorrect. This
           message is always fatal.

       &quot;CY&quot;/&quot;decrypt error&quot;
           A handshake cryptographic operation failed, including being unable to
           correctly verify a signature, decrypt a key exchange, or validate a
           finished message.

       &quot;ER&quot;/&quot;export restriction&quot;
           A negotiation not in compliance with export restrictions was
           detected; for example, attempting to transfer a 1024 bit ephemeral
           RSA key for the RSA_EXPORT handshake method. This message is always
           fatal.

       &quot;PV&quot;/&quot;protocol version&quot;
           The protocol version the client has attempted to negotiate is
           recognized, but not supported. (For example, old protocol versions
           might be avoided for security reasons). This message is always fatal.

       &quot;IS&quot;/&quot;insufficient security&quot;
           Returned instead of handshake_failure when a negotiation has failed
           specifically because the server requires ciphers more secure than
           those supported by the client. This message is always fatal.

       &quot;IE&quot;/&quot;internal error&quot;
           An internal error unrelated to the peer or the correctness of the
           protocol makes it impossible to continue (such as a memory allocation
           failure). This message is always fatal.

       &quot;US&quot;/&quot;user canceled&quot;
           This handshake is being canceled for some reason unrelated to a
           protocol failure. If the user cancels an operation after the
           handshake is complete, just closing the connection by sending a
           close_notify is more appropriate. This alert should be followed by a
           close_notify. This message is generally a warning.

       &quot;NR&quot;/&quot;no renegotiation&quot;
           Sent by the client in response to a hello request or by the server in
           response to a client hello after initial handshaking.  Either of
           these would normally lead to renegotiation; when that is not
           appropriate, the recipient should respond with this alert; at that
           point, the original requester can decide whether to proceed with the
           connection. One case where this would be appropriate would be where a
           server has spawned a process to satisfy a request; the process might
           receive security parameters (key length, authentication, etc.) at
           startup and it might be difficult to communicate changes to these
           parameters after that point. This message is always a warning.

       &quot;UP&quot;/&quot;unknown PSK identity&quot;
           Sent by the server to indicate that it does not recognize a PSK
           identity or an SRP identity.

       &quot;UK&quot;/&quot;unknown&quot;
           This indicates that no description is available for this alert type.
           Probably value does not contain a correct alert message.

SEE ALSO
       ssl(3), SSL_CTX_set_info_callback(3)



1.0.1e                             2013-02-11        SSL_alert_type_string(3SSL)

</pre></body></html>
