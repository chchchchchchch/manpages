<html>
<head><meta charset=utf-8/>
<title>Text::BibTeX::Structure - provides base classes for user structure modules</title></head>
<body><pre>

Text::BibTeX::StructureUser)Contributed Perl DocumenText::BibTeX::Structure(3pm)



NAME
       Text::BibTeX::Structure - provides base classes for user structure
       modules

SYNOPSIS
          # Define a &apos;Foo&apos; structure for BibTeX databases: first, the
          # structure class:

          package Text::BibTeX::FooStructure;
          @ISA = (&apos;Text::BibTeX::Structure&apos;);

          sub known_option
          {
             my ($self, $option) = @_;

             ...
          }

          sub default_option
          {
             my ($self, $option) = @_;

             ...
          }

          sub describe_entry
          {
             my $self = shift;

             $self-&gt;set_fields ($type,
                                \@required_fields,
                                \@optional_fields,
                                [$constraint_1, $constraint_2, ...]);
             ...
          }


          # Now, the structured entry class

          package Text::BibTeX::FooEntry;
          @ISA = (&apos;Text::BibTeX::StructuredEntry&apos;);

          # define whatever methods you like

DESCRIPTION
       The module &quot;Text::BibTeX::Structure&quot; provides two classes that form the
       basis of the btOOL &quot;structure module&quot; system.  This system is how
       database structures are defined and imposed on BibTeX files, and provides
       an elegant synthesis of object-oriented techniques with BibTeX-style
       database structures.  Nothing described here is particularly deep or
       subtle; anyone familiar with object-oriented programming should be able
       to follow it.  However, a fair bit of jargon in invented and tossed
       around, so pay attention.

       A database structure, in btOOL parlance, is just a set of allowed entry
       types and the rules for fields in each of those entry types.  Currently,
       there are three kinds of rules that apply to fields: some fields are
       required, meaning they must be present in every entry for a given type;
       some are optional, meaning they may be present, and will be used if they
       are; other fields are members of constraint sets, which are explained in
       &quot;Field lists and constraint sets&quot; below.
&#12;       A btOOL structure is implemented with two classes: the structure class
       and the structured entry class.  The former defines everything that
       applies to the structure as a whole (allowed types and field rules).  The
       latter provides methods that operate on individual entries which conform
       (or are supposed to conform) to the structure.  The two classes provided
       by the &quot;Text::BibTeX::Structure&quot; module are &quot;Text::BibTeX::Structure&quot; and
       &quot;Text::BibTeX::StructuredEntry&quot;; these serve as base classes for,
       respectively, all structure classes and all structured entry classes.
       One canonical structure is provided as an example with btOOL: the &quot;Bib&quot;
       structure, which (via the &quot;BibStructure&quot; and &quot;BibEntry&quot; classes) provides
       the same functionality as the standard style files of BibTeX 0.99.  It is
       hoped that other programmers will write new bibliography-related
       structures, possibly deriving from the &quot;Bib&quot; structure, to emulate some
       of the functionality that is available through third-party BibTeX style
       files.

       The purpose of this manual page is to describe the whole &quot;structure
       module&quot; system.  It is mainly for programmers wishing to implement a new
       database structure for data files with BibTeX syntax; if you are
       interested in the particular rules for the BibTeX-emulating &quot;Bib&quot;
       structure, see Text::BibTeX::Bib.

       Please note that the &quot;Text::BibTeX&quot; prefix is dropped from most module
       and class names in this manual page, except where necessary.

STRUCTURE CLASSES
       Structure classes have two roles: to define the list of allowed types and
       field rules, and to handle structure options.

   Field lists and constraint sets
       Field lists and constraint sets define the database structure for a
       particular entry type: that is, they specify the rules which an entry
       must follow to conform to the structure (assuming that entry is of an
       allowed type).  There are three components to the field rules for each
       entry type: a list of required fields, a list of optional fields, and
       field constraints.  Required and optional fields should be obvious to
       anyone with BibTeX experience: all required fields must be present, and
       any optional fields that are present have some meaning to the structure.
       (One could conceive of a &quot;strict&quot; interpretation, where any field not
       mentioned in the official definition is disallowed; this would be
       contrary to the open spirit of BibTeX databases, but could be useful in
       certain applications where a stricter level of control is desired.
       Currently, btOOL does not offer such an option.)

       Field constraints capture the &quot;one or the other, but not both&quot; type of
       relationships present for some entry types in the BibTeX standard style
       files.  Most BibTeX documentation glosses over the distinction between
       mutually constrained fields and required/optional fields.  For instance,
       one of the standard entry types is &quot;book&quot;, and &quot;&quot;author&quot; or &quot;editor&quot;&quot; is
       given in the list of required fields for that type.  The meaning of this
       is that an entry of type &quot;book&quot; must have either the &quot;author&quot; or &quot;editor&quot;
       fields, but not both.  Likewise, the &quot;&quot;volume&quot; or &quot;number&quot;&quot; are listed
       under the &quot;optional fields&quot; heading for &quot;book&quot; entries; it would be more
       accurate to say that every &quot;book&quot; entry may have one or the other, or
       neither, of &quot;volume&quot; or &quot;number&quot;---but not both.

       btOOL attempts to clarify this situation by creating a third category of
       fields, those that are mutually constrained.  For instance, neither
       &quot;author&quot; nor &quot;editor&quot; appears in the list of required fields for the
       &quot;inbook&quot; type according to btOOL; rather, a field constraint is created
       to express this relationship:

          [1, 1, [&apos;author&apos;, &apos;editor&apos;]]

       That is, a field constraint is a reference to a three-element list.  The
       last element is a reference to the constraint set, the list of fields to
       which the constraint applies.  (Calling this a set is a bit inaccurate,
       as there are conditions in which the order of fields matters---see the
       &quot;check_field_constraints&quot; method in &quot;METHODS 2: BASE STRUCTURED ENTRY
       CLASS&quot;.)  The first two elements are the minimum and maximum number of
       fields from the constraint set that must be present for an entry to
       conform to the constraint.  This constraint thus expresses that there
       must be exactly one (&gt;= 1 and &lt;= 1) of the fields &quot;author&quot; and &quot;editor&quot;
       in a &quot;book&quot; entry.

       The &quot;either one or neither, but not both&quot; constraint that applies to the
       &quot;volume&quot; and &quot;number&quot; fields for &quot;book&quot; entries is expressed slightly
       differently:

          [0, 1, [&apos;volume&apos;, &apos;number&apos;]]

       That is, either 0 or 1, but not the full 2, of &quot;volume&quot; and &quot;number&quot; may
       be present.

       It is important to note that checking and enforcing field constraints is
       based purely on counting which fields from a set are actually present;
       this mechanism can&apos;t capture &quot;x must be present if y is&quot; relationships.

       The requirements imposed on the actual structure class are simple: it
       must provide a method &quot;describe_entry&quot; which sets up a fancy data
       structure describing the allowed entry types and all the field rules for
       those types.  The &quot;Structure&quot; class provides methods (inherited by a
       particular structure class) to help particular structure classes create
       this data structure in a consistent, controlled way.  For instance, the
       &quot;describe_structure&quot; method in the BibTeX 0.99-emulating &quot;BibStructure&quot;
       class is quite simple:

          sub describe_entry
          {
             my $self = shift;

             # series of 13 calls to $self-&gt;set_fields (one for each standard
             # entry type)
          }

       One of those calls to the &quot;set_fields&quot; method defines the rules for
       &quot;book&quot; entries:

          $self-&gt;set_fields (&apos;book&apos;,
                             [qw(title publisher year)],
                             [qw(series address edition month note)],
                             [1, 1, [qw(author editor)]],
                             [0, 1, [qw(volume number)]]);

       The first field list is the list of required fields, and the second is
       the list of optional fields.  Any number of field constraints may follow
       the list of optional fields; in this case, there are two, one for each of
       the constraints (&quot;author&quot;/&quot;editor&quot; and &quot;volume&quot;/&quot;number&quot;) described
       above.  At no point is a list of allowed types explicitly supplied;
       rather, each call to &quot;set_fields&quot; adds one more allowed type.

       New structure modules that derive from existing ones will probably use
       the &quot;add_fields&quot; method (and possibly &quot;add_constraints&quot;) to augment an
       existing entry type.  Adding new types should be done with &quot;set_fields&quot;,
       though.

   Structure options
       The other responsibility of structure classes is to handle structure
       options.  These are scalar values that let the user customize the
       behaviour of both the structure class and the structured entry class.
       For instance, one could have an option to enable &quot;extended structure&quot;,
       which might add on a bunch of new entry types and new fields.  (In this
       case, the &quot;describe_entry&quot; method would have to pay attention to this
       option and modify its behaviour accordingly.)  Or, one could have options
       to control how the structured entry class sorts or formats entries (for
       bibliography structures such as &quot;Bib&quot;).

       The easy way to handle structure options is to provide two methods,
       &quot;known_option&quot; and &quot;default_option&quot;.  These return, respectively, whether
       a given option is supported, and what its default value is.  (If your
       structure doesn&apos;t support any options, you can just inherit these methods
       from the &quot;Structure&quot; class.  The default &quot;known_option&quot; returns false for
       all options, and its companion &quot;default_option&quot; crashes with an &quot;unknown
       option&quot; error.)

       Once &quot;known_option&quot; and &quot;default_option&quot; are provided, the structure
       class can sit back and inherit the more visible &quot;set_options&quot; and
       &quot;get_options&quot; methods from the &quot;Structure&quot; class.  These are the methods
       actually used to modify/query options, and will be used by application
       programs to customize the structure module&apos;s behaviour, and by the
       structure module itself to pay attention to the user&apos;s wishes.

       Options should generally have pure string values, so that the generic
       set_options method doesn&apos;t have to parse user-supplied strings into some
       complicated structure.  However, &quot;set_options&quot; will take any scalar
       value, so if the structure module clearly documents its requirements, the
       application program could supply a structure that meets its needs.  Keep
       in mind that this requires cooperation between the application and the
       structure module; the intermediary code in &quot;Text::BibTeX::Structure&quot;
       knows nothing about the format or syntax of your structure&apos;s options, and
       whatever scalar the application passes via &quot;set_options&quot; will be stored
       for your module to retrieve via &quot;get_options&quot;.

       As an example, the &quot;Bib&quot; structure supports a number of &quot;markup&quot; options
       that allow applications to control the markup language used for
       formatting bibliographic entries.  These options are naturally paired, as
       formatting commands in markup languages generally have to be turned on
       and off.  The &quot;Bib&quot; structure thus expects references to two-element
       lists for markup options; to specify LaTeX 2e-style emphasis for book
       titles, an application such as &quot;btformat&quot; would set the &quot;btitle_mkup&quot;
       option as follows:

          $structure-&gt;set_options (btitle_mkup =&gt; [&apos;\emph{&apos;, &apos;}&apos;]);

       Other options for other structures might have a more complicated
       structure, but it&apos;s up to the structure class to document and enforce
       this.

STRUCTURED ENTRY CLASSES
       A structured entry class defines the behaviour of individual entries
       under the regime of a particular database structure.  This is the raison
       d&apos;etre for any database structure: the structure class merely lays out
       the rules for entries to conform to the structure, but the structured
       entry class provides the methods that actually operate on individual
       entries.  Because this is completely open-ended, the requirements of a
       structured entry class are much less rigid than for a structure class.
       In fact, all of the requirements of a structured entry class can be met
       simply by inheriting from &quot;Text::BibTeX::StructuredEntry&quot;, the other
       class provided by the &quot;Text::BibTeX::Structure&quot; module.  (For the record,
       those requirements are: a structured entry class must provide the entry
       parse/query/manipulate methods of the &quot;Entry&quot; class, and it must provide
       the &quot;check&quot;, &quot;coerce&quot;, and &quot;silently_coerce&quot; methods of the
       &quot;StructuredEntry&quot; class.  Since &quot;StructuredEntry&quot; inherits from &quot;Entry&quot;,
       both of these requirements are met &quot;for free&quot; by structured entry classes
       that inherit from &quot;Text::BibTeX::StructuredEntry&quot;, so naturally this is
       the recommended course of action!)

       There are deliberately no other methods required of structured entry
       classes.  A particular application (eg. &quot;btformat&quot; for bibliography
       structures) will require certain methods, but it&apos;s up to the application
       and the structure module to work out the requirements through
       documentation.

CLASS INTERACTIONS
       Imposing a database structure on your entries sets off a chain reaction
       of interactions between various classes in the &quot;Text::BibTeX&quot; library
       that should be transparent when all goes well.  It could prove confusing
       if things go wrong and you have to go wading through several levels of
       application program, core &quot;Text::BibTeX&quot; classes, and some structure
       module.

       The justification for this complicated behaviour is that it allows you to
       write programs that will use a particular structured module without
       knowing the name of the structure when you write the program.  Thus, the
       user can supply a database structure, and ultimately the entry objects
       you manipulate will be blessed into a class supplied by the structure
       module.  A short example will illustrate this.

       Typically, a &quot;Text::BibTeX&quot;-based program is based around a kernel of
       code like this:

          $bibfile = new Text::BibTeX::File &quot;foo.bib&quot;;
          while ($entry = new Text::BibTeX::Entry $bibfile)
          {
             # process $entry
          }

       In this case, nothing fancy is happening behind the scenes: the $bibfile
       object is blessed into the &quot;Text::BibTeX::File&quot; class, and $entry is
       blessed into &quot;Text::BibTeX::Entry&quot;.  This is the conventional behaviour
       of Perl classes, but it is not the only possible behaviour.  Let us now
       suppose that $bibfile is expected to conform to a database structure
       specified by $structure (presumably a user-supplied value, and thus
       unknown at compile-time):

          $bibfile = new Text::BibTeX::File &quot;foo.bib&quot;;
          $bibfile-&gt;set_structure ($structure);
          while ($entry = new Text::BibTeX::Entry $bibfile)
          {
             # process $entry
          }

       A lot happens behind the scenes with the call to $bibfile&apos;s
       &quot;set_structure&quot; method.  First, a new structure object is created from
       $structure.  The structure name implies the name of a Perl module---the
       structure module---which is &quot;require&quot;&apos;d by the &quot;Structure&quot; constructor.
       (The main consequence of this is that any compile-time errors in your
       structure module will not be revealed until a
       &quot;Text::BibTeX::File::set_structure&quot; or &quot;Text::BibTeX::Structure::new&quot;
       call attempts to load it.)

       Recall that the first responsibility of a structure module is to define a
       structure class.  The &quot;structure object&quot; created by the &quot;set_structure&quot;
       method call is actually an object of this class; this is the first bit of
       trickery---the structure object (buried behind the scenes) is blessed
       into a class whose name is not known until run-time.

       Now, the behaviour of the &quot;Text::BibTeX::Entry::new&quot; constructor changes
       subtly: rather than returning an object blessed into the
       &quot;Text::BibTeX::Entry&quot; class as you might expect from the code, the object
       is blessed into the structured entry class associated with $structure.

       For example, if the value of $structure is &quot;Foo&quot;, that means the user has
       supplied a module implementing the &quot;Foo&quot; structure.  (Ordinarily, this
       module would be called &quot;Text::BibTeX::Foo&quot;---but you can customize this.)
       Calling the &quot;set_structure&quot; method on $bibfile will attempt to create a
       new structure object via the &quot;Text::BibTeX::Structure&quot; constructor, which
       loads the structure module &quot;Text::BibTeX::Foo&quot;.  Once this module is
       successfully loaded, the new object is blessed into its structure class,
       which will presumably be called &quot;Text::BibTeX::FooStructure&quot; (again, this
       is customizable).  The new object is supplied with the user&apos;s structure
       options via the &quot;set_options&quot; method (usually inherited), and then it is
       asked to describe the actual entry layout by calling its &quot;describe_entry&quot;
       method.  This, in turn, will usually call the inherited &quot;set_fields&quot;
       method for each entry type in the database structure.  When the
       &quot;Structure&quot; constructor is finished, the new structure object is stored
       in the &quot;File&quot; object (remember, we started all this by calling
       &quot;set_structure&quot; on a &quot;File&quot; object) for future reference.

       Then, when a new &quot;Entry&quot; object is created and parsed from that
       particular &quot;File&quot; object, some more trickery happens.  Trivially, the
       structure object stored in the &quot;File&quot; object is also stored in the
       &quot;Entry&quot; object.  (The idea is that entries could belong to a database
       structure independently of any file, but usually they will just get the
       structure that was assigned to their database file.)  More importantly,
       the new &quot;Entry&quot; object is re-blessed into the structured entry class
       supplied by the structure module---presumably, in this case,
       &quot;Text::BibTeX::FooEntry&quot; (also customizable).

       Once all this sleight-of-hand is accomplished, the application may treat
       its entry objects as objects of the structured entry class for the &quot;Foo&quot;
       structure---they may call the check/coerce methods inherited from
       &quot;Text::BibTeX::StructuredEntry&quot;, and they may also call any methods
       specific to entries for this particular database structure.  What these
       methods might be is up to the structure implementor to decide and
       document; thus, applications may be specific to one particular database
       structure, or they may work on all structures that supply certain
       methods.  The choice is up to the application developer, and the range of
       options open to him depends on which methods structure implementors
       provide.

EXAMPLE
       For example code, please refer to the source of the &quot;Bib&quot; module and the
       &quot;btcheck&quot;, &quot;btsort&quot;, and &quot;btformat&quot; applications supplied with
       &quot;Text::BibTeX&quot;.

METHODS 1: BASE STRUCTURE CLASS
       The first class provided by the &quot;Text::BibTeX::Structure&quot; module is
       &quot;Text::BibTeX::Structure&quot;.  This class is intended to provide methods
       that will be inherited by user-supplied structure classes; such classes
       should not override any of the methods described here (except
       &quot;known_option&quot; and &quot;default_option&quot;) without very good reason.
       Furthermore, overriding the &quot;new&quot; method would be useless, because in
       general applications won&apos;t know the name of your structure class---they
       can only call &quot;Text::BibTeX::Structure::new&quot; (usually via
       &quot;Text::BibTeX::File::set_structure&quot;).

       Finally, there are three methods that structure classes should implement:
       &quot;known_option&quot;, &quot;default_option&quot;, and &quot;describe_entry&quot;.  The first two
       are described in &quot;Structure options&quot; above, the latter in &quot;Field lists
       and constraint sets&quot;.  Note that &quot;describe_entry&quot; depends heavily on the
       &quot;set_fields&quot;, &quot;add_fields&quot;, and &quot;add_constraints&quot; methods described here.

   Constructor/simple query methods
       new (STRUCTURE, [OPTION =&gt; VALUE, ...])
           Constructs a new structure object---not a &quot;Text::BibTeX::Structure&quot;
           object, but rather an object blessed into the structure class
           associated with STRUCTURE.  More precisely:

           &#183;   Loads (with &quot;require&quot;) the module implementing STRUCTURE.  In the
               absence of other information, the module name is derived by
               appending STRUCTURE to &quot;Text::BibTeX::&quot;---thus, the module
               &quot;Text::BibTeX::Bib&quot; implements the &quot;Bib&quot; structure.  Use the
               pseudo-option &quot;module&quot; to override this module name.  For
               instance, if the structure &quot;Foo&quot; is implemented by the module
               &quot;Foo&quot;:

                  $structure = new Text::BibTeX::Structure
                     (&apos;Foo&apos;, module =&gt; &apos;Foo&apos;);

               This method &quot;die&quot;s if there are any errors loading/compiling the
               structure module.

           &#183;   Verifies that the structure module provides a structure class and
               a structured entry class.  The structure class is named by
               appending &quot;Structure&quot; to the name of the module, and the
               structured entry class by appending &quot;Entry&quot;.  Thus, in the
               absence of a &quot;module&quot; option, these two classes (for the &quot;Bib&quot;
               structure) would be named &quot;Text::BibTeX::BibStructure&quot; and
               &quot;Text::BibTeX::BibEntry&quot;.  Either or both of the default class
               names may be overridden by having the structure module return a
               reference to a hash (as opposed to the traditional 1 returned by
               modules).  This hash could then supply a &quot;structure_class&quot;
               element to name the structure class, and an &quot;entry_class&quot; element
               to name the structured entry class.

               Apart from ensuring that the two classes actually exist, &quot;new&quot;
               verifies that they inherit correctly (from
               &quot;Text::BibTeX::Structure&quot; and &quot;Text::BibTeX::StructuredEntry&quot;
               respectively), and that the structure class provides the required
               &quot;known_option&quot;, &quot;default_option&quot;, and &quot;describe_entry&quot; methods.

           &#183;   Creates the new structure object, and blesses it into the
               structure class.  Supplies it with options by passing all
               (OPTION, VALUE) pairs to its &quot;set_options&quot; method.  Calls its
               &quot;describe_entry&quot; method, which should list the field requirements
               for all entry types recognized by this structure.
               &quot;describe_entry&quot; will most likely use some or all of the
               &quot;set_fields&quot;, &quot;add_fields&quot;, and &quot;add_constraints&quot;
               methods---described below---for this.

       name ()
           Returns the name of the structure described by the object.

       entry_class ()
           Returns the name of the structured entry class associated with this
           structure.

   Field structure description methods
       add_constraints (TYPE, CONSTRAINT, ...)
           Adds one or more field constraints to the structure.  A field
           constraint is specified as a reference to a three-element list; the
           last element is a reference to the list of fields affected, and the
           first two elements are the minimum and maximum number of fields from
           the constraint set allowed in an entry of type TYPE.  See &quot;Field
           lists and constraint sets&quot; for a full explanation of field
           constraints.

       add_fields (TYPE, REQUIRED [, OPTIONAL [, CONSTRAINT, ...]])
           Adds fields to the required/optional lists for entries of type TYPE.
           Can also add field constraints, but you can just as easily use
           &quot;add_constraints&quot; for that.

           REQUIRED and OPTIONAL, if defined, should be references to lists of
           fields to add to the respective field lists.  The CONSTRAINTs, if
           given, are exactly as described for &quot;add_constraints&quot; above.

       set_fields (TYPE, REQUIRED [, OPTIONAL [, CONSTRAINTS, ...]])
           Sets the lists of required/optional fields for entries of type TYPE.
           Identical to &quot;add_fields&quot;, except that the field lists and list of
           constraints are set from scratch here, rather than being added to.

   Field structure query methods
       types ()
           Returns the list of entry types supported by the structure.

       known_type (TYPE)
           Returns true if TYPE is a supported entry type.

       known_field (TYPE, FIELD)
           Returns true if FIELD is in the required list, optional list, or one
           of the constraint sets for entries of type TYPE.

       required_fields (TYPE)
           Returns the list of required fields for entries of type TYPE.

       optional_fields ()
           Returns the list of optional fields for entries of type TYPE.

       field_constraints ()
           Returns the list of field constraints (in the format supplied to
           &quot;add_constraints&quot;) for entries of type TYPE.

   Option methods
       known_option (OPTION)
           Returns false.  This is mainly for the use of derived structures that
           don&apos;t have any options, and thus don&apos;t need to provide their own
           &quot;known_option&quot; method.  Structures that actually offer options should
           override this method; it should return true if OPTION is a supported
           option.

       default_option (OPTION)
           Crashes with an &quot;unknown option&quot; message.  Again, this is mainly for
           use by derived structure classes that don&apos;t actually offer any
           options.  Structures that handle options should override this method;
           every option handled by &quot;known_option&quot; should have a default value
           (which might just be &quot;undef&quot;) that is returned by &quot;default_option&quot;.
           Your &quot;default_options&quot; method should crash on an unknown option,
           perhaps by calling &quot;SUPER::default_option&quot; (in order to ensure
           consistent error messages).  For example:

              sub default_option
              {
                 my ($self, $option) = @_;
                 return $default_options{$option}
                    if exists $default_options{$option};
                 $self-&gt;SUPER::default_option ($option);   # crash
              }

           The default value for an option is returned by &quot;get_options&quot; when
           that options has not been explicitly set with &quot;set_options&quot;.

       set_options (OPTION =&gt; VALUE, ...)
           Sets one or more option values.  (You can supply as many &quot;OPTION =&gt;
           VALUE&quot; pairs as you like, just so long as there are an even number of
           arguments.)  Each OPTION must be handled by the structure module (as
           indicated by the &quot;known_option&quot; method); if not &quot;set_options&quot; will
           &quot;croak&quot;.  Each VALUE may be any scalar value; it&apos;s up to the
           structure module to validate them.

       get_options (OPTION, ...)
           Returns the value(s) of one or more options.  Any OPTION that has not
           been set by &quot;set_options&quot; will return its default value, fetched
           using the &quot;default_value&quot; method.  If OPTION is not supported by the
           structure module, then your program either already crashed (when it
           tried to set it with &quot;set_option&quot;), or it will crash here (thanks to
           calling &quot;default_option&quot;).

METHODS 2: BASE STRUCTURED ENTRY CLASS
       The other class provided by the &quot;Structure&quot; module is &quot;StructuredEntry&quot;,
       the base class for all structured entry classes.  This class inherits
       from &quot;Entry&quot;, so all of its entry query/manipulation methods are
       available.  &quot;StructuredEntry&quot; adds methods for checking that an entry
       conforms to the database structure defined by a structure class.

       It only makes sense for &quot;StructuredEntry&quot; to be used as a base class; you
       would never create standalone &quot;StructuredEntry&quot; objects.  The superficial
       reason for this is that only particular structured-entry classes have an
       actual structure class associated with them, &quot;StructuredEntry&quot; on its own
       doesn&apos;t have any information about allowed types, required fields, field
       constraints, and so on.  For a deeper understanding, consult &quot;CLASS
       INTERACTIONS&quot; above.

       Since &quot;StructuredEntry&quot; derives from &quot;Entry&quot;, it naturally operates on
       BibTeX entries.  Hence, the following descriptions refer to &quot;the
       entry&quot;---this is just the object (entry) being operated on.  Note that
       these methods are presented in bottom-up order, meaning that the methods
       you&apos;re most likely to actually use---&quot;check&quot;, &quot;coerce&quot;, and
       &quot;silently_coerce&quot; are at the bottom.  On a first reading, you&apos;ll probably
       want to skip down to them for a quick summary.

       structure ()
           Returns the object that defines the structure the entry to which is
           supposed to conform.  This will be an instantiation of some structure
           class, and exists mainly so the check/coerce methods can query the
           structure about the types and fields it recognizes.  If, for some
           reason, you wanted to query an entry&apos;s structure about the validity
           of type &quot;foo&quot;, you might do this:

              # assume $entry is an object of some structured entry class, i.e.
              # it inherits from Text::BibTeX::StructuredEntry
              $structure = $entry-&gt;structure;
              $foo_known = $structure-&gt;known_type (&apos;foo&apos;);

       check_type ([WARN])
           Returns true if the entry has a valid type according to its
           structure.  If WARN is true, then an invalid type results in a
           warning being printed.

       check_required_fields ([WARN [, COERCE]])
           Checks that all required fields are present in the entry.  If WARN is
           true, then a warning is printed for every missing field.  If COERCE
           is true, then missing fields are set to the empty string.

           This isn&apos;t generally used by other code; see the &quot;check&quot; and &quot;coerce&quot;
           methods below.

       check_field_constraints ([WARN [, COERCE]])
           Checks that the entry conforms to all of the field constraints
           imposed by its structure.  Recall that a field constraint consists of
           a list of fields, and a minimum and maximum number of those fields
           that must be present in an entry.  For each constraint,
           &quot;check_field_constraints&quot; simply counts how many fields in the
           constraint&apos;s field set are present.  If this count falls below the
           minimum or above the maximum for that constraint and WARN is true, a
           warning is issued.  In general, this warning is of the form &quot;between
           x and y of fields foo, bar, and baz must be present&quot;.  The more
           common cases are handled specially to generate more useful and human-
           friendly warning messages.

           If COERCE is true, then the entry is modified to force it into
           conformance with all field constraints.  How this is done depends on
           whether the violation is a matter of not enough fields present in the
           entry, or of too many fields present.  In the former case, just
           enough fields are added (as empty strings) to meet the requirements
           of the constraint; in the latter case, fields are deleted.  Which
           fields to add or delete is controlled by the order of fields in the
           constraint&apos;s field list.

           An example should clarify this.  For instance, a field constraint
           specifying that exactly one of &quot;author&quot; or &quot;editor&quot; must appear in an
           entry would look like this:

              [1, 1, [&apos;author&apos;, &apos;editor&apos;]]

           Suppose the following entry is parsed and expected to conform to this
           structure:

              @inbook{unknown:1997a,
                title = &quot;An Unattributed Book Chapter&quot;,
                booktitle = &quot;An Unedited Book&quot;,
                publisher = &quot;Foo, Bar \&amp; Company&quot;,
                year = 1997
              }

           If &quot;check_field_constraints&quot; is called on this method with COERCE
           true (which is done by any of the &quot;full_check&quot;, &quot;coerce&quot;, and
           &quot;silently_coerce&quot; methods), then the &quot;author&quot; field is set to the
           empty string.  (We go through the list of fields in the constraint&apos;s
           field set in order -- since &quot;author&quot; is the first missing field, we
           supply it; with that done, the entry now conforms to the
           &quot;author&quot;/&quot;editor&quot; constraint, so we&apos;re done.)

           However, if the same structure was applied to this entry:

              @inbook{smith:1997a,
                author = &quot;John Smith&quot;,
                editor = &quot;Fred Jones&quot;,
                ...
              }

           then the &quot;editor&quot; field would be deleted.  In this case, we allow the
           first field in the constraint&apos;s field list---&quot;author&quot;.  Since only
           one field from the set may be present, all fields after the first one
           are in violation, so they are deleted.

           Again, this method isn&apos;t generally used by other code; rather, it is
           called by &quot;full_check&quot; and its friends below.

       full_check ([WARN [, COERCE]])
           Returns true if an entry&apos;s type and fields are all valid.  That is,
           it calls &quot;check_type&quot;, &quot;check_required_fields&quot;, and
           &quot;check_field_constraints&quot;; if all of them return true, then so does
           &quot;full_check&quot;.  WARN and COERCE are simply passed on to the three
           &quot;check_*&quot; methods: the first controls the printing of warnings, and
           the second decides whether we should modify the entry to force it
           into conformance.

       check ()
           Checks that the entry conforms to the requirements of its associated
           database structure: the type must be known, all required fields must
           be present, and all field constraints must be met.  See &quot;check_type&quot;,
           &quot;check_required_fields&quot;, and &quot;check_field_constraints&quot; for details.

           Calling &quot;check&quot; is the same as calling &quot;full_check&quot; with WARN true
           and COERCE false.

       coerce ()
           Same as &quot;check&quot;, except entries are coerced into conformance with the
           database structure---that is, it&apos;s just like &quot;full_check&quot; with both
           WARN and COERCE true.

       silently_coerce ()
           Same as &quot;coerce&quot;, except warnings aren&apos;t printed---that is, it&apos;s just
           like &quot;full_check&quot; with WARN false and COERCE true.

SEE ALSO
       Text::BibTeX, Text::BibTeX::Entry, Text::BibTeX::File

AUTHOR
       Greg Ward &lt;gward@python.net&gt;

COPYRIGHT
       Copyright (c) 1997-2000 by Gregory P. Ward.  All rights reserved.  This
       file is part of the Text::BibTeX library.  This library is free software;
       you may redistribute it and/or modify it under the same terms as Perl
       itself.



perl v5.14.2                       2012-06-02       Text::BibTeX::Structure(3pm)

</pre></body></html>
