<html>
<head><meta charset=utf-8/>
<title>X11::Protocol - Perl module for the X Window System Protocol, version 11</title></head>
<body><pre>

Protocol(3pm)          User Contributed Perl Documentation         Protocol(3pm)



NAME
       X11::Protocol - Perl module for the X Window System Protocol, version 11

SYNOPSIS
         use X11::Protocol;
         $x = X11::Protocol-&gt;new();
         $win = $x-&gt;new_rsrc;
         $x-&gt;CreateWindow($win, $x-&gt;root, &apos;InputOutput&apos;,
                          $x-&gt;root_depth, &apos;CopyFromParent&apos;,
                          ($x_coord, $y_coord), $width,
                          $height, $border_w);
         ...

DESCRIPTION
       X11::Protocol is a client-side interface to the X11 Protocol (see X(1)
       for information about X11), allowing perl programs to display windows and
       graphics on X11 servers.

       A full description of the protocol is beyond the scope of this
       documentation; for complete information, see the X Window System
       Protocol, X Version 11, available as Postscript or *roff source from
       &quot;ftp://ftp.x.org&quot;, or Volume 0: X Protocol Reference Manual of O&apos;Reilly &amp;
       Associates&apos;s series of books about X (ISBN 1-56592-083-X,
       &quot;http://www.oreilly.com&quot;), which contains most of the same information.

DISCLAIMER
       ``The protocol contains many management mechanisms that are not intended
       for normal applications.  Not all mechanisms are needed to build a
       particular user interface.  It is important to keep in mind that the
       protocol is intended to provide mechanism, not policy.&apos;&apos; -- Robert W.
       Scheifler

BASIC METHODS
   new
         $x = X11::Protocol-&gt;new();
         $x = X11::Protocol-&gt;new($display_name);
         $x = X11::Protocol-&gt;new($connection);
         $x = X11::Protocol-&gt;new($display_name, [$auth_type, $auth_data]);
         $x = X11::Protocol-&gt;new($connection, [$auth_type, $auth_data]);

       Open a connection to a server. $display_name should be an X display name,
       of the form &apos;host:display_num.screen_num&apos;; if no arguments are supplied,
       the contents of the DISPLAY environment variable are used. Alternatively,
       a pre-opened connection, of one of the X11::Protocol::Connection classes
       (see X11::Protocol::Connection, X11::Protocol::Connection::FileHandle,
       X11::Protocol::Connection::Socket, X11::Protocol::Connection::UNIXFH,
       X11::Protocol::Connection::INETFH, X11::Protocol::Connection::UNIXSocket,
       X11::Protocol::Connection::INETSocket) can be given. The authorization
       data is obtained using X11::Auth or the second argument. If the display
       is specified by $display_name, rather than $connection, a choose_screen()
       is also performed, defaulting to screen 0 if the &apos;.screen_num&apos; of the
       display name is not present.  Returns the new protocol object.

   new_rsrc
         $x-&gt;new_rsrc;

       Returns a new resource identifier. A unique resource ID is required for
       every object that the server creates on behalf of the client: windows,
       fonts, cursors, etc. (IDs are chosen by the client instead of the server
       for efficiency -- the client doesn&apos;t have to wait for the server to
       acknowledge the creation before starting to use the object).
&#12;       Note that the total number of available resource IDs, while large, is
       finite.  Beginning from the establishment of a connection, resource IDs
       are allocated sequentially from a range whose size is server dependent
       (commonly 2**21, about 2 million).  If this limit is reached and the
       server does not support the XC_MISC extension, subsequent calls to
       new_rsrc will croak.  If the server does support this extension, the
       module will attempt to request a new range of free IDs from the server.
       This should allow the program to continue, but it is an imperfect
       solution, as over time the set of available IDs may fragment, requiring
       increasingly frequent round-trip range requests from the server.  For
       long-running programs, the best approach may be to keep track of free IDs
       as resources are destroyed.  In the current version, however, no special
       support is provided for this.

   handle_input
         $x-&gt;handle_input;

       Get one chunk of information from the server, and do something with it.
       If it&apos;s an error, handle it using the protocol object&apos;s handler
       (&apos;error_handler&apos; -- default is kill the program with an explanatory
       message). If it&apos;s an event, pass it to the chosen event handler, or put
       it in a queue if the handler is &apos;queue&apos;. If it&apos;s a reply to a request,
       save using the object&apos;s &apos;replies&apos; hash for further processing.

   atom_name
         $name = $x-&gt;atom_name($atom);

       Return the string corresponding to the atom $atom. This is similar to the
       GetAtomName request, but caches the result for efficiency.

   atom
         $atom = $x-&gt;atom($name);

       The inverse operation; Return the (numeric) atom corresponding to $name.
       This is similar to the InternAtom request, but caches the result.

   choose_screen
         $x-&gt;choose_screen($screen_num);

       Indicate that you prefer to use a particular screen of the display. Per-
       screen information, such as &apos;root&apos;, &apos;width_in_pixels&apos;, and &apos;white_pixel&apos;
       will be made available as

         $x-&gt;{&apos;root&apos;}

       instead of

         $x-&gt;{&apos;screens&apos;}[$screen_num]{&apos;root&apos;}

SYMBOLIC CONSTANTS
       Generally, symbolic constants used by the protocol, like &apos;CopyFromParent&apos;
       or &apos;PieSlice&apos; are passed to methods as strings, and converted into
       numbers by the module.  Their names are the same as those in the protocol
       specification, including capitalization, but with hyphens (&apos;-&apos;) changed
       to underscores (&apos;_&apos;) to look more perl-ish. If you want to do the
       conversion yourself for some reason, the following methods are available:

   num
         $num = $x-&gt;num($type, $str)

       Given a string representing a constant and a string specifying what type
       of constant it is, return the corresponding number. $type should be a
       name like &apos;VisualClass&apos; or &apos;GCLineStyle&apos;. If the name is not recognized,
       it is returned intact.

   interp
         $name = $x-&gt;interp($type, $num)
&#12;       The inverse operation; given a number and string specifying its type,
       return a string representing the constant.

       You can disable interp() and the module&apos;s internal interpretation of
       numbers by setting $x-&gt;{&apos;do_interp&apos;} to zero. Of course, this isn&apos;t very
       useful, unless you have you own definitions for all the constants.

       Here is a list of available constant types:

         AccessMode, AllowEventsMode, AutoRepeatMode, BackingStore,
         BitGravity, Bool, ChangePropertyMode, CirculateDirection,
         CirculatePlace, Class, ClipRectangleOrdering, CloseDownMode,
         ColormapNotifyState, CoordinateMode, CrossingNotifyDetail,
         CrossingNotifyMode, DeviceEvent, DrawDirection, Error, EventMask,
         Events, FocusDetail, FocusMode, GCArcMode, GCCapStyle, GCFillRule,
         GCFillStyle, GCFunction, GCJoinStyle, GCLineStyle, GCSubwindowMode,
         GrabStatus, HostChangeMode, HostFamily, ImageFormat,
         InputFocusRevertTo, KeyMask, LedMode, MapState, MappingChangeStatus,
         MappingNotifyRequest, PointerEvent, PolyShape, PropertyNotifyState,
         Request, ScreenSaver, ScreenSaverAction, Significance, SizeClass,
         StackMode, SyncMode, VisibilityState, VisualClass, WinGravity

SERVER INFORMATION
       At connection time, the server sends a large amount of information about
       itself to the client. This information is stored in the protocol object
       for future reference. It can be read directly, like

         $x-&gt;{&apos;release_number&apos;}

       or, for object oriented True Believers, using a method:

         $x-&gt;release_number

       The method method also has a one argument form for setting variables, but
       it isn&apos;t really useful for some of the more complex structures.

       Here is an example of what the object&apos;s information might look like:

         &apos;connection&apos; =&gt; X11::Connection::UNIXSocket(0x814526fd),
         &apos;byte_order&apos; =&gt; &apos;l&apos;,
         &apos;protocol_major_version&apos; =&gt; 11,
         &apos;protocol_minor_version&apos; =&gt; 0,
         &apos;authorization_protocol_name&apos; =&gt; &apos;MIT-MAGIC-COOKIE-1&apos;,
         &apos;release_number&apos; =&gt; 3110,
         &apos;resource_id_base&apos; =&gt; 0x1c000002,
         &apos;motion_buffer_size&apos; =&gt; 0,
         &apos;maximum_request_length&apos; =&gt; 65535, # units of 4 bytes
         &apos;image_byte_order&apos; =&gt; &apos;LeastSiginificant&apos;,
         &apos;bitmap_bit_order&apos; =&gt; &apos;LeastSiginificant&apos;,
         &apos;bitmap_scanline_unit&apos; =&gt; 32,
         &apos;bitmap_scanline_pad&apos; =&gt; 32,
         &apos;min_keycode&apos; =&gt; 8,
         &apos;max_keycode&apos; =&gt; 134,
         &apos;vendor&apos; =&gt; &apos;The XFree86 Project, Inc&apos;,
         &apos;pixmap_formats&apos; =&gt; {1 =&gt; {&apos;bits_per_pixel&apos; =&gt; 1,
                                    &apos;scanline_pad&apos; =&gt; 32},
                              8 =&gt; {&apos;bits_per_pixel&apos; =&gt; 8,
                                    &apos;scanline_pad&apos; =&gt; 32}},
         &apos;screens&apos; =&gt; [{&apos;root&apos; =&gt; 43, &apos;width_in_pixels&apos; =&gt; 800,
                        &apos;height_in_pixels&apos; =&gt; 600,
                        &apos;width_in_millimeters&apos; =&gt; 271,
                        &apos;height_in_millimeters&apos; =&gt; 203,
                        &apos;root_depth&apos; =&gt; 8,
                        &apos;root_visual&apos; =&gt; 34,
                        &apos;default_colormap&apos; =&gt; 33,
                        &apos;white_pixel&apos; =&gt; 0, &apos;black_pixel&apos; =&gt; 1,
                        &apos;min_installed_maps&apos; =&gt; 1,
                        &apos;max_installed_maps&apos; =&gt; 1,
                        &apos;backing_stores&apos; =&gt; &apos;Always&apos;,
                        &apos;save_unders&apos; =&gt; 1,
                        &apos;current_input_masks&apos; =&gt; 0x58003d,
                        &apos;allowed_depths&apos; =&gt;
                           [{&apos;depth&apos; =&gt; 1, &apos;visuals&apos; =&gt; []},
                            {&apos;depth&apos; =&gt; 8, &apos;visuals&apos; =&gt; [
                               {&apos;visual_id&apos; =&gt; 34, &apos;blue_mask&apos; =&gt; 0,
                                &apos;green_mask&apos; =&gt; 0, &apos;red_mask&apos; =&gt; 0,
                                &apos;class&apos; =&gt; &apos;PseudoColor&apos;,
                                &apos;bits_per_rgb_value&apos; =&gt; 6,
                                &apos;colormap_entries&apos; =&gt; 256},
                               {&apos;visual_id&apos; =&gt; 35, &apos;blue_mask&apos; =&gt; 0xc0,
                                &apos;green_mask&apos; =&gt; 0x38, &apos;red_mask&apos; =&gt; 0x7,
                                &apos;class&apos; =&gt; &apos;DirectColor&apos;,
                                &apos;bits_per_rgb_value&apos; =&gt; 6,
                                &apos;colormap_entries&apos; =&gt; 8}, ...]}]],
         &apos;visuals&apos; =&gt; {34 =&gt; {&apos;depth&apos; =&gt; 8, &apos;class&apos; =&gt; &apos;PseudoColor&apos;,
                              &apos;red_mask&apos; =&gt; 0, &apos;green_mask&apos; =&gt; 0,
                              &apos;blue_mask&apos;=&gt; 0, &apos;bits_per_rgb_value&apos; =&gt; 6,
                              &apos;colormap_entries&apos; =&gt; 256},
                       35 =&gt; {&apos;depth&apos; =&gt; 8, &apos;class&apos; =&gt; &apos;DirectColor&apos;,
                              &apos;red_mask&apos; =&gt; 0x7, &apos;green_mask&apos; =&gt; 0x38,
                              &apos;blue_mask&apos;=&gt; 0xc0, &apos;bits_per_rgb_value&apos; =&gt; 6,
                              &apos;colormap_entries&apos; =&gt; 8}, ...}
         &apos;error_handler&apos; =&gt; &amp;\X11::Protocol::default_error_handler,
         &apos;event_handler&apos; =&gt; sub {},
         &apos;do_interp&apos; =&gt; 1

REQUESTS
   request
         $x-&gt;request(&apos;CreateWindow&apos;, ...);
         $x-&gt;req(&apos;CreateWindow&apos;, ...);
         $x-&gt;CreateWindow(...);

       Send a protocol request to the server, and get the reply, if any. For
       names of and information about individual requests, see below and/or the
       protocol reference manual.

   robust_req
         $x-&gt;robust_req(&apos;CreateWindow&apos;, ...);

       Like request(), but if the server returns an error, return the error
       information rather than calling the error handler (which by default just
       croaks). If the request succeeds, returns an array reference containing
       whatever request() would have. Otherwise, returns the error type, the
       major and minor opcodes of the failed request, and the extra error
       information, if any. Note that even if the request normally wouldn&apos;t have
       a reply, this method still has to wait for a round-trip time to see
       whether an error occurred. If you&apos;re concerned about performance, you
       should design your error handling to be asynchronous.

   add_reply
         $x-&gt;add_reply($sequence_num, \$var);

       Add a stub for an expected reply to the object&apos;s &apos;replies&apos; hash. When a
       reply numbered $sequence_num comes, it will be stored in $var.

   delete_reply
         $x-&gt;delete_reply($sequence_num);

       Delete the entry in &apos;replies&apos; for the specified reply. (This should be
       done after the reply is received).

   send
         $x-&gt;send(&apos;CreateWindow&apos;, ...);

       Send a request, but do not wait for a reply. You must handle the reply,
       if any, yourself, using add_reply(), handle_input(), delete_reply(), and
       unpack_reply(), generally in that order.

   unpack_reply
         $x-&gt;unpack_reply(&apos;GetWindowAttributes&apos;, $data);

       Interpret the raw reply data $data, according to the reply format for the
       named request. Returns data in the same format as &quot;request($request_name,
       ...)&quot;.

       This section includes only a short calling summary for each request; for
       full descriptions, see the protocol standard. Argument order is usually
       the same as listed in the spec, but you generally don&apos;t have to pass
       lengths of strings or arrays, since perl keeps track. Symbolic constants
       are generally passed as strings. Most replies are returned as lists, but
       when there are many values, a hash is used. Lists usually come last; when
       there is more than one, each is passed by reference. In lists of multi-
       part structures, each element is a list ref. Parenthesis are inserted in
       arg lists for clarity, but are optional. Requests are listed in order by
       major opcode, so related requests are usually close together. Replies
       follow the &apos;=&gt;&apos;.

         $x-&gt;CreateWindow($wid, $parent, $class, $depth, $visual, ($x, $y),
                          $width, $height, $border_width,
                          &apos;attribute&apos; =&gt; $value, ...)

         $x-&gt;ChangeWindowAttributes($window, &apos;attribute&apos; =&gt; $value, ...)

         $x-&gt;GetWindowAttributes($window)
         =&gt;
         (&apos;backing_store&apos; =&gt; $backing_store, ...)

       This is an example of a return value that is meant to be assigned to a
       hash.

         $x-&gt;DestroyWindow($win)

         $x-&gt;DestroySubwindows($win)

         $x-&gt;ChangeSaveSet($window, $mode)

         $x-&gt;ReparentWindow($win, $parent, ($x, $y))

         $x-&gt;MapWindow($win)

         $x-&gt;MapSubwindows($win)

         $x-&gt;UnmapWindow($win)

         $x-&gt;UnmapSubwindows($win)

         $x-&gt;ConfigureWindow($win, &apos;attribute&apos; =&gt; $value, ...)

         $x-&gt;CirculateWindow($win, $direction)

       Note that this request actually circulates the subwindows of $win, not
       the window itself.

         $x-&gt;GetGeometry($drawable)
         =&gt;
         (&apos;root&apos; =&gt; $root, ...)

         $x-&gt;QueryTree($win)
         =&gt;
         ($root, $parent, @kids)

         $x-&gt;InternAtom($name, $only_if_exists)
         =&gt;
         $atom

         $x-&gt;GetAtomName($atom)
         =&gt;
         $name

         $x-&gt;ChangeProperty($window, $property, $type, $format, $mode, $data)

         $x-&gt;DeleteProperty($win, $atom)

         $x-&gt;GetProperty($window, $property, $type, $offset, $length, $delete)
         =&gt;
         ($value, $type, $format, $bytes_after)

       Notice that the value comes first, so you can easily ignore the rest.

         $x-&gt;ListProperties($window)
         =&gt;
         (@atoms)

         $x-&gt;SetSelectionOwner($selection, $owner, $time)

         $x-&gt;GetSelectionOwner($selection)
         =&gt;
         $owner

         $x-&gt;ConvertSelection($selection, $target, $property, $requestor, $time)

         $x-&gt;SendEvent($destination, $propagate, $event_mask, $event)

       The $event argument should be the result of a pack_event() (see &quot;EVENTS&quot;)

         $x-&gt;GrabPointer($grab_window, $owner_events, $event_mask,
                         $pointer_mode, $keyboard_mode, $confine_to,
                         $cursor, $time)
         =&gt;
         $status

         $x-&gt;UngrabPointer($time)

         $x-&gt;GrabButton($modifiers, $button, $grab_window, $owner_events,
                        $event_mask, $pointer_mode, $keyboard_mode,
                        $confine_to, $cursor)

         $x-&gt;UngrabButton($modifiers, $button, $grab_window)

         $x-&gt;ChangeActivePointerGrab($event_mask, $cursor, $time)

         $x-&gt;GrabKeyboard($grab_window, $owner_events, $pointer_mode,
                          $keyboard_mode, $time)
         =&gt;
         $status

         $x-&gt;UngrabKeyboard($time)

         $x-&gt;GrabKey($key, $modifiers, $grab_window, $owner_events,
                     $pointer_mode, $keyboard_mode)

         $x-&gt;UngrabKey($key, $modifiers, $grab_window)

         $x-&gt;AllowEvents($mode, $time)

         $x-&gt;GrabServer

         $x-&gt;UngrabServer

         $x-&gt;QueryPointer($window)
         =&gt;
         (&apos;root&apos; =&gt; $root, ...)

         $x-&gt;GetMotionEvents($start, $stop, $window)
         =&gt;
         ([$time, ($x, $y)], [$time, ($x, $y)], ...)

         $x-&gt;TranslateCoordinates($src_window, $dst_window, $src_x, $src_y)
         =&gt;
         ($same_screen, $child, $dst_x, $dst_y)

         $x-&gt;WarpPointer($src_window, $dst_window, $src_x, $src_y, $src_width,
                         $src_height, $dst_x, $dst_y)

         $x-&gt;SetInputFocus($focus, $revert_to, $time)

         $x-&gt;GetInputFocus
         =&gt;
         ($focus, $revert_to)

         $x-&gt;QueryKeymap
         =&gt;
         $keys

       $keys is a bit vector, so you should use vec() to read it.

         $x-&gt;OpenFont($fid, $name)

         $x-&gt;CloseFont($font)

         $x-&gt;QueryFont($font)
         =&gt;
         (&apos;min_char_or_byte2&apos; =&gt; $min_char_or_byte2,
          ...,
          &apos;min_bounds&apos; =&gt;
          [$left_side_bearing, $right_side_bearing, $character_width, $ascent,
           $descent, $attributes],
          ...,
          &apos;char_infos&apos; =&gt;
          [[$left_side_bearing, $right_side_bearing, $character_width, $ascent,
            $descent, $attributes],
           ...],
          &apos;properties&apos; =&gt; {$prop =&gt; $value, ...}
          )

         $x-&gt;QueryTextExtents($font, $string)
         =&gt;
         (&apos;draw_direction&apos; =&gt; $draw_direction, ...)

         $x-&gt;ListFonts($pattern, $max_names)
         =&gt;
         @names

         $x-&gt;ListFontsWithInfo($pattern, $max_names)
         =&gt;
         ({&apos;name&apos; =&gt; $name, ...}, {&apos;name&apos; =&gt; $name, ...}, ...)

       The information in each hash is the same as the the information returned
       by QueryFont, but without per-character size information. This request is
       special in that it is the only request that can have more than one reply.
       This means you should probably only use request() with it, not send(), as
       the reply counting is complicated. Luckily, you never need this request
       anyway, as its function is completely duplicated by other requests.

         $x-&gt;SetFontPath(@strings)

         $x-&gt;GetFontPath
         =&gt;
         @strings
&#12;         $x-&gt;CreatePixmap($pixmap, $drawable, $depth, $width, $height)

         $x-&gt;FreePixmap($pixmap)

         $x-&gt;CreateGC($cid, $drawable, &apos;attribute&apos; =&gt; $value, ...)

         $x-&gt;ChangeGC($gc, &apos;attribute&apos; =&gt; $value, ...)

         $x-&gt;CopyGC($src, $dest, &apos;attribute&apos;, &apos;attribute&apos;, ...)

         $x-&gt;SetDashes($gc, $dash_offset, (@dashes))

         $x-&gt;SetClipRectangles($gc, ($clip_x_origin, $clip_y_origin),
                               $ordering, [$x, $y, $width, $height], ...)

         $x-&gt;ClearArea($window, ($x, $y), $width, $height, $exposures)

         $x-&gt;CopyArea($src_drawable, $dst_drawable, $gc, ($src_x, $src_y),
                      $width, $height, ($dst_x, $dst_y))

         $x-&gt;CopyPlane($src_drawable, $dst_drawable, $gc, ($src_x, $src_y),
                       $width, $height, ($dst_x, $dst_y), $bit_plane)

         $x-&gt;PolyPoint($drawable, $gc, $coordinate_mode,
                       ($x, $y), ($x, $y), ...)

         $x-&gt;PolyLine($drawable, $gc, $coordinate_mode,
                      ($x, $y), ($x, $y), ...)

         $x-&gt;PolySegment($drawable, $gc, ($x, $y) =&gt; ($x, $y),
                         ($x, $y) =&gt; ($x, $y), ...)

         $x-&gt;PolyRectangle($drawable, $gc,
                           [($x, $y), $width, $height], ...)

         $x-&gt;PolyArc($drawable, $gc,
                     [($x, $y), $width, $height, $angle1, $angle2], ...)

         $x-&gt;FillPoly($drawable, $gc, $shape, $coordinate_mode,
                      ($x, $y), ...)

         $x-&gt;PolyFillRectangle($drawable, $gc,
                               [($x, $y), $width, $height], ...)

         $x-&gt;PolyFillArc($drawable, $gc,
                         [($x, $y), $width, $height, $angle1, $angle2], ...)

         $x-&gt;PutImage($drawable, $gc, $depth, $width, $height,
                      ($dst_x, $dst_y), $left_pad, $format, $data)

       Currently, the module has no code to handle the various bitmap formats
       that the server might specify. Therefore, this request will not work
       portably without a lot of work.

         $x-&gt;GetImage($drawable, ($x, $y), $width, $height, $plane_mask,
                      $format)

         $x-&gt;PolyText8($drawable, $gc, ($x, $y),
                       ($font OR [$delta, $string]), ...)

         $x-&gt;PolyText16($drawable, $gc, ($x, $y),
                        ($font OR [$delta, $string]), ...)

         $x-&gt;ImageText8($drawable, $gc, ($x, $y), $string)

         $x-&gt;ImageText16($drawable, $gc, ($x, $y), $string)

         $x-&gt;CreateColormap($mid, $visual, $window, $alloc)

         $x-&gt;FreeColormap($cmap)

         $x-&gt;CopyColormapAndFree($mid, $src_cmap)

         $x-&gt;InstallColormap($cmap)

         $x-&gt;UninstallColormap($cmap)

         $x-&gt;ListInstalledColormaps($window)
         =&gt;
         @cmaps

         $x-&gt;AllocColor($cmap, ($red, $green, $blue))
         =&gt;
         ($pixel, ($red, $green, $blue))

         $x-&gt;AllocNamedColor($cmap, $name)
         =&gt;
         ($pixel, ($exact_red, $exact_green, $exact_blue),
          ($visual_red, $visual_green, $visual_blue))

         $x-&gt;AllocColorCells($cmap, $colors, $planes, $contiguous)
         =&gt;
         ([@pixels], [@masks])

         $x-&gt;AllocColorPlanes($cmap, $colors, ($reds, $greens, $blues),
                              $contiguous)
         =&gt;
         (($red_mask, $green_mask, $blue_mask), @pixels)

         $x-&gt;FreeColors($cmap, $plane_mask, @pixels)

         $x-&gt;StoreColors($cmap, [$pixel, $red, $green, $blue, $do_mask], ...)

       The 1, 2, and 4 bits in $do_mask are do-red, do-green, and do-blue.
       $do_mask can be omitted, defaulting to 7, the usual case -- change the
       whole color.

         $x-&gt;StoreNamedColor($cmap, $pixel, $name, $do_mask)

       $do_mask has the same interpretation as above, but is mandatory.

         $x-&gt;QueryColors($cmap, @pixels)
         =&gt;
         ([$red, $green, $blue], ...)

         $x-&gt;LookupColor($cmap, $name)
         =&gt;
         (($exact_red, $exact_green, $exact_blue),
          ($visual_red, $visual_green, $visual_blue))

         $x-&gt;CreateCursor($cid, $source, $mask,
                          ($fore_red, $fore_green, $fore_blue),
                          ($back_red, $back_green, $back_blue),
                          ($x, $y))

         $x-&gt;CreateGlyphCursor($cid, $source_font, $mask_font,
                               $source_char, $mask_char,
                               ($fore_red, $fore_green, $fore_blue),
                               ($back_red, $back_green, $back_blue))

         $x-&gt;FreeCursor($cursor)

         $x-&gt;RecolorCursor($cursor, ($fore_red, $fore_green, $fore_blue),
                           ($back_red, $back_green, $back_blue))

         $x-&gt;QueryBestSize($class, $drawable, $width, $height)
         =&gt;
         ($width, $height)

         $x-&gt;QueryExtension($name)
         =&gt;
         ($major_opcode, $first_event, $first_error)

       If the extension is not present, an empty list is returned.

         $x-&gt;ListExtensions
         =&gt;
         (@names)

         $x-&gt;ChangeKeyboardMapping($first_keycode, $keysysms_per_keycode,
                                   @keysyms)

         $x-&gt;GetKeyboardMapping($first_keycode, $count)
         =&gt;
         ($keysysms_per_keycode, [$keysym, ...], [$keysym, ...], ...)

         $x-&gt;ChangeKeyboardControl(&apos;attribute&apos; =&gt; $value, ...)

         $x-&gt;GetKeyboardControl
         =&gt;
         (&apos;global_auto_repeat&apos; =&gt; $global_auto_repeat, ...)

         $x-&gt;Bell($percent)

         $x-&gt;ChangePointerControl($do_acceleration, $do_threshold,
                                  $acceleration_numerator,
                                  $acceleration_denominator, $threshold)

         $x-&gt;GetPointerControl
         =&gt;
         ($acceleration_numerator, $acceleration_denominator, $threshold)

         $x-&gt;SetScreenSaver($timeout, $interval, $prefer_blanking,
                            $allow_exposures)

         $x-&gt;GetScreenSaver
         =&gt;
         ($timeout, $interval, $prefer_blanking, $allow_exposures)

         $x-&gt;ChangeHosts($mode, $host_family, $host_address)

         $x-&gt;ListHosts
         =&gt;
         ($mode, [$family, $host], ...)

         $x-&gt;SetAccessControl($mode)

         $x-&gt;SetCloseDownMode($mode)

         $x-&gt;KillClient($resource)

         $x-&gt;RotateProperties($win, $delta, @props)

         $x-&gt;ForceScreenSaver($mode)

         $x-&gt;SetPointerMapping(@map)
         =&gt;
         $status

         $x-&gt;GetPointerMapping
         =&gt;
         @map

         $x-&gt;SetModifierMapping(@keycodes)
         =&gt;
         $status

         $x-&gt;GetModiferMapping
         =&gt;
         @keycodes

         $x-&gt;NoOperation($length)

       $length specifies the length of the entire useless request, in four byte
       units, and is optional.

EVENTS
       To receive events, first set the &apos;event_mask&apos; attribute on a window to
       indicate what types of events you desire (see &quot;pack_event_mask&quot;). Then,
       set the protocol object&apos;s &apos;event_handler&apos; to a subroutine reference that
       will handle the events. Alternatively, set &apos;event_handler&apos; to &apos;queue&apos;,
       and retrieve events using dequeue_event() or next_event(). In both cases,
       events are returned as a hash. For instance, a typical MotionNotify event
       might look like this:

         %event = (&apos;name&apos; =&gt; &apos;MotionNotify&apos;, &apos;sequence_number&apos; =&gt; 12,
                   &apos;state&apos; =&gt; 0, &apos;event&apos; =&gt; 58720256, &apos;root&apos; =&gt; 43,
                   &apos;child&apos; =&gt; None, &apos;same_screen&apos; =&gt; 1, &apos;time&apos; =&gt; 966080746,
                   &apos;detail&apos; =&gt; &apos;Normal&apos;, &apos;event_x&apos; =&gt; 10, &apos;event_y&apos; =&gt; 3,
                   &apos;code&apos; =&gt; 6, &apos;root_x&apos; =&gt; 319, &apos;root_y&apos; =&gt; 235)

   pack_event_mask
         $mask = $x-&gt;pack_event_mask(&apos;ButtonPress&apos;, &apos;KeyPress&apos;, &apos;Exposure&apos;);

       Make an event mask (suitable as the &apos;event_mask&apos; of a window) from a list
       of strings specifying event types.

   unpack_event_mask
         @event_types = $x-&gt;unpack_event_mask($mask);

       The inverse operation; convert an event mask obtained from the server
       into a list of names of event categories.

   dequeue_event
         %event = $x-&gt;dequeue_event;

       If there is an event waiting in the queue, return it.

   next_event
         %event = $x-&gt;next_event;

       Like Xlib&apos;s XNextEvent(), this function is equivalent to

         $x-&gt;handle_input until %event = dequeue_event;

   pack_event
         $data = $x-&gt;pack_event(%event);

       Given an event in hash form, pack it into a string. This is only useful
       as an argument to SendEvent().

   unpack_event
         %event = $x-&gt;unpack_event($data);

       The inverse operation; given the raw data for an event (32 bytes), unpack
       it into hash form. Normally, this is done automatically.

EXTENSIONS
       Protocol extensions add new requests, event types, and error types to the
       protocol. Support for them is compartmentalized in modules in the
       X11::Protocol::Ext:: hierarchy. For an example, see
       X11::Protocol::Ext::SHAPE. You can tell if the module has loaded an
       extension by looking at

         $x-&gt;{&apos;ext&apos;}{$extension_name}

       If the extension has been initialized, this value will be an array
       reference, [$major_request_number, $first_event_number,
       $first_error_number, $obj], where $obj is an object containing
       information private to the extension.

   init_extension
         $x-&gt;init_extension($name);

       Initialize an extension: query the server to find the extension&apos;s request
       number, then load the corresponding module. Returns 0 if the server does
       not support the named extension, or if no module to interface with it
       exists.

   init_extensions
         $x-&gt;init_extensions;

       Initialize protocol extensions. This does a ListExtensions request, then
       calls init_extension() for each extension that the server supports.

WRITING EXTENSIONS
       Internally, the X11::Protocol module is table driven. All an extension
       has to do is to add new add entries to the protocol object&apos;s tables. An
       extension module should &quot;use X11::Protocol&quot;, and should define an new()
       method

         X11::Protocol::Ext::NAME
           -&gt;new($x, $request_num, $event_num, $error_num)

       where $x is the protocol object and $request_num, $event_num and
       $error_num are the values returned by QueryExtension().

       The new() method should add new types of constant like

         $x-&gt;{&apos;ext_const&apos;}{&apos;ConstantType&apos;} = [&apos;Constant&apos;, &apos;Constant&apos;, ...]

       and set up the corresponding name to number translation hashes like

         $x-&gt;{&apos;ext_const_num&apos;}{&apos;ConstantType&apos;} =
           {make_num_hash($x-&gt;{&apos;ext_const&apos;}{&apos;ConstantType&apos;})}

       Event names go in

         $x-&gt;{&apos;ext_const&apos;}{&apos;Events&apos;}[$event_number]

       while specifications for event contents go in

         $x-&gt;{&apos;ext_event&apos;}[$event_number]

       each element of which is either &quot;[\&amp;unpack_sub, \&amp;pack_sub]&quot; or
       &quot;[$pack_format, $field, $field, ...]&quot;, where each $field is &apos;name&apos;,
       &quot;[&apos;name&apos;, &apos;const_type&apos;]&quot;, or &quot;[&apos;name&apos;, [&apos;special_name_for_zero&apos;,
       &apos;special_name_for_one&apos;]]&quot;, where &apos;special_name_for_one&apos; is optional.

       Finally,

         $x-&gt;{&apos;ext_request&apos;}{$major_request_number}

       should be an array of arrays, with each array either &quot;[$name, \&amp;packit]&quot;
       or &quot;[$name, \&amp;packit, \&amp;unpackit]&quot;, and

         $x-&gt;{&apos;ext_request_num&apos;}{$request_name}

       should be initialized with &quot;[$minor_num, $major_num]&quot; for each request
       the extension defines. For examples of code that does all of this, look
       at X11::Protocol::Ext::SHAPE.

       X11::Protocol exports several functions that might be useful in
       extensions (note that these are not methods).

   padding
         $p = padding $x;

       Given an integer, compute the number need to round it up to a multiple of
       4.  For instance, padding(5) is 3.

   pad
         $p = pad $str;

       Given a string, return the number of extra bytes needed to make a
       multiple of 4. Equivalent to &quot;padding(length($str))&quot;.

   padded
         $data = pack(padded($str), $str);

       Return a format string, suitable for pack(), for a string padded to a
       multiple of 4 bytes. For instance, &quot;pack(padded(&apos;Hello&apos;), &apos;Hello&apos;)&quot; gives
       &quot;Hello\0\0\0&quot;.

   hexi
         $str = hexi $n;

       Format a number in hexidecimal, and add a &quot;0x&quot; to the front.

   make_num_hash
         %hash = make_num_hash([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]);

       Given a reference to a list of strings, return a hash mapping the strings
       onto numbers representing their position in the list, as used by
       &quot;$x-&gt;{&apos;ext_const_num&apos;}&quot;.

BUGS
       This module is too big (~2500 lines), too slow (10 sec to load on a slow
       machine), too inefficient (request args are copied several times), and
       takes up too much memory (3000K for basicwin).

       If you have more than 65535 replies outstanding at once, sequence numbers
       can collide.

       The protocol is too complex.

AUTHOR
       Stephen McCamant &lt;SMCCAM@cpan.org&gt;.

SEE ALSO
       perl(1), X(1), X11::Keysyms, X11::Protocol::Ext::SHAPE,
       X11::Protocol::Ext::BIG_REQUESTS, X11::Protocol::Ext::XC_MISC,
       X11::Protocol::Ext::DPMS, X11::Protocol::Ext::XFree86_Misc, X11::Auth, X
       Window System Protocol (X Version 11), Inter-Client Communications
       Conventions Manual, X Logical Font Description Conventions.



perl v5.14.2                       2006-10-08                      Protocol(3pm)

</pre></body></html>
