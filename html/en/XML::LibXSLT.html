<html>
<head><meta charset=utf-8/>
<title>XML::LibXSLT - Interface to the GNOME libxslt library</title></head>
<body><pre>

LibXSLT(3pm)           User Contributed Perl Documentation          LibXSLT(3pm)



NAME
       XML::LibXSLT - Interface to the GNOME libxslt library

SYNOPSIS
         use XML::LibXSLT;
         use XML::LibXML;

         my $xslt = XML::LibXSLT-&gt;new();

         my $source = XML::LibXML-&gt;load_xml(location =&gt; &apos;foo.xml&apos;);
         my $style_doc = XML::LibXML-&gt;load_xml(location=&gt;&apos;bar.xsl&apos;, no_cdata=&gt;1);

         my $stylesheet = $xslt-&gt;parse_stylesheet($style_doc);

         my $results = $stylesheet-&gt;transform($source);

         print $stylesheet-&gt;output_as_bytes($results);

DESCRIPTION
       This module is an interface to the GNOME project&apos;s libxslt. This is an
       extremely good XSLT engine, highly compliant and also very fast. I have
       tests showing this to be more than twice as fast as Sablotron.

OPTIONS
       XML::LibXSLT has some global options. Note that these are probably not
       thread or even fork safe - so only set them once per process. Each one of
       these options can be called either as class methods, or as instance
       methods. However either way you call them, it still sets global options.

       Each of the option methods returns its previous value, and can be called
       without a parameter to retrieve the current value.

       max_depth
             XML::LibXSLT-&gt;max_depth(1000);

           This option sets the maximum recursion depth for a stylesheet. See
           the very end of section 5.4 of the XSLT specification for more
           details on recursion and detecting it. If your stylesheet or XML file
           requires seriously deep recursion, this is the way to set it. Default
           value is 250.

       debug_callback
             XML::LibXSLT-&gt;debug_callback($subref);

           Sets a callback to be used for debug messages. If you don&apos;t set this,
           debug messages will be ignored.

       register_function
             XML::LibXSLT-&gt;register_function($uri, $name, $subref);
             $stylesheet-&gt;register_function($uri, $name, $subref);

           Registers an XSLT extension function mapped to the given URI. For
           example:

             XML::LibXSLT-&gt;register_function(&quot;urn:foo&quot;, &quot;bar&quot;,
               sub { scalar localtime });

           Will register a &quot;bar&quot; function in the &quot;urn:foo&quot; namespace (which you
           have to define in your XSLT using &quot;xmlns:...&quot;) that will return the
           current date and time as a string:

             &lt;xsl:stylesheet version=&quot;1.0&quot;
               xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;
               xmlns:foo=&quot;urn:foo&quot;&gt;
             &lt;xsl:template match=&quot;/&quot;&gt;
               The time is: &lt;xsl:value-of select=&quot;foo:bar()&quot;/&gt;
             &lt;/xsl:template&gt;
             &lt;/xsl:stylesheet&gt;
&#12;           Parameters can be in whatever format you like. If you pass in a
           nodelist it will be a XML::LibXML::NodeList object in your perl code,
           but ordinary values (strings, numbers and booleans) will be ordinary
           perl scalars. If you wish them to be &quot;XML::LibXML::Literal&quot;,
           &quot;XML::LibXML::Number&quot; and &quot;XML::LibXML::Number&quot; values respectively
           then set the variable $XML::LibXSLT::USE_LIBXML_DATA_TYPES to a true
           value. Return values can be a nodelist or a plain value - the code
           will just do the right thing.  But only a single return value is
           supported (a list is not converted to a nodelist).

       register_element
                   $stylesheet-&gt;register_element($uri, $name, $subref)

           Registers an XSLT extension element $name mapped to the given URI.
           For example:

             $stylesheet-&gt;register_element(&quot;urn:foo&quot;, &quot;hello&quot;, sub {
                     my $name = $_[2]-&gt;getAttribute( &quot;name&quot; );
                     return XML::LibXML::Text-&gt;new( &quot;Hello, $name!&quot; );
             });

           Will register a &quot;hello&quot; element in the &quot;urn:foo&quot; namespace that
           returns a &quot;Hello, X!&quot; text node. You must define this namespace in
           your XSLT and include its prefix in the &quot;extension-element-prefixes&quot;
           list:

             &lt;xsl:stylesheet version=&quot;1.0&quot;
               xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;
               xmlns:foo=&quot;urn:foo&quot;
                   extension-element-prefixes=&quot;foo&quot;&gt;
             &lt;xsl:template match=&quot;/&quot;&gt;
               &lt;foo:hello name=&quot;bob&quot;/&gt;
             &lt;/xsl:template&gt;
             &lt;/xsl:stylesheet&gt;

           The callback is passed the input document node as $_[1] and the
           stylesheet node as $_[2]. $_[0] is reserved for future use.

API
       The following methods are available on the new XML::LibXSLT object:

       parse_stylesheet($stylesheet_doc)
           $stylesheet_doc here is an XML::LibXML::Document object (see
           XML::LibXML) representing an XSLT file. This method will return a
           XML::LibXSLT::Stylesheet object, or undef on failure. If the XSLT is
           invalid, an exception will be thrown, so wrap the call to
           parse_stylesheet in an eval{} block to trap this.

           IMPORTANT: $stylesheet_doc should not contain CDATA sections,
           otherwise libxslt may misbehave. The best way to assure this is to
           load the stylesheet with no_cdata flag, e.g.

             my $stylesheet_doc = XML::LibXML-&gt;load_xml(location=&gt;&quot;some.xsl&quot;, no_cdata=&gt;1);

       parse_stylesheet_file($filename)
           Exactly the same as the above, but parses the given filename
           directly.

Input Callbacks
       To define XML::LibXSLT or XML::LibXSLT::Stylesheet specific input
       callbacks, reuse the XML::LibXML input callback API as described in
       XML::LibXML::InputCallback(3).

Security Callbacks
       To create security preferences for the transformation see
       XML::LibXSLT::Security. Once the security preferences have been defined
       you can apply them to an XML::LibXSLT or XML::LibXSLT::Stylesheet
       instance using the &quot;security_callbacks()&quot; method.

XML::LibXSLT::Stylesheet
       The main API is on the stylesheet, though it is fairly minimal.

       One of the main advantages of XML::LibXSLT is that you have a generic
       stylesheet object which you call the transform() method passing in a
       document to transform. This allows you to have multiple transformations
       happen with one stylesheet without requiring a reparse.

       transform(doc, %params)
             my $results = $stylesheet-&gt;transform($doc, foo =&gt; &quot;&apos;bar&apos;&quot;);
             print $stylesheet-&gt;output_as_bytes($results);

           Transforms the passed in XML::LibXML::Document object, and returns a
           new XML::LibXML::Document. Extra hash entries are used as parameters.
           Be sure to keep in mind the caveat with regard to quotes explained in
           the section on &quot;Parameters&quot; below.

       transform_file(filename, %params)
             my $results = $stylesheet-&gt;transform_file($filename, bar =&gt; &quot;&apos;baz&apos;&quot;);

           Note the string parameter caveat, detailed in the section on
           &quot;Parameters&quot; below.

       output_as_bytes(result)
           Returns a scalar that is the XSLT rendering of the
           XML::LibXML::Document object using the desired output format
           (specified in the xsl:output tag in the stylesheet). Note that you
           can also call $result-&gt;toString, but that will *always* output the
           document in XML format which may not be what you asked for in the
           xsl:output tag. The scalar is a byte string encoded in the output
           encoding specified in the stylesheet.

       output_as_chars(result)
           Like &quot;output_as_bytes(result)&quot;, but always return the output as
           (UTF-8 encoded) string of characters.

       output_string(result)
           DEPRECATED: This method is something between
           &quot;output_as_bytes(result)&quot; and &quot;output_as_bytes(result)&quot;: The scalar
           returned by this function appears to Perl as characters (UTF8 flag is
           on) if the output encoding specified in the XSLT stylesheet was UTF-8
           and as bytes if no output encoding was specified or if the output
           encoding was other than UTF-8. Since the behavior of this function
           depends on the particular stylesheet, it is deprecated in favor of
           &quot;output_as_bytes(result)&quot; and &quot;output_as_chars(result)&quot;.

       output_fh(result, fh)
           Outputs the result to the filehandle given in $fh.

       output_file(result, filename)
           Outputs the result to the file named in $filename.

       output_encoding()
           Returns the output encoding of the results. Defaults to &quot;UTF-8&quot;.

       media_type()
           Returns the output media_type of the results. Defaults to
           &quot;text/html&quot;.

Parameters
       LibXSLT expects parameters in XPath format. That is, if you wish to pass
       a string to the XSLT engine, you actually have to pass it as a quoted
       string:

         $stylesheet-&gt;transform($doc, param =&gt; &quot;&apos;string&apos;&quot;);

       Note the quotes within quotes there!

       Obviously this isn&apos;t much fun, so you can make it easy on yourself:

         $stylesheet-&gt;transform($doc, XML::LibXSLT::xpath_to_string(
               param =&gt; &quot;string&quot;
               ));

       The utility function does the right thing with respect to strings in
       XPath, including when you have quotes already embedded within your
       string.

XML::LibXSLT::Security
       Provides an interface to the libxslt security framework by allowing
       callbacks to be defined that can restrict access to various resources
       (files or URLs) during a transformation.

       The libxslt security framework allows callbacks to be defined for certain
       actions that a stylesheet may attempt during a transformation. It may be
       desirable to restrict some of these actions (for example, writing a new
       file using exsl:document). The actions that may be restricted are:

       read_file
           Called when the stylesheet attempts to open a local file (ie: when
           using the document() function).

       write_file
           Called when an attempt is made to write a local file (ie: when using
           the exsl:document element).

       create_dir
           Called when a directory needs to be created in order to write a file.

           NOTE: By default, create_dir is not allowed. To enable it a callback
           must be registered.

       read_net
           Called when the stylesheet attempts to read from the network.

       write_net
           Called when the stylesheet attempts to write to the network.

   Using XML::LibXSLT::Security
       The interface for this module is similar to XML::LibXML::InputCallback.
       After creating a new instance you may register callbacks for each of the
       security options listed above. Then you apply the security preferences to
       the XML::LibXSLT or XML::LibXSLT::Stylesheet object using
       &quot;security_callbacks()&quot;.

         my $security = XML::LibXSLT::Security-&gt;new();
         $security-&gt;register_callback( read_file  =&gt; $read_cb );
         $security-&gt;register_callback( write_file =&gt; $write_cb );
         $security-&gt;register_callback( create_dir =&gt; $create_cb );
         $security-&gt;register_callback( read_net   =&gt; $read_net_cb );
         $security-&gt;register_callback( write_net  =&gt; $write_net_cb );

         $xslt-&gt;security_callbacks( $security );
          -OR-
         $stylesheet-&gt;security_callbacks( $security );

       The registered callback functions are called when access to a resource is
       requested. If the access should be allowed the callback should return 1,
       if not it should return 0. The callback functions should accept the
       following arguments:

       $tctxt
           This is the transform context (XML::LibXSLT::TransformContext). You
           can use this to get the current XML::LibXSLT::Stylesheet object by
           calling &quot;stylesheet()&quot;.

             my $stylesheet = $tctxt-&gt;stylesheet();

           The stylesheet object can then be used to share contextual
           information between different calls to the security callbacks.

       $value
           This is the name of the resource (file or URI) that has been
           requested.

       If a particular option (except for &quot;create_dir&quot;) doesn&apos;t have a
       registered callback, then the stylesheet will have full access for that
       action.

   Interface
       new()
           Creates a new XML::LibXSLT::Security object.
&#12;       register_callback( $option, $callback )
           Registers a callback function for the given security option (listed
           above).

       unregister_callback( $option )
           Removes the callback for the given option. This has the effect of
           allowing all access for the given option (except for &quot;create_dir&quot;).

BENCHMARK
       Included in the distribution is a simple benchmark script, which has two
       drivers - one for LibXSLT and one for Sablotron. The benchmark requires
       the testcases files from the XSLTMark distribution which you can find at
       http://www.datapower.com/XSLTMark/

       Put the testcases directory in the directory created by this
       distribution, and then run:

         perl benchmark.pl -h

       to get a list of options.

       The benchmark requires XML::XPath at the moment, but I hope to factor
       that out of the equation fairly soon. It also requires Time::HiRes, which
       I could be persuaded to factor out, replacing it with Benchmark.pm, but I
       haven&apos;t done so yet.

       I would love to get drivers for XML::XSLT and XML::Transformiix, if you
       would like to contribute them. Also if you get this running on Win32, I&apos;d
       love to get a driver for MSXSLT via OLE, to see what we can do against
       those Redmond boys!

LIBRARY VERSIONS
       For debugging purposes, XML::LibXSLT provides version information about
       the libxslt C library (but do not confuse it with the version number of
       XML::LibXSLT module itself, i.e. with $XML::LibXSLT::VERSION).
       XML::LibXSLT issues a warning if the runtime version of the library is
       less then the compile-time version.

       XML::LibXSLT::LIBXSLT_VERSION()
           Returns version number of libxslt library which was used to compile
           XML::LibXSLT as an integer. For example, for libxslt-1.1.18, it will
           return 10118.

       XML::LibXSLT::LIBXSLT_DOTTED_VERSION()
           Returns version number of libxslt library which was used to compile
           XML::LibXSLT as a string, e.g. &quot;1.1.18&quot;.

       XML::LibXSLT::LIBXSLT_RUNTIME_VERSION()
           Returns version number of libxslt library to which XML::LibXSLT is
           linked at runtime (either dynamically or statically). For example,
           for example, for libxslt.so.1.1.18, it will return 10118.

       XML::LibXSLT::HAVE_EXLT()
           Returns 1 if the module was compiled with libexslt, 0 otherwised.

LICENSE
       This is free software, you may use it and distribute it under the same
       terms as Perl itself.

       Copyright 2001-2009, AxKit.com Ltd.

AUTHOR
       Matt Sergeant, matt@sergeant.org

       Security callbacks implementation contributed by Shane Corgatelli.

MAINTAINER
       Petr Pajas , pajas@matfyz.org

BUGS
       Please report bugs via

         http://rt.cpan.org/NoAuth/Bugs.html?Dist=XML-LibXSLT

SEE ALSO
       XML::LibXML



perl v5.14.2                       2012-02-25                       LibXSLT(3pm)

</pre></body></html>
