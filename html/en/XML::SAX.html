<html>
<head><meta charset=utf-8/>
<title>XML::SAX - Simple API for XML</title></head>
<body><pre>

SAX(3pm)               User Contributed Perl Documentation              SAX(3pm)



NAME
       XML::SAX - Simple API for XML

SYNOPSIS
         use XML::SAX;

         # get a list of known parsers
         my $parsers = XML::SAX-&gt;parsers();

         # add/update a parser
         XML::SAX-&gt;add_parser(q(XML::SAX::PurePerl));

         # remove parser
         XML::SAX-&gt;remove_parser(q(XML::SAX::Foodelberry));

         # save parsers
         XML::SAX-&gt;save_parsers();

DESCRIPTION
       XML::SAX is a SAX parser access API for Perl. It includes classes and
       APIs required for implementing SAX drivers, along with a factory class
       for returning any SAX parser installed on the user&apos;s system.

USING A SAX2 PARSER
       The factory class is XML::SAX::ParserFactory. Please see the
       documentation of that module for how to instantiate a SAX parser:
       XML::SAX::ParserFactory. However if you don&apos;t want to load up another
       manual page, here&apos;s a short synopsis:

         use XML::SAX::ParserFactory;
         use XML::SAX::XYZHandler;
         my $handler = XML::SAX::XYZHandler-&gt;new();
         my $p = XML::SAX::ParserFactory-&gt;parser(Handler =&gt; $handler);
         $p-&gt;parse_uri(&quot;foo.xml&quot;);
         # or $p-&gt;parse_string(&quot;&lt;foo/&gt;&quot;) or $p-&gt;parse_file($fh);

       This will automatically load a SAX2 parser (defaulting to
       XML::SAX::PurePerl if no others are found) and return it to you.

       In order to learn how to use SAX to parse XML, you will need to read
       XML::SAX::Intro and for reference, XML::SAX::Specification.

WRITING A SAX2 PARSER
       The first thing to remember in writing a SAX2 parser is to subclass
       XML::SAX::Base. This will make your life infinitely easier, by providing
       a number of methods automagically for you. See XML::SAX::Base for more
       details.

       When writing a SAX2 parser that is compatible with XML::SAX, you need to
       inform XML::SAX of the presence of that driver when you install it.  In
       order to do that, XML::SAX contains methods for saving the fact that the
       parser exists on your system to a &quot;INI&quot; file, which is then loaded to
       determine which parsers are installed.

       The best way to do this is to follow these rules:

       &#183;   Add XML::SAX as a prerequisite in Makefile.PL:

             WriteMakefile(
                 ...
                 PREREQ_PM =&gt; { &apos;XML::SAX&apos; =&gt; 0 },
                 ...
             );
&#12;           Alternatively you may wish to check for it in other ways that will
           cause more than just a warning.

       &#183;   Add the following code snippet to your Makefile.PL:

             sub MY::install {
               package MY;
               my $script = shift-&gt;SUPER::install(@_);
               if (ExtUtils::MakeMaker::prompt(
                 &quot;Do you want to modify ParserDetails.ini?&quot;, &apos;Y&apos;)
                 =~ /^y/i) {
                 $script =~ s/install :: (.*)$/install :: $1 install_sax_driver/m;
                 $script .= &lt;&lt;&quot;INSTALL&quot;;

             install_sax_driver :
             \t\@\$(PERL) -MXML::SAX -e &quot;XML::SAX-&gt;add_parser(q(\$(NAME)))-&gt;save_parsers()&quot;

             INSTALL
               }
               return $script;
             }

           Note that you should check the output of this - \$(NAME) will use the
           name of your distribution, which may not be exactly what you want.
           For example XML::LibXML has a driver called
           XML::LibXML::SAX::Generator, which is used in place of \$(NAME) in
           the above.

       &#183;   Add an XML::SAX test:

           A test file should be added to your t/ directory containing something
           like the following:

             use Test;
             BEGIN { plan tests =&gt; 3 }
             use XML::SAX;
             use XML::SAX::PurePerl::DebugHandler;
             XML::SAX-&gt;add_parser(q(XML::SAX::MyDriver));
             local $XML::SAX::ParserPackage = &apos;XML::SAX::MyDriver&apos;;
             eval {
               my $handler = XML::SAX::PurePerl::DebugHandler-&gt;new();
               ok($handler);
               my $parser = XML::SAX::ParserFactory-&gt;parser(Handler =&gt; $handler);
               ok($parser);
               ok($parser-&gt;isa(&apos;XML::SAX::MyDriver&apos;);
               $parser-&gt;parse_string(&quot;&lt;tag/&gt;&quot;);
               ok($handler-&gt;{seen}{start_element});
             };

EXPORTS
       By default, XML::SAX exports nothing into the caller&apos;s namespace. However
       you can request the symbols &quot;Namespaces&quot; and &quot;Validation&quot; which are the
       URIs for those features, allowing an easier way to request those features
       via ParserFactory:

         use XML::SAX qw(Namespaces Validation);
         my $factory = XML::SAX::ParserFactory-&gt;new();
         $factory-&gt;require_feature(Namespaces);
         $factory-&gt;require_feature(Validation);
         my $parser = $factory-&gt;parser();

AUTHOR
       Current maintainer: Grant McLean, grantm@cpan.org

       Originally written by:

       Matt Sergeant, matt@sergeant.org
&#12;       Kip Hampton, khampton@totalcinema.com

       Robin Berjon, robin@knowscape.com

LICENSE
       This is free software, you may use it and distribute it under the same
       terms as Perl itself.

SEE ALSO
       XML::SAX::Base for writing SAX Filters and Parsers

       XML::SAX::PurePerl for an XML parser written in 100% pure perl.

       XML::SAX::Exception for details on exception handling



perl v5.14.2                       2012-06-01                           SAX(3pm)

</pre></body></html>
