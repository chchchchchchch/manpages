<html>
<head><meta charset=utf-8/>
<title>XML::Simple::FAQ - Frequently Asked Questions about XML::Simple</title></head>
<body><pre>

XML::Simple::FAQ(3pm)  User Contributed Perl Documentation XML::Simple::FAQ(3pm)



NAME
       XML::Simple::FAQ - Frequently Asked Questions about XML::Simple

Basics
   What is XML::Simple designed to be used for?
       XML::Simple is a Perl module that was originally developed as a tool for
       reading and writing configuration data in XML format.  You can use it for
       many other purposes that involve storing and retrieving structured data
       in XML.

       You might also find XML::Simple a good starting point for playing with
       XML from Perl.  It doesn&apos;t have a steep learning curve and if you outgrow
       its capabilities there are plenty of other Perl/XML modules to &apos;step up&apos;
       to.

   Why store configuration data in XML anyway?
       The many advantages of using XML format for configuration data include:

       &#183;   Using existing XML parsing tools requires less development time, is
           easier and more robust than developing your own config file parsing
           code

       &#183;   XML can represent relationships between pieces of data, such as
           nesting of sections to arbitrary levels (not easily done with .INI
           files for example)

       &#183;   XML is basically just text, so you can easily edit a config file
           (easier than editing a Win32 registry)

       &#183;   XML provides standard solutions for handling character sets and
           encoding beyond basic ASCII (important for internationalization)

       &#183;   If it becomes necessary to change your configuration file format,
           there are many tools available for performing transformations on XML
           files

       &#183;   XML is an open standard (the world does not need more proprietary
           binary file formats)

       &#183;   Taking the extra step of developing a DTD allows the format of
           configuration files to be validated before your program reads them
           (not directly supported by XML::Simple)

       &#183;   Combining a DTD with a good XML editor can give you a GUI config
           editor for minimal coding effort

   What isn&apos;t XML::Simple good for?
       The main limitation of XML::Simple is that it does not work with &apos;mixed
       content&apos; (see the next question).  If you consider your XML files contain
       marked up text rather than structured data, you should probably use
       another module.

       If you are working with very large XML files, XML::Simple&apos;s approach of
       representing the whole file in memory as a &apos;tree&apos; data structure may not
       be suitable.

   What is mixed content?
       Consider this example XML:

         &lt;document&gt;
           &lt;para&gt;This is &lt;em&gt;mixed&lt;/em&gt; content.&lt;/para&gt;
         &lt;/document&gt;
&#12;       This is said to be mixed content, because the &lt;para&gt; element contains
       both character data (text content) and nested elements.

       Here&apos;s some more XML:

         &lt;person&gt;
           &lt;first_name&gt;Joe&lt;/first_name&gt;
           &lt;last_name&gt;Bloggs&lt;/last_name&gt;
           &lt;dob&gt;25-April-1969&lt;/dob&gt;
         &lt;/person&gt;

       This second example is not generally considered to be mixed content.  The
       &lt;first_name&gt;, &lt;last_name&gt; and &lt;dob&gt; elements contain only character data
       and the  &lt;person&gt; element contains only nested elements.  (Note: Strictly
       speaking, the whitespace between the nested elements is character data,
       but it is ignored by XML::Simple).

   Why doesn&apos;t XML::Simple handle mixed content?
       Because if it did, it would no longer be simple :-)

       Seriously though, there are plenty of excellent modules that allow you to
       work with mixed content in a variety of ways.  Handling mixed content
       correctly is not easy and by ignoring these issues, XML::Simple is able
       to present an API without a steep learning curve.

   Which Perl modules do handle mixed content?
       Every one of them except XML::Simple :-)

       If you&apos;re looking for a recommendation, I&apos;d suggest you look at the Perl-
       XML FAQ at:

         http://perl-xml.sourceforge.net/faq/

Installation
   How do I install XML::Simple?
       If you&apos;re running ActiveState Perl, you&apos;ve probably already got
       XML::Simple (although you may want to upgrade to version 1.09 or better
       for SAX support).

       If you do need to install XML::Simple, you&apos;ll need to install an XML
       parser module first.  Install either XML::Parser (which you may have
       already) or XML::SAX.  If you install both, XML::SAX will be used by
       default.

       Once you have a parser installed ...

       On Unix systems, try:

         perl -MCPAN -e &apos;install XML::Simple&apos;

       If that doesn&apos;t work, download the latest distribution from
       ftp://ftp.cpan.org/pub/CPAN/authors/id/G/GR/GRANTM , unpack it and run
       these commands:

         perl Makefile.PL
         make
         make test
         make install

       On Win32, if you have a recent build of ActiveState Perl (618 or better)
       try this command:

         ppm install XML::Simple

       If that doesn&apos;t work, you really only need the Simple.pm file, so extract
       it from the .tar.gz file (eg: using WinZIP) and save it in the
       \site\lib\XML directory under your Perl installation (typically C:\Perl).

   I&apos;m trying to install XML::Simple and &apos;make test&apos; fails
       Is the directory where you&apos;ve unpacked XML::Simple mounted from a file
       server using NFS, SMB or some other network file sharing?  If so, that
       may cause errors in the the following test scripts:

         3_Storable.t
         4_MemShare.t
         5_MemCopy.t

       The test suite is designed to exercise the boundary conditions of all
       XML::Simple&apos;s functionality and these three scripts exercise the caching
       functions.  If XML::Simple is asked to parse a file for which it has a
       cached copy of a previous parse, then it compares the timestamp on the
       XML file with the timestamp on the cached copy.  If the cached copy is
       *newer* then it will be used.  If the cached copy is older or the same
       age then the file is re-parsed.  The test scripts will get confused by
       networked filesystems if the workstation and server system clocks are not
       synchronised (to the second).

       If you get an error in one of these three test scripts but you don&apos;t plan
       to use the caching options (they&apos;re not enabled by default), then go
       right ahead and run &apos;make install&apos;.  If you do plan to use caching, then
       try unpacking the distribution on local disk and doing the build/test
       there.

       It&apos;s probably not a good idea to use the caching options with networked
       filesystems in production.  If the file server&apos;s clock is ahead of the
       local clock, XML::Simple will re-parse files when it could have used the
       cached copy.  However if the local clock is ahead of the file server
       clock and a file is changed immediately after it is cached, the old
       cached copy will be used.

       Is one of the three test scripts (above) failing but you&apos;re not running
       on a network filesystem?  Are you running Win32?  If so, you may be
       seeing a bug in Win32 where writes to a file do not affect its
       modfication timestamp.

       If none of these scenarios match your situation, please confirm you&apos;re
       running the latest version of XML::Simple and then email the output of
       &apos;make test&apos; to me at grantm@cpan.org

   Why is XML::Simple so slow?
       If you find that XML::Simple is very slow reading XML, the most likely
       reason is that you have XML::SAX installed but no additional SAX parser
       module.  The XML::SAX distribution includes an XML parser written
       entirely in Perl.  This is very portable but not very fast.  For better
       performance install either XML::SAX::Expat or XML::LibXML.

Usage
   How do I use XML::Simple?
       If you had an XML document called /etc/appconfig/foo.xml you could
       &apos;slurp&apos; it into a simple data structure (typically a hashref) with these
       lines of code:

         use XML::Simple;

         my $config = XMLin(&apos;/etc/appconfig/foo.xml&apos;);

       The XMLin() function accepts options after the filename.

   There are so many options, which ones do I really need to know about?
       Although you can get by without using any options, you shouldn&apos;t even
       consider using XML::Simple in production until you know what these two
       options do:

       &#183;   forcearray
&#12;       &#183;   keyattr

       The reason you really need to read about them is because the default
       values for these options will trip you up if you don&apos;t.  Although
       everyone agrees that these defaults are not ideal, there is not wide
       agreement on what they should be changed to.  The answer therefore is to
       read about them (see below) and select values which are right for you.

   What is the forcearray option all about?
       Consider this XML in a file called ./person.xml:

         &lt;person&gt;
           &lt;first_name&gt;Joe&lt;/first_name&gt;
           &lt;last_name&gt;Bloggs&lt;/last_name&gt;
           &lt;hobbie&gt;bungy jumping&lt;/hobbie&gt;
           &lt;hobbie&gt;sky diving&lt;/hobbie&gt;
           &lt;hobbie&gt;knitting&lt;/hobbie&gt;
         &lt;/person&gt;

       You could read it in with this line:

         my $person = XMLin(&apos;./person.xml&apos;);

       Which would give you a data structure like this:

         $person = {
           &apos;first_name&apos; =&gt; &apos;Joe&apos;,
           &apos;last_name&apos;  =&gt; &apos;Bloggs&apos;,
           &apos;hobbie&apos;     =&gt; [ &apos;bungy jumping&apos;, &apos;sky diving&apos;, &apos;knitting&apos; ]
         };

       The &lt;first_name&gt; and &lt;last_name&gt; elements are represented as simple
       scalar values which you could refer to like this:

         print &quot;$person-&gt;{first_name} $person-&gt;{last_name}\n&quot;;

       The &lt;hobbie&gt; elements are represented as an array - since there is more
       than one.  You could refer to the first one like this:

         print $person-&gt;{hobbie}-&gt;[0], &quot;\n&quot;;

       Or the whole lot like this:

         print join(&apos;, &apos;, @{$person-&gt;{hobbie}} ), &quot;\n&quot;;

       The catch is, that these last two lines of code will only work for people
       who have more than one hobbie.  If there is only one &lt;hobbie&gt; element, it
       will be represented as a simple scalar (just like &lt;first_name&gt; and
       &lt;last_name&gt;).  Which might lead you to write code like this:

         if(ref($person-&gt;{hobbie})) {
           print join(&apos;, &apos;, @{$person-&gt;{hobbie}} ), &quot;\n&quot;;
         }
         else {
           print $person-&gt;{hobbie}, &quot;\n&quot;;
         }

       Don&apos;t do that.

       One alternative approach is to set the forcearray option to a true value:

         my $person = XMLin(&apos;./person.xml&apos;, forcearray =&gt; 1);

       Which will give you a data structure like this:

         $person = {
           &apos;first_name&apos; =&gt; [ &apos;Joe&apos; ],
           &apos;last_name&apos;  =&gt; [ &apos;Bloggs&apos; ],
           &apos;hobbie&apos;     =&gt; [ &apos;bungy jumping&apos;, &apos;sky diving&apos;, &apos;knitting&apos; ]
         };
&#12;       Then you can use this line to refer to all the list of hobbies even if
       there was only one:

         print join(&apos;, &apos;, @{$person-&gt;{hobbie}} ), &quot;\n&quot;;

       The downside of this approach is that the &lt;first_name&gt; and &lt;last_name&gt;
       elements will also always be represented as arrays even though there will
       never be more than one:

         print &quot;$person-&gt;{first_name}-&gt;[0] $person-&gt;{last_name}-&gt;[0]\n&quot;;

       This might be OK if you change the XML to use attributes for things that
       will always be singular and nested elements for things that may be
       plural:

         &lt;person first_name=&quot;Jane&quot; last_name=&quot;Bloggs&quot;&gt;
           &lt;hobbie&gt;motorcycle maintenance&lt;/hobbie&gt;
         &lt;/person&gt;

       On the other hand, if you prefer not to use attributes, then you could
       specify that any &lt;hobbie&gt; elements should always be represented as arrays
       and all other nested elements should be simple scalar values unless there
       is more than one:

         my $person = XMLin(&apos;./person.xml&apos;, forcearray =&gt; [ &apos;hobbie&apos; ]);

       The forcearray option accepts a list of element names which should always
       be forced to an array representation:

         forcearray =&gt; [ qw(hobbie qualification childs_name) ]

       See the XML::Simple manual page for more information.

   What is the keyattr option all about?
       Consider this sample XML:

         &lt;catalog&gt;
           &lt;part partnum=&quot;1842334&quot; desc=&quot;High pressure flange&quot; price=&quot;24.50&quot; /&gt;
           &lt;part partnum=&quot;9344675&quot; desc=&quot;Threaded gasket&quot;      price=&quot;9.25&quot; /&gt;
           &lt;part partnum=&quot;5634896&quot; desc=&quot;Low voltage washer&quot;   price=&quot;12.00&quot; /&gt;
         &lt;/catalog&gt;

       You could slurp it in with this code:

         my $catalog = XMLin(&apos;./catalog.xml&apos;);

       Which would return a data structure like this:

         $catalog = {
             &apos;part&apos; =&gt; [
                 {
                   &apos;partnum&apos; =&gt; &apos;1842334&apos;,
                   &apos;desc&apos;    =&gt; &apos;High pressure flange&apos;,
                   &apos;price&apos;   =&gt; &apos;24.50&apos;
                 },
                 {
                   &apos;partnum&apos; =&gt; &apos;9344675&apos;,
                   &apos;desc&apos;    =&gt; &apos;Threaded gasket&apos;,
                   &apos;price&apos;   =&gt; &apos;9.25&apos;
                 },
                 {
                   &apos;partnum&apos; =&gt; &apos;5634896&apos;,
                   &apos;desc&apos;    =&gt; &apos;Low voltage washer&apos;,
                   &apos;price&apos;   =&gt; &apos;12.00&apos;
                 }
             ]
         };

       Then you could access the description of the first part in the catalog
       with this code:
&#12;         print $catalog-&gt;{part}-&gt;[0]-&gt;{desc}, &quot;\n&quot;;

       However, if you wanted to access the description of the part with the
       part number of &quot;9344675&quot; then you&apos;d have to code a loop like this:

         foreach my $part (@{$catalog-&gt;{part}}) {
           if($part-&gt;{partnum} eq &apos;9344675&apos;) {
             print $part-&gt;{desc}, &quot;\n&quot;;
             last;
           }
         }

       The knowledge that each &lt;part&gt; element has a unique partnum attribute
       allows you to eliminate this search.  You can pass this knowledge on to
       XML::Simple like this:

         my $catalog = XMLin($xml, keyattr =&gt; [&apos;partnum&apos;]);

       Which will return a data structure like this:

         $catalog = {
           &apos;part&apos; =&gt; {
             &apos;5634896&apos; =&gt; { &apos;desc&apos; =&gt; &apos;Low voltage washer&apos;,   &apos;price&apos; =&gt; &apos;12.00&apos; },
             &apos;1842334&apos; =&gt; { &apos;desc&apos; =&gt; &apos;High pressure flange&apos;, &apos;price&apos; =&gt; &apos;24.50&apos; },
             &apos;9344675&apos; =&gt; { &apos;desc&apos; =&gt; &apos;Threaded gasket&apos;,      &apos;price&apos; =&gt; &apos;9.25&apos;  }
           }
         };

       XML::Simple has been able to transform $catalog-&gt;{part} from an arrayref
       to a hashref (keyed on partnum).  This transformation is called &apos;array
       folding&apos;.

       Through the use of array folding, you can now index directly to the
       description of the part you want:

         print $catalog-&gt;{part}-&gt;{9344675}-&gt;{desc}, &quot;\n&quot;;

       The &apos;keyattr&apos; option also enables array folding when the unique key is in
       a nested element rather than an attribute.  eg:

         &lt;catalog&gt;
           &lt;part&gt;
             &lt;partnum&gt;1842334&lt;/partnum&gt;
             &lt;desc&gt;High pressure flange&lt;/desc&gt;
             &lt;price&gt;24.50&lt;/price&gt;
           &lt;/part&gt;
           &lt;part&gt;
             &lt;partnum&gt;9344675&lt;/partnum&gt;
             &lt;desc&gt;Threaded gasket&lt;/desc&gt;
             &lt;price&gt;9.25&lt;/price&gt;
           &lt;/part&gt;
           &lt;part&gt;
             &lt;partnum&gt;5634896&lt;/partnum&gt;
             &lt;desc&gt;Low voltage washer&lt;/desc&gt;
             &lt;price&gt;12.00&lt;/price&gt;
           &lt;/part&gt;
         &lt;/catalog&gt;

       See the XML::Simple manual page for more information.

   So what&apos;s the catch with &apos;keyattr&apos;?
       One thing to watch out for is that you might get array folding even if
       you don&apos;t supply the keyattr option.  The default value for this option
       is:

         [ &apos;name&apos;, &apos;key&apos;, &apos;id&apos;]

       Which means if your XML elements have a &apos;name&apos;, &apos;key&apos; or &apos;id&apos; attribute
       (or nested element) then they may get folded on those values.  This means
       that you can take advantage of array folding simply through careful
       choice of attribute names.  On the hand, if you really don&apos;t want array
       folding at all, you&apos;ll need to set &apos;key attr to an empty list:

         my $ref = XMLin($xml, keyattr =&gt; []);

       A second &apos;gotcha&apos; is that array folding only works on arrays.  That might
       seem obvious, but if there&apos;s only one record in your XML and you didn&apos;t
       set the &apos;forcearray&apos; option then it won&apos;t be represented as an array and
       consequently won&apos;t get folded into a hash.  The moral is that if you&apos;re
       using array folding, you should always turn on the forcearray option.

       You probably want to be as specific as you can be too.  For instance, the
       safest way to parse the &lt;catalog&gt; example above would be:

         my $catalog = XMLin($xml, keyattr =&gt; { part =&gt; &apos;partnum&apos;},
                                   forcearray =&gt; [&apos;part&apos;]);

       By using the hashref for keyattr, you can specify that only &lt;part&gt;
       elements should be folded on the &apos;partnum&apos; attribute (and that the &lt;part&gt;
       elements should not be folded on any other attribute).

       By supplying a list of element names for forcearray, you&apos;re ensuring that
       folding will work even if there&apos;s only one &lt;part&gt;.  You&apos;re also ensuring
       that if the &apos;partnum&apos; unique key is supplied in a nested element then
       that element won&apos;t get forced to an array too.

   How do I know what my data structure should look like?
       The rules are fairly straightforward:

       &#183;   each element gets represented as a hash

       &#183;   unless it contains only text, in which case it&apos;ll be a simple scalar
           value

       &#183;   or unless there&apos;s more than one element with the same name, in which
           case they&apos;ll be represented as an array

       &#183;   unless you&apos;ve got array folding enabled, in which case they&apos;ll be
           folded into a hash

       &#183;   empty elements (no text contents and no attributes) will either be
           represented as an empty hash, an empty string or undef - depending on
           the value of the &apos;suppressempty&apos; option.

       If you&apos;re in any doubt, use Data::Dumper, eg:

         use XML::Simple;
         use Data::Dumper;

         my $ref = XMLin($xml);

         print Dumper($ref);

   I&apos;m getting &apos;Use of uninitialized value&apos; warnings
       You&apos;re probably trying to index into a non-existant hash key - try
       Data::Dumper.

   I&apos;m getting a &apos;Not an ARRAY reference&apos; error
       Something that you expect to be an array is not.  The two most likely
       causes are that you forgot to use &apos;forcearray&apos; or that the array got
       folded into a hash - try Data::Dumper.

   I&apos;m getting a &apos;No such array field&apos; error
       Something that you expect to be a hash is actually an array.  Perhaps
       array folding failed because one element was missing the key attribute -
       try Data::Dumper.

   I&apos;m getting an &apos;Out of memory&apos; error
       Something in the data structure is not as you expect and Perl may be
       trying unsuccessfully to autovivify things - try Data::Dumper.

       If you&apos;re already using Data::Dumper, try calling Dumper() immediately
       after XMLin() - ie: before you attempt to access anything in the data
       structure.

   My element order is getting jumbled up
       If you read an XML file with XMLin() and then write it back out with
       XMLout(), the order of the elements will likely be different.  (However,
       if you read the file back in with XMLin() you&apos;ll get the same Perl data
       structure).

       The reordering happens because XML::Simple uses hashrefs to store your
       data and Perl hashes do not really have any order.

       It is possible that a future version of XML::Simple will use Tie::IxHash
       to store the data in hashrefs which do retain the order.  However this
       will not fix all cases of element order being lost.

       If your application really is sensitive to element order, don&apos;t use
       XML::Simple (and don&apos;t put order-sensitive values in attributes).

   XML::Simple turns nested elements into attributes
       If you read an XML file with XMLin() and then write it back out with
       XMLout(), some data which was originally stored in nested elements may
       end up in attributes.  (However, if you read the file back in with
       XMLin() you&apos;ll get the same Perl data structure).

       There are a number of ways you might handle this:

       &#183;   use the &apos;forcearray&apos; option with XMLin()

       &#183;   use the &apos;noattr&apos; option with XMLout()

       &#183;   live with it

       &#183;   don&apos;t use XML::Simple

   Why does XMLout() insert &lt;name&gt; elements (or attributes)?
       Try setting keyattr =&gt; [].

       When you call XMLin() to read XML, the &apos;keyattr&apos; option controls whether
       arrays get &apos;folded&apos; into hashes.  Similarly, when you call XMLout(), the
       &apos;keyattr&apos; option controls whether hashes get &apos;unfolded&apos; into arrays.  As
       described above, &apos;keyattr&apos; is enabled by default.

   Why are empty elements represented as empty hashes?
       An element is always represented as a hash unless it contains only text,
       in which case it is represented as a scalar string.

       If you would prefer empty elements to be represented as empty strings or
       the undefined value, set the &apos;suppressempty&apos; option to &apos;&apos; or undef
       respectively.

   Why is ParserOpts deprecated?
       The &quot;ParserOpts&quot; option is a remnant of the time when XML::Simple only
       worked with the XML::Parser API.  Its value is completely ignored if
       you&apos;re using a SAX parser, so writing code which relied on it would bar
       you from taking advantage of SAX.

       Even if you are using XML::Parser, it is seldom necessary to pass options
       to the parser object.  A number of people have written to say they use
       this option to set XML::Parser&apos;s &quot;ProtocolEncoding&quot; option.  Don&apos;t do
       that, it&apos;s wrong, Wrong, WRONG!  Fix the XML document so that it&apos;s well-
       formed and you won&apos;t have a problem.

       Having said all of that, as long as XML::Simple continues to support the
       XML::Parser API, this option will not be removed.  There are currently no
       plans to remove support for the XML::Parser API.



perl v5.14.2                       2012-06-23              XML::Simple::FAQ(3pm)

</pre></body></html>
