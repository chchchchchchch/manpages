<html>
<head><meta charset=utf-8/>
<title>ffserver - ffserver video server</title></head>
<body><pre>

FFSERVER(1)                                                          FFSERVER(1)



NAME
       ffserver - ffserver video server

SYNOPSYS
       The generic syntax is:

               ffserver [options]

DESCRIPTION
       ffserver is a streaming server for both audio and video. It supports

       several live feeds, streaming from files and time shifting on live feeds
       (you can seek to positions in the past on each live feed, provided you
       specify a big enough feed storage in ffserver.conf).

       ffserver runs in daemon mode by default; that is, it puts itself in the
       background and detaches from its TTY, unless it is launched in debug mode
       or a NoDaemon option is specified in the configuration file.

       This documentation covers only the streaming aspects of ffserver /
       ffmpeg. All questions about parameters for ffmpeg, codec questions, etc.
       are not covered here. Read ffmpeg.html for more information.

   How does it work?
       ffserver receives prerecorded files or FFM streams from some ffmpeg
       instance as input, then streams them over RTP/RTSP/HTTP.

       An ffserver instance will listen on some port as specified in the
       configuration file. You can launch one or more instances of ffmpeg and
       send one or more FFM streams to the port where ffserver is expecting to
       receive them. Alternately, you can make ffserver launch such ffmpeg
       instances at startup.

       Input streams are called feeds, and each one is specified by a &lt;Feed&gt;
       section in the configuration file.

       For each feed you can have different output streams in various formats,
       each one specified by a &lt;Stream&gt; section in the configuration file.

   Status stream
       ffserver supports an HTTP interface which exposes the current status of
       the server.

       Simply point your browser to the address of the special status stream
       specified in the configuration file.

       For example if you have:

               &lt;Stream status.html&gt;
               Format status

               # Only allow local people to get the status
               ACL allow localhost
               ACL allow 192.168.0.0 192.168.255.255
               &lt;/Stream&gt;

       then the server will post a page with the status information when the
       special stream status.html is requested.

   What can this do?
       When properly configured and running, you can capture video and audio in
       real time from a suitable capture card, and stream it out over the
       Internet to either Windows Media Player or RealAudio player (with some
       restrictions).

       It can also stream from files, though that is currently broken. Very
       often, a web server can be used to serve up the files just as well.

       It can stream prerecorded video from .ffm files, though it is somewhat
       tricky to make it work correctly.

   What do I need?
       I use Linux on a 900 MHz Duron with a cheapo Bt848 based TV capture card.
       I&apos;m using stock Linux 2.4.17 with the stock drivers. [Actually that isn&apos;t
       true, I needed some special drivers for my motherboard-based sound card.]

       I understand that FreeBSD systems work just fine as well.

   How do I make it work?
       First, build the kit. It *really* helps to have installed LAME first.
       Then when you run the ffserver ./configure, make sure that you have the
       &quot;--enable-libmp3lame&quot; flag turned on.

       LAME is important as it allows for streaming audio to Windows Media
       Player.  Don&apos;t ask why the other audio types do not work.

       As a simple test, just run the following two command lines where
       INPUTFILE is some file which you can decode with ffmpeg:

               ffserver -f doc/ffserver.conf &amp;
               ffmpeg -i INPUTFILE http://localhost:8090/feed1.ffm

       At this point you should be able to go to your Windows machine and fire
       up Windows Media Player (WMP). Go to Open URL and enter

                   http://&lt;linuxbox&gt;:8090/test.asf

       You should (after a short delay) see video and hear audio.

       WARNING: trying to stream test1.mpg doesn&apos;t work with WMP as it tries to
       transfer the entire file before starting to play.  The same is true of
       AVI files.

   What happens next?
       You should edit the ffserver.conf file to suit your needs (in terms of
       frame rates etc). Then install ffserver and ffmpeg, write a script to
       start them up, and off you go.

   Troubleshooting
       I don&apos;t hear any audio, but video is fine.

       Maybe you didn&apos;t install LAME, or got your ./configure statement wrong.
       Check the ffmpeg output to see if a line referring to MP3 is present. If
       not, then your configuration was incorrect. If it is, then maybe your
       wiring is not set up correctly. Maybe the sound card is not getting data
       from the right input source. Maybe you have a really awful audio
       interface (like I do) that only captures in stereo and also requires that
       one channel be flipped.  If you are one of these people, then export
       &apos;AUDIO_FLIP_LEFT=1&apos; before starting ffmpeg.

       The audio and video lose sync after a while.

       Yes, they do.

       After a long while, the video update rate goes way down in WMP.

       Yes, it does. Who knows why?
&#12;       WMP 6.4 behaves differently to WMP 7.

       Yes, it does. Any thoughts on this would be gratefully received. These
       differences extend to embedding WMP into a web page. [There are two
       object IDs that you can use: The old one, which does not play well, and
       the new one, which does (both tested on the same system). However, I
       suspect that the new one is not available unless you have installed WMP
       7].

   What else can it do?
       You can replay video from .ffm files that was recorded earlier.  However,
       there are a number of caveats, including the fact that the ffserver
       parameters must match the original parameters used to record the file. If
       they do not, then ffserver deletes the file before recording into it.
       (Now that I write this, it seems broken).

       You can fiddle with many of the codec choices and encoding parameters,
       and there are a bunch more parameters that you cannot control. Post a
       message to the mailing list if there are some &apos;must have&apos; parameters.
       Look in ffserver.conf for a list of the currently available controls.

       It will automatically generate the ASX or RAM files that are often used
       in browsers. These files are actually redirections to the underlying ASF
       or RM file. The reason for this is that the browser often fetches the
       entire file before starting up the external viewer. The redirection files
       are very small and can be transferred quickly. [The stream itself is
       often &apos;infinite&apos; and thus the browser tries to download it and never
       finishes.]

   Tips
       * When you connect to a live stream, most players (WMP, RA, etc) want to
       buffer a certain number of seconds of material so that they can display
       the signal continuously. However, ffserver (by default) starts sending
       data in realtime. This means that there is a pause of a few seconds while
       the buffering is being done by the player. The good news is that this can
       be cured by adding a &apos;?buffer=5&apos; to the end of the URL. This means that
       the stream should start 5 seconds in the past -- and so the first 5
       seconds of the stream are sent as fast as the network will allow. It will
       then slow down to real time. This noticeably improves the startup
       experience.

       You can also add a &apos;Preroll 15&apos; statement into the ffserver.conf that
       will add the 15 second prebuffering on all requests that do not otherwise
       specify a time. In addition, ffserver will skip frames until a key_frame
       is found. This further reduces the startup delay by not transferring data
       that will be discarded.

       * You may want to adjust the MaxBandwidth in the ffserver.conf to limit
       the amount of bandwidth consumed by live streams.

   Why does the ?buffer / Preroll stop working after a time?
       It turns out that (on my machine at least) the number of frames
       successfully grabbed is marginally less than the number that ought to be
       grabbed. This means that the timestamp in the encoded data stream gets
       behind realtime.  This means that if you say &apos;Preroll 10&apos;, then when the
       stream gets 10 or more seconds behind, there is no Preroll left.

       Fixing this requires a change in the internals of how timestamps are
       handled.

   Does the &quot;?date=&quot; stuff work.
       Yes (subject to the limitation outlined above). Also note that whenever
       you start ffserver, it deletes the ffm file (if any parameters have
       changed), thus wiping out what you had recorded before.

       The format of the &quot;?date=xxxxxx&quot; is fairly flexible. You should use one
       of the following formats (the &apos;T&apos; is literal):

               * YYYY-MM-DDTHH:MM:SS     (localtime)
               * YYYY-MM-DDTHH:MM:SSZ    (UTC)

       You can omit the YYYY-MM-DD, and then it refers to the current day.
       However note that ?date=16:00:00 refers to 16:00 on the current day --
       this may be in the future and so is unlikely to be useful.

       You use this by adding the ?date= to the end of the URL for the stream.
       For example:   http://localhost:8080/test.asf?date=2002-07-26T23:05:00.

OPTIONS
       All the numerical options, if not specified otherwise, accept in input a
       string representing a number, which may contain one of the International
       System number postfixes, for example &apos;K&apos;, &apos;M&apos;, &apos;G&apos;.  If &apos;i&apos; is appended
       after the postfix, powers of 2 are used instead of powers of 10. The &apos;B&apos;
       postfix multiplies the value for 8, and can be appended after another
       postfix or used alone. This allows using for example &apos;KB&apos;, &apos;MiB&apos;, &apos;G&apos; and
       &apos;B&apos; as postfix.

       Options which do not take arguments are boolean options, and set the
       corresponding value to true. They can be set to false by prefixing with
       &quot;no&quot; the option name, for example using &quot;-nofoo&quot; in the command line will
       set to false the boolean option with name &quot;foo&quot;.

   Stream specifiers
       Some options are applied per-stream, e.g. bitrate or codec. Stream
       specifiers are used to precisely specify which stream(s) does a given
       option belong to.

       A stream specifier is a string generally appended to the option name and
       separated from it by a colon. E.g. &quot;-codec:a:1 ac3&quot; option contains &quot;a:1&quot;
       stream specifier, which matches the second audio stream. Therefore it
       would select the ac3 codec for the second audio stream.

       A stream specifier can match several streams, the option is then applied
       to all of them. E.g. the stream specifier in &quot;-b:a 128k&quot; matches all
       audio streams.

       An empty stream specifier matches all streams, for example &quot;-codec copy&quot;
       or &quot;-codec: copy&quot; would copy all the streams without reencoding.

       Possible forms of stream specifiers are:

       stream_index
           Matches the stream with this index. E.g. &quot;-threads:1 4&quot; would set the
           thread count for the second stream to 4.

       stream_type[:stream_index]
           stream_type is one of: &apos;v&apos; for video, &apos;a&apos; for audio, &apos;s&apos; for
           subtitle, &apos;d&apos; for data and &apos;t&apos; for attachments. If stream_index is
           given, then matches stream number stream_index of this type.
           Otherwise matches all streams of this type.

       p:program_id[:stream_index]
           If stream_index is given, then matches stream number stream_index in
           program with id program_id. Otherwise matches all streams in this
           program.

       #stream_id
           Matches the stream by format-specific ID.

   Generic options
       These options are shared amongst the av* tools.
&#12;       -L  Show license.

       -h, -?, -help, --help [arg]
           Show help. An optional parameter may be specified to print help about
           a specific item.

           Possible values of arg are:

           decoder=decoder_name
               Print detailed information about the decoder named decoder_name.
               Use the -decoders option to get a list of all decoders.

           encoder=encoder_name
               Print detailed information about the encoder named encoder_name.
               Use the -encoders option to get a list of all encoders.

           demuxer=demuxer_name
               Print detailed information about the demuxer named demuxer_name.
               Use the -formats option to get a list of all demuxers and muxers.

           muxer=muxer_name
               Print detailed information about the muxer named muxer_name. Use
               the -formats option to get a list of all muxers and demuxers.

       -version
           Show version.

       -formats
           Show available formats.

           The fields preceding the format names have the following meanings:

           D   Decoding available

           E   Encoding available

       -codecs
           Show all codecs known to libavcodec.

           Note that the term &apos;codec&apos; is used throughout this documentation as a
           shortcut for what is more correctly called a media bitstream format.

       -decoders
           Show available decoders.

       -encoders
           Show all available encoders.

       -bsfs
           Show available bitstream filters.

       -protocols
           Show available protocols.

       -filters
           Show available libavfilter filters.

       -pix_fmts
           Show available pixel formats.

       -sample_fmts
           Show available sample formats.

       -layouts
           Show channel names and standard channel layouts.
&#12;       -loglevel loglevel | -v loglevel
           Set the logging level used by the library.  loglevel is a number or a
           string containing one of the following values:

           quiet
           panic
           fatal
           error
           warning
           info
           verbose
           debug

           By default the program logs to stderr, if coloring is supported by
           the terminal, colors are used to mark errors and warnings. Log
           coloring can be disabled setting the environment variable
           AV_LOG_FORCE_NOCOLOR or NO_COLOR, or can be forced setting the
           environment variable AV_LOG_FORCE_COLOR.  The use of the environment
           variable NO_COLOR is deprecated and will be dropped in a following
           FFmpeg version.

       -report
           Dump full command line and console output to a file named
           &quot;program-YYYYMMDD-HHMMSS.log&quot; in the current directory.  This file
           can be useful for bug reports.  It also implies &quot;-loglevel verbose&quot;.

           Note: setting the environment variable &quot;FFREPORT&quot; to any value has
           the same effect.

       -cpuflags flags (global)
           Allows setting and clearing cpu flags. This option is intended for
           testing. Do not use it unless you know what you&apos;re doing.

                   ffmpeg -cpuflags -sse+mmx ...
                   ffmpeg -cpuflags mmx ...
                   ffmpeg -cpuflags 0 ...

   AVOptions
       These options are provided directly by the libavformat, libavdevice and
       libavcodec libraries. To see the list of available AVOptions, use the
       -help option. They are separated into two categories:

       generic
           These options can be set for any container, codec or device. Generic
           options are listed under AVFormatContext options for
           containers/devices and under AVCodecContext options for codecs.

       private
           These options are specific to the given container, device or codec.
           Private options are listed under their corresponding
           containers/devices/codecs.

       For example to write an ID3v2.3 header instead of a default ID3v2.4 to an
       MP3 file, use the id3v2_version private option of the MP3 muxer:

               ffmpeg -i input.flac -id3v2_version 3 out.mp3

       All codec AVOptions are obviously per-stream, so the chapter on stream
       specifiers applies to them

       Note -nooption syntax cannot be used for boolean AVOptions, use -option
       0/-option 1.

       Note2 old undocumented way of specifying per-stream AVOptions by
       prepending v/a/s to the options name is now obsolete and will be removed
       soon.

   Codec AVOptions
       -b[:stream_specifier] integer (output,audio,video)
           set bitrate (in bits/s)

       -ab[:stream_specifier] integer (output,audio)
           set bitrate (in bits/s)

       -bt[:stream_specifier] integer (output,video)
           Set video bitrate tolerance (in bits/s). In 1-pass mode, bitrate
           tolerance specifies how far ratecontrol is willing to deviate from
           the target average bitrate value. This is not related to min/max
           bitrate. Lowering tolerance too much has an adverse effect on
           quality.

       -flags[:stream_specifier] flags (input/output,audio,video,subtitles)
           Possible values:

           mv4 use four motion vector by macroblock (mpeg4)

           qpel
               use 1/4 pel motion compensation

           loop
               use loop filter

           qscale
               use fixed qscale

           gmc use gmc

           mv0 always try a mb with mv=&lt;0,0&gt;

           input_preserved
           pass1
               use internal 2pass ratecontrol in first  pass mode

           pass2
               use internal 2pass ratecontrol in second pass mode

           gray
               only decode/encode grayscale

           emu_edge
               don&apos;t draw edges

           psnr
               error[?] variables will be set during encoding

           truncated
           naq normalize adaptive quantization

           ildct
               use interlaced dct

           low_delay
               force low delay

           global_header
               place global headers in extradata instead of every keyframe

           bitexact
               use only bitexact stuff (except (i)dct)

           aic h263 advanced intra coding / mpeg4 ac prediction
&#12;           cbp Deprecated, use mpegvideo private options instead

           qprd
               Deprecated, use mpegvideo private options instead

           ilme
               interlaced motion estimation

           cgop
               closed gop

       -sub_id[:stream_specifier] integer ()
       -me_method[:stream_specifier] integer (output,video)
           set motion estimation method

           Possible values:

           zero
               zero motion estimation (fastest)

           full
               full motion estimation (slowest)

           epzs
               EPZS motion estimation (default)

           esa esa motion estimation (alias for full)

           tesa
               tesa motion estimation

           dia dia motion estimation (alias for epzs)

           log log motion estimation

           phods
               phods motion estimation

           x1  X1 motion estimation

           hex hex motion estimation

           umh umh motion estimation

           iter
               iter motion estimation

       -extradata_size[:stream_specifier] integer ()
       -time_base[:stream_specifier] rational number ()
       -g[:stream_specifier] integer (output,video)
           set the group of picture size

       -ar[:stream_specifier] integer (input/output,audio)
           set audio sampling rate (in Hz)

       -ac[:stream_specifier] integer (input/output,audio)
           set number of audio channels

       -cutoff[:stream_specifier] integer (output,audio)
           set cutoff bandwidth

       -frame_size[:stream_specifier] integer (output,audio)
       -frame_number[:stream_specifier] integer ()
       -delay[:stream_specifier] integer ()
       -qcomp[:stream_specifier] float (output,video)
           video quantizer scale compression (VBR). Constant of ratecontrol
           equation. Recommended range for default rc_eq: 0.0-1.0

       -qblur[:stream_specifier] float (output,video)
           video quantizer scale blur (VBR)

       -qmin[:stream_specifier] integer (output,video)
           min video quantizer scale (VBR)

       -qmax[:stream_specifier] integer (output,video)
           max video quantizer scale (VBR)

       -qdiff[:stream_specifier] integer (output,video)
           max difference between the quantizer scale (VBR)

       -bf[:stream_specifier] integer (output,video)
           use &apos;frames&apos; B frames

       -b_qfactor[:stream_specifier] float (output,video)
           qp factor between p and b frames

       -rc_strategy[:stream_specifier] integer (output,video)
           ratecontrol method

       -b_strategy[:stream_specifier] integer (output,video)
           strategy to choose between I/P/B-frames

       -ps[:stream_specifier] integer (output,video)
           rtp payload size in bytes

       -mv_bits[:stream_specifier] integer ()
       -header_bits[:stream_specifier] integer ()
       -i_tex_bits[:stream_specifier] integer ()
       -p_tex_bits[:stream_specifier] integer ()
       -i_count[:stream_specifier] integer ()
       -p_count[:stream_specifier] integer ()
       -skip_count[:stream_specifier] integer ()
       -misc_bits[:stream_specifier] integer ()
       -frame_bits[:stream_specifier] integer ()
       -codec_tag[:stream_specifier] integer ()
       -bug[:stream_specifier] flags (input,video)
           workaround not auto detected encoder bugs

           Possible values:

           autodetect
           old_msmpeg4
               some old lavc generated msmpeg4v3 files (no autodetection)

           xvid_ilace
               Xvid interlacing bug (autodetected if fourcc==XVIX)

           ump4
               (autodetected if fourcc==UMP4)

           no_padding
               padding bug (autodetected)

           amv
           ac_vlc
               illegal vlc bug (autodetected per fourcc)

           qpel_chroma
           std_qpel
               old standard qpel (autodetected per fourcc/version)

           qpel_chroma2
           direct_blocksize
               direct-qpel-blocksize bug (autodetected per fourcc/version)
&#12;           edge
               edge padding bug (autodetected per fourcc/version)

           hpel_chroma
           dc_clip
           ms  workaround various bugs in microsofts broken decoders

           trunc
               trancated frames

       -lelim[:stream_specifier] integer (output,video)
           single coefficient elimination threshold for luminance (negative
           values also consider dc coefficient)

       -celim[:stream_specifier] integer (output,video)
           single coefficient elimination threshold for chrominance (negative
           values also consider dc coefficient)

       -strict[:stream_specifier] integer (input/output,audio,video)
           how strictly to follow the standards

           Possible values:

           very
               strictly conform to a older more strict version of the spec or
               reference software

           strict
               strictly conform to all the things in the spec no matter what
               consequences

           normal
           unofficial
               allow unofficial extensions

           experimental
               allow non standardized experimental things

       -b_qoffset[:stream_specifier] float (output,video)
           qp offset between P and B frames

       -err_detect[:stream_specifier] flags (input,audio,video)
           set error detection flags

           Possible values:

           crccheck
               verify embedded CRCs

           bitstream
               detect bitstream specification deviations

           buffer
               detect improper bitstream length

           explode
               abort decoding on minor error detection

           careful
               consider things that violate the spec and have not been seen in
               the wild as errors

           compliant
               consider all spec non compliancies as errors

           aggressive
               consider things that a sane encoder should not do as an error
&#12;       -has_b_frames[:stream_specifier] integer ()
       -block_align[:stream_specifier] integer ()
       -mpeg_quant[:stream_specifier] integer (output,video)
           use MPEG quantizers instead of H.263

       -stats_out[:stream_specifier] string ()
       -qsquish[:stream_specifier] float (output,video)
           how to keep quantizer between qmin and qmax (0 = clip, 1 = use
           differentiable function)

       -rc_qmod_amp[:stream_specifier] float (output,video)
           experimental quantizer modulation

       -rc_qmod_freq[:stream_specifier] integer (output,video)
           experimental quantizer modulation

       -rc_override_count[:stream_specifier] integer ()
       -rc_eq[:stream_specifier] string (output,video)
           Set rate control equation. When computing the expression, besides the
           standard functions defined in the section &apos;Expression Evaluation&apos;,
           the following functions are available: bits2qp(bits), qp2bits(qp).
           Also the following constants are available: iTex pTex tex mv fCode
           iCount mcVar var isI isP isB avgQP qComp avgIITex avgPITex avgPPTex
           avgBPTex avgTex.

       -maxrate[:stream_specifier] integer (output,audio,video)
           Set max bitrate tolerance (in bits/s). Requires bufsize to be set.

       -minrate[:stream_specifier] integer (output,audio,video)
           Set min bitrate tolerance (in bits/s). Most useful in setting up a
           CBR encode. It is of little use elsewise.

       -bufsize[:stream_specifier] integer (output,audio,video)
           set ratecontrol buffer size (in bits)

       -rc_buf_aggressivity[:stream_specifier] float (output,video)
           currently useless

       -i_qfactor[:stream_specifier] float (output,video)
           qp factor between P and I frames

       -i_qoffset[:stream_specifier] float (output,video)
           qp offset between P and I frames

       -rc_init_cplx[:stream_specifier] float (output,video)
           initial complexity for 1-pass encoding

       -dct[:stream_specifier] integer (output,video)
           DCT algorithm

           Possible values:

           auto
               autoselect a good one (default)

           fastint
               fast integer

           int accurate integer

           mmx
           altivec
           faan
               floating point AAN DCT

       -lumi_mask[:stream_specifier] float (output,video)
           compresses bright areas stronger than medium ones
&#12;       -tcplx_mask[:stream_specifier] float (output,video)
           temporal complexity masking

       -scplx_mask[:stream_specifier] float (output,video)
           spatial complexity masking

       -p_mask[:stream_specifier] float (output,video)
           inter masking

       -dark_mask[:stream_specifier] float (output,video)
           compresses dark areas stronger than medium ones

       -idct[:stream_specifier] integer (input/output,video)
           select IDCT implementation

           Possible values:

           auto
           int
           simple
           simplemmx
           libmpeg2mmx
           mmi
           arm
           altivec
           sh4
           simplearm
           simplearmv5te
           simplearmv6
           simpleneon
           simplealpha
           h264
           vp3
           ipp
           xvidmmx
           faani
               floating point AAN IDCT

       -slice_count[:stream_specifier] integer ()
       -ec[:stream_specifier] flags (input,video)
           set error concealment strategy

           Possible values:

           guess_mvs
               iterative motion vector (MV) search (slow)

           deblock
               use strong deblock filter for damaged MBs

       -bits_per_coded_sample[:stream_specifier] integer ()
       -pred[:stream_specifier] integer (output,video)
           prediction method

           Possible values:

           left
           plane
           median
       -aspect[:stream_specifier] rational number (output,video)
           sample aspect ratio

       -debug[:stream_specifier] flags (input/output,audio,video,subtitles)
           print specific debug info

           Possible values:

           pict
               picture info
&#12;           rc  rate control

           bitstream
           mb_type
               macroblock (MB) type

           qp  per-block quantization parameter (QP)

           mv  motion vector

           dct_coeff
           skip
           startcode
           pts
           er  error recognition

           mmco
               memory management control operations (H.264)

           bugs
           vis_qp
               visualize quantization parameter (QP), lower QP are tinted
               greener

           vis_mb_type
               visualize block types

           buffers
               picture buffer allocations

           thread_ops
               threading operations

       -vismv[:stream_specifier] integer (input,video)
           visualize motion vectors (MVs)

           Possible values:

           pf  forward predicted MVs of P-frames

           bf  forward predicted MVs of B-frames

           bb  backward predicted MVs of B-frames

       -cmp[:stream_specifier] integer (output,video)
           full pel me compare function

           Possible values:

           sad sum of absolute differences, fast (default)

           sse sum of squared errors

           satd
               sum of absolute Hadamard transformed differences

           dct sum of absolute DCT transformed differences

           psnr
               sum of squared quantization errors (avoid, low quality)

           bit number of bits needed for the block

           rd  rate distortion optimal, slow

           zero
               0

           vsad
               sum of absolute vertical differences
&#12;           vsse
               sum of squared vertical differences

           nsse
               noise preserving sum of squared differences

           w53 5/3 wavelet, only used in snow

           w97 9/7 wavelet, only used in snow

           dctmax
           chroma
       -subcmp[:stream_specifier] integer (output,video)
           sub pel me compare function

           Possible values:

           sad sum of absolute differences, fast (default)

           sse sum of squared errors

           satd
               sum of absolute Hadamard transformed differences

           dct sum of absolute DCT transformed differences

           psnr
               sum of squared quantization errors (avoid, low quality)

           bit number of bits needed for the block

           rd  rate distortion optimal, slow

           zero
               0

           vsad
               sum of absolute vertical differences

           vsse
               sum of squared vertical differences

           nsse
               noise preserving sum of squared differences

           w53 5/3 wavelet, only used in snow

           w97 9/7 wavelet, only used in snow

           dctmax
           chroma
       -mbcmp[:stream_specifier] integer (output,video)
           macroblock compare function

           Possible values:

           sad sum of absolute differences, fast (default)

           sse sum of squared errors

           satd
               sum of absolute Hadamard transformed differences

           dct sum of absolute DCT transformed differences

           psnr
               sum of squared quantization errors (avoid, low quality)

           bit number of bits needed for the block

           rd  rate distortion optimal, slow
&#12;           zero
               0

           vsad
               sum of absolute vertical differences

           vsse
               sum of squared vertical differences

           nsse
               noise preserving sum of squared differences

           w53 5/3 wavelet, only used in snow

           w97 9/7 wavelet, only used in snow

           dctmax
           chroma
       -ildctcmp[:stream_specifier] integer (output,video)
           interlaced dct compare function

           Possible values:

           sad sum of absolute differences, fast (default)

           sse sum of squared errors

           satd
               sum of absolute Hadamard transformed differences

           dct sum of absolute DCT transformed differences

           psnr
               sum of squared quantization errors (avoid, low quality)

           bit number of bits needed for the block

           rd  rate distortion optimal, slow

           zero
               0

           vsad
               sum of absolute vertical differences

           vsse
               sum of squared vertical differences

           nsse
               noise preserving sum of squared differences

           w53 5/3 wavelet, only used in snow

           w97 9/7 wavelet, only used in snow

           dctmax
           chroma
       -dia_size[:stream_specifier] integer (output,video)
           diamond type &amp; size for motion estimation

       -last_pred[:stream_specifier] integer (output,video)
           amount of motion predictors from the previous frame

       -preme[:stream_specifier] integer (output,video)
           pre motion estimation

       -precmp[:stream_specifier] integer (output,video)
           pre motion estimation compare function

           Possible values:

           sad sum of absolute differences, fast (default)
&#12;           sse sum of squared errors

           satd
               sum of absolute Hadamard transformed differences

           dct sum of absolute DCT transformed differences

           psnr
               sum of squared quantization errors (avoid, low quality)

           bit number of bits needed for the block

           rd  rate distortion optimal, slow

           zero
               0

           vsad
               sum of absolute vertical differences

           vsse
               sum of squared vertical differences

           nsse
               noise preserving sum of squared differences

           w53 5/3 wavelet, only used in snow

           w97 9/7 wavelet, only used in snow

           dctmax
           chroma
       -pre_dia_size[:stream_specifier] integer (output,video)
           diamond type &amp; size for motion estimation pre-pass

       -subq[:stream_specifier] integer (output,video)
           sub pel motion estimation quality

       -dtg_active_format[:stream_specifier] integer ()
       -me_range[:stream_specifier] integer (output,video)
           limit motion vectors range (1023 for DivX player)

       -ibias[:stream_specifier] integer (output,video)
           intra quant bias

       -pbias[:stream_specifier] integer (output,video)
           inter quant bias

       -color_table_id[:stream_specifier] integer ()
       -global_quality[:stream_specifier] integer (output,audio,video)
       -coder[:stream_specifier] integer (output,video)
           Possible values:

           vlc variable length coder / huffman coder

           ac  arithmetic coder

           raw raw (no encoding)

           rle run-length coder

           deflate
               deflate-based coder

       -context[:stream_specifier] integer (output,video)
           context model

       -slice_flags[:stream_specifier] integer ()
       -xvmc_acceleration[:stream_specifier] integer ()
       -mbd[:stream_specifier] integer (output,video)
           macroblock decision algorithm (high quality mode)

           Possible values:

           simple
               use mbcmp (default)

           bits
               use fewest bits

           rd  use best rate distortion

       -stream_codec_tag[:stream_specifier] integer ()
       -sc_threshold[:stream_specifier] integer (output,video)
           scene change threshold

       -lmin[:stream_specifier] integer (output,video)
           min lagrange factor (VBR)

       -lmax[:stream_specifier] integer (output,video)
           max lagrange factor (VBR)

       -nr[:stream_specifier] integer (output,video)
           noise reduction

       -rc_init_occupancy[:stream_specifier] integer (output,video)
           number of bits which should be loaded into the rc buffer before
           decoding starts

       -inter_threshold[:stream_specifier] integer (output,video)
       -flags2[:stream_specifier] flags (input/output,audio,video)
           Possible values:

           fast
               allow non spec compliant speedup tricks

           sgop
               Deprecated, use mpegvideo private options instead

           noout
               skip bitstream encoding

           local_header
               place global headers at every keyframe instead of in extradata

           chunks
               Frame data might be split into multiple chunks

           showall
               Show all frames before the first keyframe

           skiprd
               Deprecated, use mpegvideo private options instead

       -error[:stream_specifier] integer (output,video)
       -qns[:stream_specifier] integer (output,video)
           deprecated, use mpegvideo private options instead

       -threads[:stream_specifier] integer (input/output,video)
           Possible values:

           auto
               detect a good number of threads

       -me_threshold[:stream_specifier] integer (output,video)
           motion estimaton threshold

       -mb_threshold[:stream_specifier] integer (output,video)
           macroblock threshold

       -dc[:stream_specifier] integer (output,video)
           intra_dc_precision

       -nssew[:stream_specifier] integer (output,video)
           nsse weight
&#12;       -skip_top[:stream_specifier] integer (input,video)
           number of macroblock rows at the top which are skipped

       -skip_bottom[:stream_specifier] integer (input,video)
           number of macroblock rows at the bottom which are skipped

       -profile[:stream_specifier] integer (output,audio,video)
           Possible values:

           unknown
           aac_main
           aac_low
           aac_ssr
           aac_ltp
           aac_he
           aac_he_v2
           aac_ld
           aac_eld
           dts
           dts_es
           dts_96_24
           dts_hd_hra
           dts_hd_ma
       -level[:stream_specifier] integer (output,audio,video)
           Possible values:

           unknown
       -lowres[:stream_specifier] integer (input,audio,video)
           decode at 1= 1/2, 2=1/4, 3=1/8 resolutions

       -skip_threshold[:stream_specifier] integer (output,video)
           frame skip threshold

       -skip_factor[:stream_specifier] integer (output,video)
           frame skip factor

       -skip_exp[:stream_specifier] integer (output,video)
           frame skip exponent

       -skipcmp[:stream_specifier] integer (output,video)
           frame skip compare function

           Possible values:

           sad sum of absolute differences, fast (default)

           sse sum of squared errors

           satd
               sum of absolute Hadamard transformed differences

           dct sum of absolute DCT transformed differences

           psnr
               sum of squared quantization errors (avoid, low quality)

           bit number of bits needed for the block

           rd  rate distortion optimal, slow

           zero
               0

           vsad
               sum of absolute vertical differences

           vsse
               sum of squared vertical differences

           nsse
               noise preserving sum of squared differences

           w53 5/3 wavelet, only used in snow
&#12;           w97 9/7 wavelet, only used in snow

           dctmax
           chroma
       -border_mask[:stream_specifier] float (output,video)
           increases the quantizer for macroblocks close to borders

       -mblmin[:stream_specifier] integer (output,video)
           min macroblock lagrange factor (VBR)

       -mblmax[:stream_specifier] integer (output,video)
           max macroblock lagrange factor (VBR)

       -mepc[:stream_specifier] integer (output,video)
           motion estimation bitrate penalty compensation (1.0 = 256)

       -skip_loop_filter[:stream_specifier] integer (input,video)
           Possible values:

           none
           default
           noref
           bidir
           nokey
           all
       -skip_idct[:stream_specifier] integer (input,video)
           Possible values:

           none
           default
           noref
           bidir
           nokey
           all
       -skip_frame[:stream_specifier] integer (input,video)
           Possible values:

           none
           default
           noref
           bidir
           nokey
           all
       -bidir_refine[:stream_specifier] integer (output,video)
           refine the two motion vectors used in bidirectional macroblocks

       -brd_scale[:stream_specifier] integer (output,video)
           downscales frames for dynamic B-frame decision

       -keyint_min[:stream_specifier] integer (output,video)
           minimum interval between IDR-frames

       -refs[:stream_specifier] integer (output,video)
           reference frames to consider for motion compensation

       -chromaoffset[:stream_specifier] integer (output,video)
           chroma qp offset from luma

       -trellis[:stream_specifier] integer (output,audio,video)
           rate-distortion optimal quantization

       -sc_factor[:stream_specifier] integer (output,video)
           multiplied by qscale for each frame and added to scene_change_score

       -mv0_threshold[:stream_specifier] integer (output,video)
       -b_sensitivity[:stream_specifier] integer (output,video)
           adjusts sensitivity of b_frame_strategy 1

       -compression_level[:stream_specifier] integer (output,audio,video)
       -min_prediction_order[:stream_specifier] integer (output,audio)
       -max_prediction_order[:stream_specifier] integer (output,audio)
       -timecode_frame_start[:stream_specifier] integer (output,video)
           GOP timecode frame start number, in non drop frame format
&#12;       -request_channels[:stream_specifier] integer (input,audio)
           set desired number of audio channels

       -bits_per_raw_sample[:stream_specifier] integer ()
       -channel_layout[:stream_specifier] integer (input/output,audio)
           Possible values:

       -request_channel_layout[:stream_specifier] integer (input,audio)
           Possible values:

       -rc_max_vbv_use[:stream_specifier] float (output,video)
       -rc_min_vbv_use[:stream_specifier] float (output,video)
       -ticks_per_frame[:stream_specifier] integer (input/output,audio,video)
       -color_primaries[:stream_specifier] integer (input/output,video)
       -color_trc[:stream_specifier] integer (input/output,video)
       -colorspace[:stream_specifier] integer (input/output,video)
       -color_range[:stream_specifier] integer (input/output,video)
       -chroma_sample_location[:stream_specifier] integer (input/output,video)
       -log_level_offset[:stream_specifier] integer ()
           set the log level offset

       -slices[:stream_specifier] integer (output,video)
           number of slices, used in parallelized encoding

       -thread_type[:stream_specifier] flags (input/output,video)
           select multithreading type

           Possible values:

           slice
           frame
       -audio_service_type[:stream_specifier] integer (output,audio)
           audio service type

           Possible values:

           ma  Main Audio Service

           ef  Effects

           vi  Visually Impaired

           hi  Hearing Impaired

           di  Dialogue

           co  Commentary

           em  Emergency

           vo  Voice Over

           ka  Karaoke

       -request_sample_fmt[:stream_specifier] integer (input,audio)
           sample format audio decoders should prefer

           Possible values:

           u8  8-bit unsigned integer

           s16 16-bit signed integer

           s32 32-bit signed integer

           flt 32-bit float

           dbl 64-bit double

           u8p 8-bit unsigned integer planar

           s16p
               16-bit signed integer planar
&#12;           s32p
               32-bit signed integer planar

           fltp
               32-bit float planar

           dblp
               64-bit double planar

       -pkt_timebase[:stream_specifier] rational number ()

   Format AVOptions
       -avioflags flags (input/output)
           Possible values:

           direct
               reduce buffering

       -probesize integer (input)
           set probing size

       -packetsize integer (output)
           set packet size

       -fflags flags (input/output)
           Possible values:

           ignidx
               ignore index

           genpts
               generate pts

           nofillin
               do not fill in missing values that can be exactly calculated

           noparse
               disable AVParsers, this needs nofillin too

           igndts
               ignore dts

           discardcorrupt
               discard corrupted frames

           sortdts
               try to interleave outputted packets by dts

           keepside
               dont merge side data

           latm
               enable RTP MP4A-LATM payload

           nobuffer
               reduce the latency introduced by optional buffering

       -analyzeduration integer (input)
           how many microseconds are analyzed to estimate duration

       -cryptokey hexadecimal string (input)
           decryption key

       -indexmem integer (input)
           max memory used for timestamp index (per stream)

       -rtbufsize integer (input)
           max memory used for buffering real-time frames

       -fdebug flags (input/output)
           print specific debug info

           Possible values:
&#12;           ts
       -max_delay integer (input/output)
           maximum muxing or demuxing delay in microseconds

       -fpsprobesize integer (input)
           number of frames used to probe fps

       -audio_preload integer (output)
           microseconds by which audio packets should be interleaved earlier

       -chunk_duration integer (output)
           microseconds for each chunk

       -chunk_size integer (output)
           size in bytes for each chunk

       -f_err_detect flags (input)
           set error detection flags (deprecated; use err_detect, save via
           avconv)

           Possible values:

           crccheck
               verify embedded CRCs

           bitstream
               detect bitstream specification deviations

           buffer
               detect improper bitstream length

           explode
               abort decoding on minor error detection

           careful
               consider things that violate the spec and have not been seen in
               the wild as errors

           compliant
               consider all spec non compliancies as errors

           aggressive
               consider things that a sane encoder shouldnt do as an error

       -err_detect flags (input)
           set error detection flags

           Possible values:

           crccheck
               verify embedded CRCs

           bitstream
               detect bitstream specification deviations

           buffer
               detect improper bitstream length

           explode
               abort decoding on minor error detection

           careful
               consider things that violate the spec and have not been seen in
               the wild as errors

           compliant
               consider all spec non compliancies as errors

           aggressive
               consider things that a sane encoder shouldnt do as an error

       -use_wallclock_as_timestamps integer (input)
           use wallclock as timestamps
&#12;       -avoid_negative_ts integer (output)
           avoid negative timestamps

   Main options
       -f configfile
           Use configfile instead of /etc/ffserver.conf.

       -n  Enable no-launch mode. This option disables all the Launch directives
           within the various &lt;Stream&gt; sections. Since ffserver will not launch
           any ffmpeg instances, you will have to launch them manually.

       -d  Enable debug mode. This option increases log verbosity, directs log
           messages to stdout and causes ffserver to run in the foreground
           rather than as a daemon.



                                   2014-07-25                        FFSERVER(1)

</pre></body></html>
