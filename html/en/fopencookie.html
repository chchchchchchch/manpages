<html>
<head><meta charset=utf-8/>
<title>fopencookie - opening a custom stream</title></head>
<body><pre>

FOPENCOOKIE(3)              Linux Programmer&apos;s Manual             FOPENCOOKIE(3)



NAME
       fopencookie - opening a custom stream

SYNOPSIS
       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include &lt;stdio.h&gt;

       FILE *fopencookie(void *cookie, const char *mode,
                         cookie_io_functions_t io_funcs);

DESCRIPTION
       The  fopencookie()  function  allows  the  programmer  to create a custom
       implementation for a standard I/O stream.  This implementation can  store
       the  stream&apos;s data at a location of its own choosing; for example, fopen&#8208;
       cookie() is used to implement fmemopen(3), which provides a stream inter&#8208;
       face to data that is stored in a buffer in memory.

       In order to create a custom stream the programmer must:

       *  Implement  four &quot;hook&quot; functions that are used internally by the stan&#8208;
          dard I/O library when performing I/O on the stream.

       *  Define a &quot;cookie&quot; data type, a  structure  that  provides  bookkeeping
          information  (e.g.,  where  to  store data) used by the aforementioned
          hook functions.  The standard I/O package knows nothing about the con&#8208;
          tents of this cookie (thus it is typed as void * when passed to fopen&#8208;
          cookie()), but automatically supplies the cookie as the first argument
          when calling the hook functions.

       *  Call  fopencookie()  to open a new stream and associate the cookie and
          hook functions with that stream.

       The fopencookie() function serves a purpose similar to fopen(3): it opens
       a new stream and returns a pointer to a FILE object that is used to oper&#8208;
       ate on that stream.

       The cookie argument is a pointer to the caller&apos;s cookie structure that is
       to  be  associated  with the new stream.  This pointer is supplied as the
       first argument when the standard I/O library  invokes  any  of  the  hook
       functions described below.

       The mode argument serves the same purpose as for fopen(3).  The following
       modes are supported: r, w, a, r+, w+, and a+.  See fopen(3) for details.

       The io_funcs argument is a structure that contains four  fields  pointing
       to  the programmer-defined hook functions that are used to implement this
       stream.  The structure is defined as follows

           struct cookie_io_functions_t {
               cookie_read_function_t  *read;
               cookie_write_function_t *write;
               cookie_seek_function_t  *seek;
               cookie_close_function_t *close;
           };

       The four fields are as follows:

       cookie_read_function_t *read
              This function implements read operations  for  the  stream.   When
              called, it receives three arguments:

                  ssize_t read(void *cookie, char *buf, size_t size);

              The  buf and size arguments are, respectively, a buffer into which
              input data can be placed and the size  of  that  buffer.   As  its
              function  result,  the  read  function should return the number of
              bytes copied into buf, 0 on end of file, or -1 on error.  The read
              function should update the stream offset appropriately.

              If  *read  is  a  NULL  pointer, then reads from the custom stream
              always return end of file.

       cookie_write_function_t *write
              This function implements write operations for  the  stream.   When
              called, it receives three arguments:

                  ssize_t write(void *cookie, const char *buf, size_t size);

              The  buf and size arguments are, respectively, a buffer of data to
              be output to the stream and the size of that buffer.  As its func&#8208;
              tion  result, the write function should return the number of bytes
              copied from buf, or 0 on error.  (The function must not  return  a
              negative value.)  The write function should update the stream off&#8208;
              set appropriately.

              If *write is a NULL pointer, then output to  the  stream  is  dis&#8208;
              carded.

       cookie_seek_function_t *seek
              This  function  implements  seek  operations  on the stream.  When
              called, it receives three arguments:

                  int seek(void *cookie, off64_t *offset, int whence);

              The *offset argument specifies the new file  offset  depending  on
              which of the following three values is supplied in whence:

              SEEK_SET  The  stream  offset should be set *offset bytes from the
                        start of the stream.

              SEEK_CUR  *offset should be added to the current stream offset.

              SEEK_END  The stream offset should be  set  to  the  size  of  the
                        stream plus *offset.

              Before returning, the seek function should update *offset to indi&#8208;
              cate the new stream offset.

              As its function result, the seek function should return 0 on  suc&#8208;
              cess, and -1 on error.

              If  *seek  is  a  NULL pointer, then it is not possible to perform
              seek operations on the stream.

       cookie_close_function_t *close
              This function closes the stream.  The hook function can do  things
              such as freeing buffers allocated for the stream.  When called, it
              receives one argument:

                  int close(void *cookie);

              The cookie argument is the cookie  that  the  programmer  supplied
              when calling fopencookie().

              As its function result, the close function should return 0 on suc&#8208;
              cess, and EOF on error.

              If *close is NULL, then no special action is  performed  when  the
              stream is closed.

RETURN VALUE
       On  success fopencookie() returns a pointer to the new stream.  On error,
       NULL is returned.

CONFORMING TO
       This function is a nonstandard GNU extension.

EXAMPLE
       The program below implements a custom stream whose functionality is simi&#8208;
       lar (but not identical) to that available via fmemopen(3).  It implements
       a stream whose data is stored in a memory buffer.  The program writes its
       command-line  arguments  to the stream, and then seeks through the stream
       reading two out of every five characters and  writing  them  to  standard
       output.  The following shell session demonstrates the use of the program:

           $ ./a.out &apos;hello world&apos;
           /he/
           / w/
           /d/
           Reached end of file

       Note  that  a more general version of the program below could be improved
       to more robustly handle various error situations (e.g., opening a  stream
       with  a cookie that already has an open stream; closing a stream that has
       already been closed).

   Program source

       #define _GNU_SOURCE
       #include &lt;sys/types.h&gt;
       #include &lt;stdio.h&gt;
       #include &lt;stdlib.h&gt;
       #include &lt;unistd.h&gt;
       #include &lt;string.h&gt;

       #define INIT_BUF_SIZE 4

       struct memfile_cookie {
           char   *buf;        /* Dynamically sized buffer for data */
           size_t  allocated;  /* Size of buf */
           size_t  endpos;     /* Number of characters in buf */
           off_t   offset;     /* Current file offset in buf */
       };

       ssize_t
       memfile_write(void *c, const char *buf, size_t size)
       {
           char *new_buff;
           struct memfile_cookie *cookie = c;

           /* Buffer too small? Keep doubling size until big enough */

           while (size + cookie-&gt;offset &gt; cookie-&gt;allocated) {
               new_buff = realloc(cookie-&gt;buf, cookie-&gt;allocated * 2);
               if (new_buff == NULL) {
                   return -1;
               } else {
                   cookie-&gt;allocated *= 2;
                   cookie-&gt;buf = new_buff;
               }
           }

           memcpy(cookie-&gt;buf + cookie-&gt;offset, buf, size);
&#12;           cookie-&gt;offset += size;
           if (cookie-&gt;offset &gt; cookie-&gt;endpos)
               cookie-&gt;endpos = cookie-&gt;offset;

           return size;
       }

       ssize_t
       memfile_read(void *c, char *buf, size_t size)
       {
           ssize_t xbytes;
           struct memfile_cookie *cookie = c;

           /* Fetch minimum of bytes requested and bytes available */

           xbytes = size;
           if (cookie-&gt;offset + size &gt; cookie-&gt;endpos)
               xbytes = cookie-&gt;endpos - cookie-&gt;offset;
           if (xbytes &lt; 0)     /* offset may be past endpos */
              xbytes = 0;

           memcpy(buf, cookie-&gt;buf + cookie-&gt;offset, xbytes);

           cookie-&gt;offset += xbytes;
           return xbytes;
       }

       int
       memfile_seek(void *c, off64_t *offset, int whence)
       {
           off64_t new_offset;
           struct memfile_cookie *cookie = c;

           if (whence == SEEK_SET)
               new_offset = *offset;
           else if (whence == SEEK_END)
               new_offset = cookie-&gt;endpos + *offset;
           else if (whence == SEEK_CUR)
               new_offset = cookie-&gt;offset + *offset;
           else
               return -1;

           if (new_offset &lt; 0)
               return -1;

           cookie-&gt;offset = new_offset;
           *offset = new_offset;
           return 0;
       }

       int
       memfile_close(void *c)
       {
           struct memfile_cookie *cookie = c;

           free(cookie-&gt;buf);
           cookie-&gt;allocated = 0;
           cookie-&gt;buf = NULL;

           return 0;
       }

       int
       main(int argc, char *argv[])
       {
           cookie_io_functions_t  memfile_func = {
               .read  = memfile_read,
               .write = memfile_write,
               .seek  = memfile_seek,
               .close = memfile_close
           };
           FILE *fp;
           struct memfile_cookie mycookie;
           ssize_t nread;
           long p;
           int j;
           char buf[1000];

           /* Set up the cookie before calling fopencookie() */

           mycookie.buf = malloc(INIT_BUF_SIZE);
           if (mycookie.buf == NULL) {
               perror(&quot;malloc&quot;);
               exit(EXIT_FAILURE);
           }

           mycookie.allocated = INIT_BUF_SIZE;
           mycookie.offset = 0;
           mycookie.endpos = 0;

           fp = fopencookie(&amp;mycookie,&quot;w+&quot;, memfile_func);
           if (fp == NULL) {
               perror(&quot;fopencookie&quot;);
               exit(EXIT_FAILURE);
           }

           /* Write command-line arguments to our file */

           for (j = 1; j &lt; argc; j++)
               if (fputs(argv[j], fp) == EOF) {
                   perror(&quot;fputs&quot;);
                   exit(EXIT_FAILURE);
               }

           /* Read two bytes out of every five, until EOF */

           for (p = 0; ; p += 5) {
               if (fseek(fp, p, SEEK_SET) == -1) {
                   perror(&quot;fseek&quot;);
                   exit(EXIT_FAILURE);
               }
               nread = fread(buf, 1, 2, fp);
               if (nread == -1) {
                   perror(&quot;fread&quot;);
                   exit(EXIT_FAILURE);
               }
               if (nread == 0) {
                   printf(&quot;Reached end of file\n&quot;);
                   break;
               }

               printf(&quot;/%.*s/\n&quot;, nread, buf);
           }

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       fclose(3), fmemopen(3), fopen(3), fseek(3)

COLOPHON
       This page is part of release 3.44 of  the  Linux  man-pages  project.   A
       description  of the project, and information about reporting bugs, can be
       found at http://www.kernel.org/doc/man-pages/.



Linux                              2012-04-30                     FOPENCOOKIE(3)

</pre></body></html>
