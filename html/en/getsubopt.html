<html>
<head><meta charset=utf-8/>
<title>getsubopt - parse suboption arguments from a string</title></head>
<body><pre>

GETSUBOPT(3)                Linux Programmer&apos;s Manual               GETSUBOPT(3)



NAME
       getsubopt - parse suboption arguments from a string

SYNOPSIS
       #include &lt;stdlib.h&gt;

       int getsubopt(char **optionp, char * const *tokens, char **valuep);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       getsubopt():
           _XOPEN_SOURCE &gt;= 500 || _XOPEN_SOURCE &amp;&amp; _XOPEN_SOURCE_EXTENDED
           || /* Since glibc 2.12: */ _POSIX_C_SOURCE &gt;= 200809L

DESCRIPTION
       getsubopt()  parses  the  list  of comma-separated suboptions provided in
       optionp.  (Such a suboption list is typically produced when getopt(3)  is
       used to parse a command line; see for example the -o option of mount(8).)
       Each suboption may include an associated value, which is  separated  from
       the  suboption name by an equal sign.  The following is an example of the
       kind of string that might be passed in optionp:

           ro,name=xyz

       The tokens argument is a pointer to a NULL-terminated array  of  pointers
       to  the  tokens  that  getsubopt()  will look for in optionp.  The tokens
       should be distinct, null-terminated strings containing at least one char&#8208;
       acter, with no embedded equal signs or commas.

       Each  call  to getsubopt() returns information about the next unprocessed
       suboption in optionp.  The first equal sign in a suboption  (if  any)  is
       interpreted  as a separator between the name and the value of that subop&#8208;
       tion.  The value extends to the next comma, or (for the  last  suboption)
       to  the  end of the string.  If the name of the suboption matches a known
       name from tokens, and a value string was found, getsubopt() sets  *valuep
       to the address of that string.  The first comma in optionp is overwritten
       with a null byte, so *valuep is precisely the  &quot;value  string&quot;  for  that
       suboption.

       If the suboption is recognized, but no value string was found, *valuep is
       set to NULL.

       When getsubopt() returns, optionp points to the next suboption, or to the
       null  byte (&apos;\0&apos;) at the end of the string if the last suboption was just
       processed.

RETURN VALUE
       If the first suboption in optionp is recognized, getsubopt() returns  the
       index  of  the  matching  suboption  element in tokens.  Otherwise, -1 is
       returned and *valuep is the entire name[=value] string.

       Since *optionp is changed, the first suboption before the call to getsub&#8208;
       opt()  is not (necessarily) the same as the first suboption after getsub&#8208;
       opt().

CONFORMING TO
       POSIX.1-2001.

NOTES
       Since getsubopt() overwrites any commas it finds in the string  *optionp,
       that string must be writable; it cannot be a string constant.
&#12;EXAMPLE
       The following program expects suboptions following a &quot;-o&quot; option.

       #define _XOPEN_SOURCE 500
       #include &lt;stdlib.h&gt;
       #include &lt;assert.h&gt;
       #include &lt;stdio.h&gt;

       int main(int argc, char **argv)
       {
           enum {
               RO_OPT = 0,
               RW_OPT,
               NAME_OPT
           };
           char *const token[] = {
               [RO_OPT]   = &quot;ro&quot;,
               [RW_OPT]   = &quot;rw&quot;,
               [NAME_OPT] = &quot;name&quot;,
               NULL
           };
           char *subopts;
           char *value;
           int opt;

           int readonly = 0;
           int readwrite = 0;
           char *name = NULL;
           int errfnd = 0;

           while ((opt = getopt(argc, argv, &quot;o:&quot;)) != -1) {
               switch (opt) {
               case &apos;o&apos;:
                   subopts = optarg;
                   while (*subopts != &apos;\0&apos; &amp;&amp; !errfnd) {

                   switch (getsubopt(&amp;subopts, token, &amp;value)) {
                   case RO_OPT:
                       readonly = 1;
                       break;

                   case RW_OPT:
                       readwrite = 1;
                       break;

                   case NAME_OPT:
                       if (value == NULL) {
                           fprintf(stderr, &quot;Missing value for &quot;
                                   &quot;suboption &apos;%s&apos;\n&quot;, token[NAME_OPT]);
                           errfnd = 1;
                           continue;
                       }

                       name = value;
                       break;

                   default:
                       fprintf(stderr, &quot;No match found &quot;
                               &quot;for token: /%s/\n&quot;, value);
                       errfnd = 1;
                       break;
                   }
               }
               if (readwrite &amp;&amp; readonly) {
                   fprintf(stderr, &quot;Only one of &apos;%s&apos; and &apos;%s&apos; can be &quot;
                           &quot;specified\n&quot;, token[RO_OPT], token[RW_OPT]);
                   errfnd = 1;
               }
               break;

               default:
                   errfnd = 1;
               }
           }

           if (errfnd || argc == 1) {
               fprintf(stderr, &quot;\nUsage: %s -o &lt;suboptstring&gt;\n&quot;, argv[0]);
               fprintf(stderr, &quot;suboptions are &apos;ro&apos;, &apos;rw&apos;, &quot;
                       &quot;and &apos;name=&lt;value&gt;&apos;\n&quot;);
               exit(EXIT_FAILURE);
           }

           /* Remainder of program... */

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       getopt(3)

COLOPHON
       This  page  is  part  of  release 3.44 of the Linux man-pages project.  A
       description of the project, and information about reporting bugs, can  be
       found at http://www.kernel.org/doc/man-pages/.



GNU                                2010-09-26                       GETSUBOPT(3)

</pre></body></html>
