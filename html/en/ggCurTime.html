<html>
<head><meta charset=utf-8/>
<title>ggCurTime, ggUSleep, ggUSlumber - Portable Time Routines</title></head>
<body><pre>

ggCurTime(3)                           GGI                          ggCurTime(3)



NAME
       ggCurTime, ggUSleep, ggUSlumber - Portable Time Routines

SYNOPSIS
       #include &lt;ggi/gg.h&gt;

       int ggCurTime(struct timeval *tv);

       int ggUSleep(int32_t usecs);

       void ggUSlumber(int32_t usecs);


DESCRIPTION
       ggCurTime  fills  the timeval structure pointed to by tv with the current
       time to the best precision available on the executing platform.

       ggUSleep sleeps for at least usecs microseconds, to  the  best  precision
       available  on  the executing platform, but may be woken up by a signal or
       other unspecified condition.  It is not  guaranteed  that  ggUSleep  will
       wake  up  prematurely  for  any specific reason.  It is mainly useful for
       points where the main objective is to avoid using CPU resources,  not  to
       perform accurate timing.

       ggUSlumber  does  the  same  thing  as ggUSleep, but is guaranteed not to
       return until the allotted time has elapsed.  It is  slightly  less  effi&#8208;
       cient than ggUSleep with reguard to CPU utilization.

       All times represent wall-clock (real, versus processor) times.

       The  above routines are often simple macros rather than functions, and as
       such should not be used by reference.

       The above functions are threadsafe, but are not guaranteed to be safe  to
       use  in  a thread that may be cancelled during their execution.  They are
       also not guaranteed to be safe to use in special contexts such  as  LibGG
       task handlers, signal handlers and asyncronous procedure calls.

RETURN VALUE
       ggCurTime  returns  GGI_OK on success, or a negative value on failure. On
       Windows, this function will never report a failure.  On  platforms  where
       gettimeofday(2) is used, the error code is the one returned by gettimeof&#8208;
       day.

       ggUSleep returns GGI_OK when the alloted time interval has elapsed, or  a
       non-zero value if the sleep was interrupted. On platforms where usleep(3)
       is used, the error code is the one return by usleep.

EXAMPLE
       A demonstration on how to measure a framerate.

       struct timeval start, stop, diff;
       long time_of_frame = 1;
       int framerate;

       ...

       ggCurTime(&amp;start);

       /* do something here, i.e. render and display a frame */

       ggCurTime(&amp;stop);
       diff.tv_sec = stop_tv.tv_sec - start_tv.tv_sec;
       diff.tv_usec = stop_tv.tv_usec - start_tv.tv_usec;

       if (diff.tv_usec &lt; 0) {
               diff.tv_usec += 1000000;
               diff.tv_sec--;
       }
       time_of_frame = diff.tv_sec * 1000 + diff.tv_usec / 1000;
       if (time_of_frame == 0)
               time_of_frame = 1;      /* CPU too fast? */
       printf(&quot;framerate: %i\n&quot;, 1000 / time_of_framerate);


SEE ALSO
       gettimeofday(2), usleep(3)



libgg-1.0.x                        2005-08-26                       ggCurTime(3)

</pre></body></html>
