<html>
<head><meta charset=utf-8/>
<title>git-for-each-ref - Output information on each ref</title></head>
<body><pre>

GIT-FOR-EACH-REF(1)                Git Manual                GIT-FOR-EACH-REF(1)



NAME
       git-for-each-ref - Output information on each ref

SYNOPSIS
       git for-each-ref [--count=&lt;count&gt;] [--shell|--perl|--python|--tcl]
                          [(--sort=&lt;key&gt;)...] [--format=&lt;format&gt;] [&lt;pattern&gt;...]


DESCRIPTION
       Iterate over all refs that match &lt;pattern&gt; and show them according to the
       given &lt;format&gt;, after sorting them according to the given set of &lt;key&gt;.
       If &lt;count&gt; is given, stop after showing that many refs. The interpolated
       values in &lt;format&gt; can optionally be quoted as string literals in the
       specified host language allowing their direct evaluation in that
       language.

OPTIONS
       &lt;count&gt;
           By default the command shows all refs that match &lt;pattern&gt;. This
           option makes it stop after showing that many refs.

       &lt;key&gt;
           A field name to sort on. Prefix - to sort in descending order of the
           value. When unspecified, refname is used. You may use the
           --sort=&lt;key&gt; option multiple times, in which case the last key
           becomes the primary key.

       &lt;format&gt;
           A string that interpolates %(fieldname) from the object pointed at by
           a ref being shown. If fieldname is prefixed with an asterisk (*) and
           the ref points at a tag object, the value for the field in the object
           tag refers is used. When unspecified, defaults to %(objectname) SPC
           %(objecttype) TAB %(refname). It also interpolates %% to %, and %xx
           where xx are hex digits interpolates to character with hex code xx;
           for example %00 interpolates to \0 (NUL), %09 to \t (TAB) and %0a to
           \n (LF).

       &lt;pattern&gt;...
           If one or more patterns are given, only refs are shown that match
           against at least one pattern, either using fnmatch(3) or literally,
           in the latter case matching completely or from the beginning up to a
           slash.

       --shell, --perl, --python, --tcl
           If given, strings that substitute %(fieldname) placeholders are
           quoted as string literals suitable for the specified host language.
           This is meant to produce a scriptlet that can directly be `eval`ed.

FIELD NAMES
       Various values from structured fields in referenced objects can be used
       to interpolate into the resulting output, or as sort keys.

       For all objects, the following names can be used:

       refname
           The name of the ref (the part after $GIT_DIR/). For a non-ambiguous
           short name of the ref append :short. The option
           core.warnAmbiguousRefs is used to select the strict abbreviation
           mode.

       objecttype
           The type of the object (blob, tree, commit, tag).

       objectsize
           The size of the object (the same as git cat-file -s reports).

       objectname
           The object name (aka SHA-1). For a non-ambiguous abbreviation of the
           object name append :short.

       upstream
           The name of a local ref which can be considered &#8220;upstream&#8221; from the
           displayed ref. Respects :short in the same way as refname above.

       In addition to the above, for commit and tag objects, the header field
       names (tree, parent, object, type, and tag) can be used to specify the
       value in the header field.

       Fields that have name-email-date tuple as its value (author, committer,
       and tagger) can be suffixed with name, email, and date to extract the
       named component.

       The complete message in a commit and tag object is contents. Its first
       line is contents:subject, the remaining lines are contents:body and the
       optional GPG signature is contents:signature.

       For sorting purposes, fields with numeric values sort in numeric order
       (objectsize, authordate, committerdate, taggerdate). All other fields are
       used to sort in their byte-value order.

       In any case, a field name that refers to a field inapplicable to the
       object referred by the ref does not cause an error. It returns an empty
       string instead.

       As a special case for the date-type fields, you may specify a format for
       the date by adding one of :default, :relative, :short, :local, :iso8601
       or :rfc2822 to the end of the fieldname; e.g. %(taggerdate:relative).

EXAMPLES
       An example directly producing formatted text. Show the most recent 3
       tagged commits:

           #!/bin/sh

           git for-each-ref --count=3 --sort=&apos;-*authordate&apos; \
           --format=&apos;From: %(*authorname) %(*authoremail)
           Subject: %(*subject)
           Date: %(*authordate)
           Ref: %(*refname)

           %(*body)
           &apos; &apos;refs/tags&apos;


       A simple example showing the use of shell eval on the output,
       demonstrating the use of --shell. List the prefixes of all heads:

           #!/bin/sh

           git for-each-ref --shell --format=&quot;ref=%(refname)&quot; refs/heads | \
           while read entry
           do
                   eval &quot;$entry&quot;
                   echo `dirname $ref`
           done


       A bit more elaborate report on tags, demonstrating that the format may be
       an entire script:

           #!/bin/sh

           fmt=&apos;
                   r=%(refname)
                   t=%(*objecttype)
                   T=${r#refs/tags/}

                   o=%(*objectname)
                   n=%(*authorname)
                   e=%(*authoremail)
                   s=%(*subject)
                   d=%(*authordate)
                   b=%(*body)

                   kind=Tag
                   if test &quot;z$t&quot; = z
                   then
                           # could be a lightweight tag
                           t=%(objecttype)
                           kind=&quot;Lightweight tag&quot;
                           o=%(objectname)
                           n=%(authorname)
                           e=%(authoremail)
                           s=%(subject)
                           d=%(authordate)
                           b=%(body)
                   fi
                   echo &quot;$kind $T points at a $t object $o&quot;
                   if test &quot;z$t&quot; = zcommit
                   then
                           echo &quot;The commit was authored by $n $e
           at $d, and titled

               $s

           Its message reads as:
           &quot;
                           echo &quot;$b&quot; | sed -e &quot;s/^/    /&quot;
                           echo
                   fi
           &apos;

           eval=`git for-each-ref --shell --format=&quot;$fmt&quot; \
                   --sort=&apos;*objecttype&apos; \
                   --sort=-taggerdate \
                   refs/tags`
           eval &quot;$eval&quot;


AUTHOR
       Written by Junio C Hamano &lt;gitster@pobox.com[1]&gt;.

DOCUMENTATION
       Documentation by Junio C Hamano and the git-list
       &lt;git@vger.kernel.org[2]&gt;.

GIT
       Part of the git(1) suite

NOTES
        1. gitster@pobox.com
           mailto:gitster@pobox.com

        2. git@vger.kernel.org
           mailto:git@vger.kernel.org



Git 1.7.10.4                       11/24/2012                GIT-FOR-EACH-REF(1)

</pre></body></html>
