<html>
<head><meta charset=utf-8/>
<title>init_module - load a kernel module</title></head>
<body><pre>

INIT_MODULE(2)              Linux Programmer&apos;s Manual             INIT_MODULE(2)



NAME
       init_module - load a kernel module

SYNOPSIS
       int init_module(void *module_image, unsigned long len,
                       const char *param_values);

       Note: There is no glibc wrapper for this system call; see NOTES.

DESCRIPTION
       init_module()  loads  an ELF image into kernel space, performs any neces&#8208;
       sary symbol relocations, initializes module parameters to values provided
       by  the  caller,  and  then runs the module&apos;s init function.  This system
       call requires privilege.

       The module_image argument points to a buffer containing the binary  image
       to  be  loaded;  len specifies the size of that buffer.  The module image
       should be a valid ELF image, built for the running kernel.

       The param_values argument is a string containing space-delimited specifi&#8208;
       cations  of  the  values for module parameters (defined inside the module
       using module_param() and module_param_array()).  The kernel  parses  this
       string  and  initializes the specified parameters.  Each of the parameter
       specifications has the form:

               name[=value[,value...]]

       The parameter name is one of those defined within the module  using  mod&#8208;
       ule_param()   (see   the  Linux  kernel  source  file  include/linux/mod&#8208;
       uleparam.h).  The parameter value is optional in the  case  of  bool  and
       invbool  parameters.   Values  for  array  parameters  are specified as a
       comma-separated list.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned and errno is  set
       appropriately.

ERRORS
       EBUSY  Timeout while trying to resolve a symbol reference by this module.

       EEXIST A module with this name is already loaded.

       EFAULT An  address  argument  referred  to a location that is outside the
              process&apos;s accessible address space.

       EINVAL param_values is invalid, or some part of the  ELF  image  in  mod&#8208;
              ule_image contains inconsistencies.

       ENOEXEC
              The  binary image supplied in module_image is not an ELF image, or
              is an ELF image that is invalid or for a different architecture.

       EPERM  The caller was not privileged (did  not  have  the  CAP_SYS_MODULE
              capability),  or  module  loading  is disabled (see /proc/sys/ker&#8208;
              nel/modules_disabled in proc(5)).

       In addition to the above errors, if the module&apos;s init  function  is  exe&#8208;
       cuted  and returns an error, then init_module() fails and errno is set to
       the value returned by the init function.

CONFORMING TO
       init_module() is Linux-specific.
&#12;NOTES
       Glibc does not provide a wrapper for this  system  call;  call  it  using
       syscall(2).

       Information  about currently loaded modules can be found in /proc/modules
       and in the file trees under the per-module subdirectories under /sys/mod&#8208;
       ule.

       See  the  Linux kernel source file include/linux/module.h for some useful
       background information.

   Linux 2.4 and earlier
       In Linux 2.4 and earlier, this system call was rather different:

           #include &lt;linux/module.h&gt;

           int init_module(const char *name, struct module *image);

       (User-space applications can detect which  version  of  init_module()  is
       available by calling query_module(); the latter call fails with the error
       ENOSYS on Linux 2.6 and later.)

       The older version of the system call loads  the  relocated  module  image
       pointed  to  by  image into kernel space and runs the module&apos;s init func&#8208;
       tion.  The caller is responsible for providing the relocated image (since
       Linux 2.6, the init_module() system call does the relocation).

       The  module  image begins with a module structure and is followed by code
       and data as appropriate.   Since  Linux  2.2,  the  module  structure  is
       defined as follows:

           struct module {
               unsigned long         size_of_struct;
               struct module        *next;
               const char           *name;
               unsigned long         size;
               long                  usecount;
               unsigned long         flags;
               unsigned int          nsyms;
               unsigned int          ndeps;
               struct module_symbol *syms;
               struct module_ref    *deps;
               struct module_ref    *refs;
               int                 (*init)(void);
               void                (*cleanup)(void);
               const struct exception_table_entry *ex_table_start;
               const struct exception_table_entry *ex_table_end;
           #ifdef __alpha__
               unsigned long gp;
           #endif
           };

       All  of  the  pointer  fields,  with  the exception of next and refs, are
       expected to point within the module body and be initialized as  appropri&#8208;
       ate for kernel space, that is, relocated with the rest of the module.

SEE ALSO
       create_module(2),   delete_module(2),   query_module(2),  lsmod(8),  mod&#8208;
       probe(8)

COLOPHON
       This page is part of release 3.44 of  the  Linux  man-pages  project.   A
       description  of the project, and information about reporting bugs, can be
       found at http://www.kernel.org/doc/man-pages/.



Linux                              2012-10-18                     INIT_MODULE(2)

</pre></body></html>
