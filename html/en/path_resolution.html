<html>
<head><meta charset=utf-8/>
<title>path_resolution - how a pathname is resolved to a file</title></head>
<body><pre>

PATH_RESOLUTION(7)          Linux Programmer&apos;s Manual         PATH_RESOLUTION(7)



NAME
       path_resolution - how a pathname is resolved to a file

DESCRIPTION
       Some  UNIX/Linux system calls have as parameter one or more filenames.  A
       filename (or pathname) is resolved as follows.

   Step 1: Start of the resolution process
       If the pathname starts with the &apos;/&apos; character, the starting lookup direc&#8208;
       tory  is  the root directory of the calling process.  (A process inherits
       its root directory from its parent.  Usually this will be the root direc&#8208;
       tory of the file hierarchy.  A process may get a different root directory
       by use of the chroot(2) system call.  A process may get an entirely  pri&#8208;
       vate mount namespace in case it&#8212;or one of its ancestors&#8212;was started by an
       invocation of the clone(2) system call  that  had  the  CLONE_NEWNS  flag
       set.)  This handles the &apos;/&apos; part of the pathname.

       If  the  pathname  does  not  start  with the &apos;/&apos; character, the starting
       lookup directory of the resolution process is the current working  direc&#8208;
       tory of the process.  (This is also inherited from the parent.  It can be
       changed by use of the chdir(2) system call.)

       Pathnames starting with a &apos;/&apos; character are  called  absolute  pathnames.
       Pathnames not starting with a &apos;/&apos; are called relative pathnames.

   Step 2: Walk along the path
       Set  the current lookup directory to the starting lookup directory.  Now,
       for each nonfinal component of the pathname, where a component is a  sub&#8208;
       string  delimited  by  &apos;/&apos; characters, this component is looked up in the
       current lookup directory.

       If the process does not have search  permission  on  the  current  lookup
       directory, an EACCES error is returned (&quot;Permission denied&quot;).

       If the component is not found, an ENOENT error is returned (&quot;No such file
       or directory&quot;).

       If the component is found, but is neither  a  directory  nor  a  symbolic
       link, an ENOTDIR error is returned (&quot;Not a directory&quot;).

       If  the  component is found and is a directory, we set the current lookup
       directory to that directory, and go to the next component.

       If the component is found and is a  symbolic  link  (symlink),  we  first
       resolve this symbolic link (with the current lookup directory as starting
       lookup directory).  Upon error, that error is returned.  If the result is
       not  a directory, an ENOTDIR error is returned.  If the resolution of the
       symlink is successful and returns a directory, we set the current  lookup
       directory to that directory, and go to the next component.  Note that the
       resolution process here involves recursion.  In order to protect the ker&#8208;
       nel  against  stack  overflow, and also to protect against denial of ser&#8208;
       vice, there are limits on the maximum recursion depth, and on the maximum
       number  of  symbolic links followed.  An ELOOP error is returned when the
       maximum is exceeded (&quot;Too many levels of symbolic links&quot;).

   Step 3: Find the final entry
       The lookup of the final component of the pathname goes just like that  of
       all other components, as described in the previous step, with two differ&#8208;
       ences: (i) the final component need not be a directory (at least  as  far
       as  the  path  resolution process is concerned&#8212;it may have to be a direc&#8208;
       tory, or a nondirectory, because of the requirements of the specific sys&#8208;
       tem  call),  and  (ii) it is not necessarily an error if the component is
       not found&#8212;maybe we are just creating it.  The details on the treatment of
       the  final entry are described in the manual pages of the specific system
       calls.

   . and ..
       By convention, every directory has the entries &quot;.&quot; and &quot;..&quot;, which  refer
       to the directory itself and to its parent directory, respectively.

       The  path  resolution  process  will assume that these entries have their
       conventional meanings, regardless of whether they are actually present in
       the physical file system.

       One cannot walk down past the root: &quot;/..&quot; is the same as &quot;/&quot;.

   Mount points
       After  a &quot;mount dev path&quot; command, the pathname &quot;path&quot; refers to the root
       of the file system hierarchy on the device &quot;dev&quot;, and no longer to  what&#8208;
       ever it referred to earlier.

       One can walk out of a mounted file system: &quot;path/..&quot; refers to the parent
       directory of &quot;path&quot;, outside of the file system hierarchy on &quot;dev&quot;.

   Trailing slashes
       If a pathname ends in a &apos;/&apos;, that forces resolution of the preceding com&#8208;
       ponent  as in Step 2: it has to exist and resolve to a directory.  Other&#8208;
       wise a trailing &apos;/&apos; is ignored.  (Or, equivalently,  a  pathname  with  a
       trailing  &apos;/&apos;  is equivalent to the pathname obtained by appending &apos;.&apos; to
       it.)

   Final symlink
       If the last component of a pathname is a symbolic link, then  it  depends
       on the system call whether the file referred to will be the symbolic link
       or the result of path resolution on its contents.  For example, the  sys&#8208;
       tem  call lstat(2) will operate on the symlink, while stat(2) operates on
       the file pointed to by the symlink.

   Length limit
       There is a maximum length for pathnames.  If the pathname (or some inter&#8208;
       mediate pathname obtained while resolving symbolic links) is too long, an
       ENAMETOOLONG error is returned (&quot;Filename too long&quot;).

   Empty pathname
       In the original UNIX, the empty pathname referred to the  current  direc&#8208;
       tory.  Nowadays POSIX decrees that an empty pathname must not be resolved
       successfully.  Linux returns ENOENT in this case.

   Permissions
       The permission bits of a file consist of three groups of three bits,  cf.
       chmod(1)  and  stat(2).  The first group of three is used when the effec&#8208;
       tive user ID of the calling process equals the owner ID of the file.  The
       second group of three is used when the group ID of the file either equals
       the effective group ID of the calling process, or is one of  the  supple&#8208;
       mentary  group IDs of the calling process (as set by setgroups(2)).  When
       neither holds, the third group is used.

       Of the three bits used, the first bit  determines  read  permission,  the
       second write permission, and the last execute permission in case of ordi&#8208;
       nary files, or search permission in case of directories.

       Linux uses the fsuid instead of  the  effective  user  ID  in  permission
       checks.   Ordinarily  the fsuid will equal the effective user ID, but the
       fsuid can be changed by the system call setfsuid(2).

       (Here &quot;fsuid&quot; stands for something like &quot;file system user ID&quot;.  The  con&#8208;
       cept  was required for the implementation of a user space NFS server at a
       time when processes could send a signal to a process with the same effec&#8208;
       tive user ID.  It is obsolete now.  Nobody should use setfsuid(2).)

       Similarly,  Linux  uses the fsgid (&quot;file system group ID&quot;) instead of the
       effective group ID.  See setfsgid(2).

   Bypassing permission checks: superuser and capabilities
       On a traditional UNIX system, the superuser (root, user ID 0) is all-pow&#8208;
       erful, and bypasses all permissions restrictions when accessing files.

       On  Linux,  superuser privileges are divided into capabilities (see capa&#8208;
       bilities(7)).  Two capabilities are relevant for file permissions checks:
       CAP_DAC_OVERRIDE and CAP_DAC_READ_SEARCH.  (A process has these capabili&#8208;
       ties if its fsuid is 0.)

       The CAP_DAC_OVERRIDE capability overrides all  permission  checking,  but
       only grants execute permission when at least one of the file&apos;s three exe&#8208;
       cute permission bits is set.

       The CAP_DAC_READ_SEARCH capability grants read and search  permission  on
       directories, and read permission on ordinary files.

SEE ALSO
       readlink(2), capabilities(7), credentials(7), symlink(7)

COLOPHON
       This  page  is  part  of  release 3.44 of the Linux man-pages project.  A
       description of the project, and information about reporting bugs, can  be
       found at http://www.kernel.org/doc/man-pages/.



Linux                              2009-12-05                 PATH_RESOLUTION(7)

</pre></body></html>
