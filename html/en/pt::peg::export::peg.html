<html>
<head><meta charset=utf-8/>
<title>pt::peg::export::peg - PEG Export Plugin. Write PEG format</title></head>
<body><pre>

pt::peg::export::peg(3tcl)        Parser Tools        pt::peg::export::peg(3tcl)



________________________________________________________________________________

NAME
       pt::peg::export::peg - PEG Export Plugin. Write PEG format

SYNOPSIS
       package require Tcl  8.5

       package require pt::peg::export::peg  ?1?

       package require pt::peg::to::peg

       export serial configuration

_________________________________________________________________

DESCRIPTION
       Are  you  lost  ?   Do you have trouble understanding this document ?  In
       that case please read the overview provided by the Introduction to Parser
       Tools.  This  document  is the entrypoint to the whole system the current
       package is a part of.

       This package implements the parsing expression grammar export plugin  for
       the generation of PEG markup.

       It resides in the Export section of the Core Layer of Parser Tools and is
       intended to be used  by  pt::peg::export,  the  export  manager,  sitting
       between  it  and the corresponding core conversion functionality provided
       by pt::peg::to::peg.

       IMAGE: arch_core_eplugins

       While the direct use of this package with a regular interpreter is possi&#8208;
       ble, this is strongly disrecommended and requires a number of contortions
       to provide the expected environment.  The proper way to  use  this  func&#8208;
       tionality depends on the situation:

       [1]    In an untrusted environment the proper access is through the pack&#8208;
              age pt::peg::export and the export manager objects it provides.

       [2]    In  a  trusted  environment  however  simply   use   the   package
              pt::peg::to::peg  and  access  the  core  conversion functionality
              directly.

API
       The API provided by this package satisfies the specification of the Plug&#8208;
       in API found in the Parser Tools Export API specification.

       export serial configuration
              This  command  takes  the  canonical  serialization  of  a parsing
              expression grammar, as specified in section PEG serialization for&#8208;
              mat, and contained in serial, the configuration, a dictionary, and
              generates PEG markup encoding the grammar.  The created string  is
              then returned as the result of the command.

CONFIGURATION
       The  PEG  export  plugin recognizes the following configuration variables
       and changes its behaviour as they specify.

       string template
              If this configuration variable is set it is assumed to  contain  a
              string  into  which to put the generated text and other configura&#8208;
              tion data. The various locations are expected to be specified with
              the following placeholders:

              @user@ To be replaced with the value of the configuration variable
                     user.

              @format@
                     To be replaced with the the constant PEG.

              @file@ To be replaced with the value of the configuration variable
                     file.

              @name@ To be replaced with the value of the configuration variable
                     name.

              @code@ To be replaced with the generated text.

       If this configuration variable is not set,  or  empty,  then  the  plugin
       falls back to a standard template, which is defined as &quot;@code@&quot;.

       Note  that  this  plugin  may ignore the standard configuration variables
       user, format, file, and their values, depending on the chosen template.

       The content of the standard configuration variable name, if set, is  used
       as  name of the grammar in the output. Otherwise the plugin falls back to
       the default name a_pe_grammar.

PEG SPECIFICATION LANGUAGE
       peg, a language for the specification of parsing expression  grammars  is
       meant  to  be  human readable, and writable as well, yet strict enough to
       allow its processing by machine.  Like  any  computer  language.  It  was
       defined  to  make  writing the specification of a grammar easy, something
       the other formats found in the Parser Tools do not lend themselves too.

       It is formally specified by the grammar shown below, written  in  itself.
       For  a tutorial / introduction to the language please go and read the PEG
       Language Tutorial.

              PEG pe-grammar-for-peg (Grammar)

                # --------------------------------------------------------------------
                      # Syntactical constructs

                      Grammar         &lt;- WHITESPACE Header Definition* Final EOF ;

                      Header          &lt;- PEG Identifier StartExpr ;
                      Definition      &lt;- Attribute? Identifier IS Expression SEMICOLON ;
                      Attribute       &lt;- (VOID / LEAF) COLON ;
                      Expression      &lt;- Sequence (SLASH Sequence)* ;
                      Sequence        &lt;- Prefix+ ;
                      Prefix          &lt;- (AND / NOT)? Suffix ;
                      Suffix          &lt;- Primary (QUESTION / STAR / PLUS)? ;
                      Primary         &lt;- ALNUM / ALPHA / ASCII / CONTROL / DDIGIT / DIGIT
                                      /  GRAPH / LOWER / PRINTABLE / PUNCT / SPACE / UPPER
                                      /  WORDCHAR / XDIGIT
                                      / Identifier
                                      /  OPEN Expression CLOSE
                                      /  Literal
                                      /  Class
                                      /  DOT
                                      ;
                      Literal         &lt;- APOSTROPH  (!APOSTROPH  Char)* APOSTROPH  WHITESPACE
                                      /  DAPOSTROPH (!DAPOSTROPH Char)* DAPOSTROPH WHITESPACE ;
                      Class           &lt;- OPENB (!CLOSEB Range)* CLOSEB WHITESPACE ;
                      Range           &lt;- Char TO Char / Char ;
&#12;                      StartExpr       &lt;- OPEN Expression CLOSE ;
              void:   Final           &lt;- END SEMICOLON WHITESPACE ;

                      # --------------------------------------------------------------------
                      # Lexing constructs

                      Identifier      &lt;- Ident WHITESPACE ;
              leaf:   Ident           &lt;- (&apos;_&apos; / &apos;:&apos; / &lt;alpha&gt;) (&apos;_&apos; / &apos;:&apos; / &lt;alnum&gt;)* ;
                      Char            &lt;- CharSpecial / CharOctalFull / CharOctalPart
                                      /  CharUnicode / CharUnescaped
                                      ;

              leaf:   CharSpecial     &lt;- &quot;\\&quot; [nrt&apos;&quot;\[\]\\] ;
              leaf:   CharOctalFull   &lt;- &quot;\\&quot; [0-2][0-7][0-7] ;
              leaf:   CharOctalPart   &lt;- &quot;\\&quot; [0-7][0-7]? ;
              leaf:   CharUnicode     &lt;- &quot;\\&quot; &apos;u&apos; HexDigit (HexDigit (HexDigit HexDigit?)?)? ;
              leaf:   CharUnescaped   &lt;- !&quot;\\&quot; . ;

              void:   HexDigit        &lt;- [0-9a-fA-F] ;

              void:   TO              &lt;- &apos;-&apos;           ;
              void:   OPENB           &lt;- &quot;[&quot;           ;
              void:   CLOSEB          &lt;- &quot;]&quot;           ;
              void:   APOSTROPH       &lt;- &quot;&apos;&quot;           ;
              void:   DAPOSTROPH      &lt;- &apos;&quot;&apos;           ;
              void:   PEG             &lt;- &quot;PEG&quot;   WHITESPACE ;
              void:   IS              &lt;- &quot;&lt;-&quot;    WHITESPACE ;
              leaf:   VOID            &lt;- &quot;void&quot;  WHITESPACE ; # Implies that definition has no semantic value.
              leaf:   LEAF            &lt;- &quot;leaf&quot;  WHITESPACE ; # Implies that definition has no terminals.
              void:   END             &lt;- &quot;END&quot;   WHITESPACE ;
              void:   SEMICOLON       &lt;- &quot;;&quot;     WHITESPACE ;
              void:   COLON           &lt;- &quot;:&quot;     WHITESPACE ;
              void:   SLASH           &lt;- &quot;/&quot;     WHITESPACE ;
              leaf:   AND             &lt;- &quot;&amp;&quot;     WHITESPACE ;
              leaf:   NOT             &lt;- &quot;!&quot;     WHITESPACE ;
              leaf:   QUESTION        &lt;- &quot;?&quot;     WHITESPACE ;
              leaf:   STAR            &lt;- &quot;*&quot;     WHITESPACE ;
              leaf:   PLUS            &lt;- &quot;+&quot;     WHITESPACE ;
              void:   OPEN            &lt;- &quot;(&quot;     WHITESPACE ;
              void:   CLOSE           &lt;- &quot;)&quot;     WHITESPACE ;
              leaf:   DOT             &lt;- &quot;.&quot;     WHITESPACE ;

              leaf:   ALNUM           &lt;- &quot;&lt;alnum&gt;&quot;    WHITESPACE ;
              leaf:   ALPHA           &lt;- &quot;&lt;alpha&gt;&quot;    WHITESPACE ;
              leaf:   ASCII           &lt;- &quot;&lt;ascii&gt;&quot;    WHITESPACE ;
              leaf:   CONTROL         &lt;- &quot;&lt;control&gt;&quot;  WHITESPACE ;
              leaf:   DDIGIT          &lt;- &quot;&lt;ddigit&gt;&quot;   WHITESPACE ;
              leaf:   DIGIT           &lt;- &quot;&lt;digit&gt;&quot;    WHITESPACE ;
              leaf:   GRAPH           &lt;- &quot;&lt;graph&gt;&quot;    WHITESPACE ;
              leaf:   LOWER           &lt;- &quot;&lt;lower&gt;&quot;    WHITESPACE ;
              leaf:   PRINTABLE       &lt;- &quot;&lt;print&gt;&quot;    WHITESPACE ;
              leaf:   PUNCT           &lt;- &quot;&lt;punct&gt;&quot;    WHITESPACE ;
              leaf:   SPACE           &lt;- &quot;&lt;space&gt;&quot;    WHITESPACE ;
              leaf:   UPPER           &lt;- &quot;&lt;upper&gt;&quot;    WHITESPACE ;
              leaf:   WORDCHAR        &lt;- &quot;&lt;wordchar&gt;&quot; WHITESPACE ;
              leaf:   XDIGIT          &lt;- &quot;&lt;xdigit&gt;&quot;   WHITESPACE ;

              void:   WHITESPACE      &lt;- (&quot; &quot; / &quot;\t&quot; / EOL / COMMENT)* ;
              void:   COMMENT         &lt;- &apos;#&apos; (!EOL .)* EOL ;
              void:   EOL             &lt;- &quot;\n\r&quot; / &quot;\n&quot; / &quot;\r&quot; ;
              void:   EOF             &lt;- !. ;

                      # --------------------------------------------------------------------
              END;
&#12;   EXAMPLE
       Our example specifies the grammar for a basic 4-operation calculator.

              PEG calculator (Expression)
                  Digit      &lt;- &apos;0&apos;/&apos;1&apos;/&apos;2&apos;/&apos;3&apos;/&apos;4&apos;/&apos;5&apos;/&apos;6&apos;/&apos;7&apos;/&apos;8&apos;/&apos;9&apos;       ;
                  Sign       &lt;- &apos;-&apos; / &apos;+&apos;                                     ;
                  Number     &lt;- Sign? Digit+                                  ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- &apos;*&apos; / &apos;/&apos;                                     ;
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- &apos;+&apos;/&apos;-&apos;                                       ;
                  Factor     &lt;- &apos;(&apos; Expression &apos;)&apos; / Number                   ;
              END;


       Using higher-level features of the notation, i.e. the  character  classes
       (predefined and custom), this example can be rewritten as

              PEG calculator (Expression)
                  Sign       &lt;- [-+] ;
                  Number     &lt;- Sign? &lt;ddigit&gt;+;
                  Expression &lt;- &apos;(&apos; Expression &apos;)&apos; / (Factor (MulOp Factor)*);
                  MulOp      &lt;- [*/];
                  Factor     &lt;- Term (AddOp Term)*;
                  AddOp      &lt;- [-+];
                  Term       &lt;- Number;
              END;


PEG SERIALIZATION FORMAT
       Here  we specify the format used by the Parser Tools to serialize Parsing
       Expression Grammars as immutable values for transport, comparison, etc.

       We distinguish between regular and canonical serializations.  While a PEG
       may  have  more  than  one regular serialization only exactly one of them
       will be canonical.

       regular serialization

              [1]    The serialization of any PEG is a nested Tcl dictionary.

              [2]    This dictionary holds a single key,  pt::grammar::peg,  and
                     its value. This value holds the contents of the grammar.

              [3]    The  contents  of  the grammar are a Tcl dictionary holding
                     the set of nonterminal symbols and the starting expression.
                     The relevant keys and their values are

                     rules  The  value  is  a  Tcl dictionary whose keys are the
                            names of the nonterminal symbols known to the  gram&#8208;
                            mar.

                            [1]    Each nonterminal symbol may occur only once.

                            [2]    The  empty  string is not a legal nonterminal
                                   symbol.

                            [3]    The value for each symbol is a Tcl dictionary
                                   itself. The relevant keys and their values in
                                   this dictionary are

                                   is     The value is the serialization of  the
                                          parsing expression describing the sym&#8208;
                                          bols sentennial structure,  as  speci&#8208;
                                          fied  in  the section PE serialization
                                          format.

                                   mode   The value can be one of  three  values
                                          specifying  how a parser should handle
                                          the semantic  value  produced  by  the
                                          symbol.

                                          value  The  semantic value of the non&#8208;
                                                 terminal symbol is an  abstract
                                                 syntax  tree  consisting  of  a
                                                 single node node for  the  non&#8208;
                                                 terminal  itself, which has the
                                                 ASTs of the symbol&apos;s right hand
                                                 side as its children.

                                          leaf   The  semantic value of the non&#8208;
                                                 terminal symbol is an  abstract
                                                 syntax  tree  consisting  of  a
                                                 single node node for  the  non&#8208;
                                                 terminal, without any children.
                                                 Any ASTs generated by the  sym&#8208;
                                                 bol&apos;s  right hand side are dis&#8208;
                                                 carded.

                                          void   The nonterminal has no semantic
                                                 value.  Any  ASTs  generated by
                                                 the symbol&apos;s  right  hand  side
                                                 are discarded (as well).

                     start  The  value is the serialization of the start parsing
                            expression of the grammar, as specified in the  sec&#8208;
                            tion PE serialization format.

              [4]    The  terminal  symbols of the grammar are specified implic&#8208;
                     itly as the set of all terminal symbols used in  the  start
                     expression and on the RHS of the grammar rules.

       canonical serialization
              The  canonical serialization of a grammar has the format as speci&#8208;
              fied in the previous item, and  then  additionally  satisfies  the
              constraints  below,  which  make  it unique among all the possible
              serializations of this grammar.

              [1]    The keys found in  all  the  nested  Tcl  dictionaries  are
                     sorted in ascending dictionary order, as generated by Tcl&apos;s
                     builtin command lsort -increasing -dict.

              [2]    The string representation of the  value  is  the  canonical
                     representation  of  a Tcl dictionary. I.e. it does not con&#8208;
                     tain superfluous whitespace.

   EXAMPLE
       Assuming the following PEG for simple mathematical expressions

              PEG calculator (Expression)
                  Digit      &lt;- &apos;0&apos;/&apos;1&apos;/&apos;2&apos;/&apos;3&apos;/&apos;4&apos;/&apos;5&apos;/&apos;6&apos;/&apos;7&apos;/&apos;8&apos;/&apos;9&apos;       ;
                  Sign       &lt;- &apos;-&apos; / &apos;+&apos;                                     ;
                  Number     &lt;- Sign? Digit+                                  ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- &apos;*&apos; / &apos;/&apos;                                     ;
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- &apos;+&apos;/&apos;-&apos;                                       ;
                  Factor     &lt;- &apos;(&apos; Expression &apos;)&apos; / Number                   ;
              END;


       then its canonical serialization (except for whitespace) is

              pt::grammar::peg {
                  rules {
                      AddOp      {is {/ {t -} {t +}}                                                                mode value}
                      Digit      {is {/ {t 0} {t 1} {t 2} {t 3} {t 4} {t 5} {t 6} {t 7} {t 8} {t 9}}                mode value}
                      Expression {is {x {n Term} {* {x {n AddOp} {n Term}}}}                                        mode value}
                      Factor     {is {/ {x {t (} {n Expression} {t )}} {n Number}}                                  mode value}
                      MulOp      {is {/ {t *} {t /}}                                                                mode value}
                      Number     {is {x {? {n Sign}} {+ {n Digit}}}                                                 mode value}
                      Sign       {is {/ {t -} {t +}}                                                                mode value}
                      Term       {is {x {n Factor} {* {x {n MulOp} {n Factor}}}}                                    mode value}
                  }
                  start {n Expression}
              }


PE SERIALIZATION FORMAT
       Here we specify the format used by the Parser Tools to serialize  Parsing
       Expressions as immutable values for transport, comparison, etc.

       We  distinguish  between  regular  and canonical serializations.  While a
       parsing expression may have more  than  one  regular  serialization  only
       exactly one of them will be canonical.

       Regular serialization

              Atomic Parsing Expressions

                     [1]    The  string epsilon is an atomic parsing expression.
                            It matches the empty string.

                     [2]    The string dot is an atomic parsing  expression.  It
                            matches any character.

                     [3]    The string alnum is an atomic parsing expression. It
                            matches any Unicode  alphabet  or  digit  character.
                            This  is  a  custom  extension of PEs based on Tcl&apos;s
                            builtin command string is.

                     [4]    The string alpha is an atomic parsing expression. It
                            matches  any  Unicode  alphabet character. This is a
                            custom extension of PEs based on Tcl&apos;s builtin  com&#8208;
                            mand string is.

                     [5]    The string ascii is an atomic parsing expression. It
                            matches any Unicode character below U0080. This is a
                            custom  extension of PEs based on Tcl&apos;s builtin com&#8208;
                            mand string is.

                     [6]    The string control is an atomic parsing  expression.
                            It  matches any Unicode control character. This is a
                            custom extension of PEs based on Tcl&apos;s builtin  com&#8208;
                            mand string is.

                     [7]    The string digit is an atomic parsing expression. It
                            matches any Unicode digit character. Note that  this
                            includes  characters  outside  of  the [0..9] range.
                            This is a custom extension of  PEs  based  on  Tcl&apos;s
                            builtin command string is.

                     [8]    The string graph is an atomic parsing expression. It
                            matches any Unicode printing character,  except  for
                            space.  This  is  a custom extension of PEs based on
                            Tcl&apos;s builtin command string is.

                     [9]    The string lower is an atomic parsing expression. It
                            matches  any  Unicode lower-case alphabet character.
                            This is a custom extension of  PEs  based  on  Tcl&apos;s
                            builtin command string is.

                     [10]   The string print is an atomic parsing expression. It
                            matches any Unicode  printing  character,  including
                            space.  This  is  a custom extension of PEs based on
                            Tcl&apos;s builtin command string is.

                     [11]   The string punct is an atomic parsing expression. It
                            matches any Unicode punctuation character. This is a
                            custom extension of PEs based on Tcl&apos;s builtin  com&#8208;
                            mand string is.

                     [12]   The string space is an atomic parsing expression. It
                            matches any Unicode space character. This is a  cus&#8208;
                            tom  extension of PEs based on Tcl&apos;s builtin command
                            string is.

                     [13]   The string upper is an atomic parsing expression. It
                            matches  any  Unicode upper-case alphabet character.
                            This is a custom extension of  PEs  based  on  Tcl&apos;s
                            builtin command string is.

                     [14]   The string wordchar is an atomic parsing expression.
                            It matches any Unicode word character. This  is  any
                            alphanumeric  character (see alnum), and any connec&#8208;
                            tor punctuation characters (e.g.  underscore).  This
                            is  a custom extension of PEs based on Tcl&apos;s builtin
                            command string is.

                     [15]   The string xdigit is an atomic  parsing  expression.
                            It  matches any hexadecimal digit character. This is
                            a custom extension of PEs  based  on  Tcl&apos;s  builtin
                            command string is.

                     [16]   The  string  ddigit is an atomic parsing expression.
                            It matches any decimal digit character.  This  is  a
                            custom  extension of PEs based on Tcl&apos;s builtin com&#8208;
                            mand regexp.

                     [17]   The expression [list  t  x]  is  an  atomic  parsing
                            expression. It matches the terminal string x.

                     [18]   The  expression  [list  n  A]  is  an atomic parsing
                            expression. It matches the nonterminal A.

              Combined Parsing Expressions

                     [1]    For parsing expressions e1, e2, ...  the  result  of
                            [list / e1 e2 ... ] is a parsing expression as well.
                            This is the ordered choice, aka prioritized choice.

                     [2]    For parsing expressions e1, e2, ...  the  result  of
                            [list x e1 e2 ... ] is a parsing expression as well.
                            This is the sequence.

                     [3]    For a parsing expression e the result of [list *  e]
                            is a parsing expression as well.  This is the kleene
                            closure, describing zero or more repetitions.

                     [4]    For a parsing expression e the result of [list +  e]
                            is  a parsing expression as well.  This is the posi&#8208;
                            tive kleene closure, describing one or more  repeti&#8208;
                            tions.

                     [5]    For  a parsing expression e the result of [list &amp; e]
                            is a parsing expression as well.  This  is  the  and
                            lookahead predicate.

                     [6]    For  a parsing expression e the result of [list ! e]
                            is a parsing expression as well.  This  is  the  not
                            lookahead predicate.

                     [7]    For  a parsing expression e the result of [list ? e]
                            is a  parsing  expression  as  well.   This  is  the
                            optional input.

       Canonical serialization
              The canonical serialization of a parsing expression has the format
              as specified in the previous item, and then additionally satisfies
              the constraints below, which make it unique among all the possible
              serializations of this parsing expression.

              [1]    The string representation of the  value  is  the  canonical
                     representation of a pure Tcl list. I.e. it does not contain
                     superfluous whitespace.

              [2]    Terminals are not encoded as ranges (where start and end of
                     the range are identical).

   EXAMPLE
       Assuming the parsing expression shown on the right-hand side of the rule

                  Expression &lt;- Term (AddOp Term)*


       then its canonical serialization (except for whitespace) is

                  {x {n Term} {* {x {n AddOp} {n Term}}}}


BUGS, IDEAS, FEEDBACK
       This  document,  and  the  package it describes, will undoubtedly contain
       bugs and other problems.  Please report such in the category  pt  of  the
       Tcllib   SF   Trackers  [http://sourceforge.net/tracker/?group_id=12883].
       Please also report any ideas for enhancements you  may  have  for  either
       package and/or documentation.

KEYWORDS
       EBNF, LL(k), PEG, TDPL, context-free languages, export, expression, gram&#8208;
       mar, matching, parser, parsing expression,  parsing  expression  grammar,
       plugin,  push  down  automaton,  recursive descent, serialization, state,
       top-down parsing languages, transducer

CATEGORY
       Parsing and Grammars

COPYRIGHT
       Copyright (c) 2009 Andreas Kupries &lt;andreas_kupries@users.sourceforge.net&gt;




pt                                      1             pt::peg::export::peg(3tcl)

</pre></body></html>
