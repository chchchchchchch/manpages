<html>
<head><meta charset=utf-8/>
<title>pt::peg_language - PEG Language Tutorial</title></head>
<body><pre>

pt::peg_language(3tcl)            Parser Tools            pt::peg_language(3tcl)



________________________________________________________________________________

NAME
       pt::peg_language - PEG Language Tutorial

SYNOPSIS
       package require Tcl  8.5

_________________________________________________________________

DESCRIPTION
       Are  you  lost  ?   Do you have trouble understanding this document ?  In
       that case please read the overview provided by the Introduction to Parser
       Tools.  This  document  is the entrypoint to the whole system the current
       package is a part of.

       Welcome to the tutorial / introduction for  the  PEG  Specification  Lan&#8208;
       guage.   If  you  are  already familiar with the language we are about to
       discuss, and only wish to refresh your memory you can,  of  course,  skip
       ahead  to the aforementioned section and just read the full formal speci&#8208;
       fication.

WHAT IS IT?
       peg, a language for the specification of parsing expression  grammars  is
       meant  to  be  human readable, and writable as well, yet strict enough to
       allow its processing by machine.  Like  any  computer  language.  It  was
       defined  to  make  writing the specification of a grammar easy, something
       the other formats found in the Parser Tools do not lend themselves too.

THE ELEMENTS OF THE LANGUAGE
   BASIC STRUCTURE
       The general outline of a textual PEG is


              PEG &lt;&lt;name&gt;&gt; (&lt;&lt;start-expression&gt;&gt;)
                 &lt;&lt;rules&gt;&gt;
              END;

       Note: We are using text in double  angle-brackets  as  place-holders  for
       things not yet explained.

   NAMES
       Names are mostly used to identify the nonterminal symbols of the grammar,
       i.e. that which occurs on the left-hand side of a &lt;rule&gt;.  The  exception
       to  that  is the name given after the keyword PEG (see previous section),
       which is the name of the whole grammar itself.

       The structure of a name is simple:

       [1]    It begins with a letter, underscore, or colon, followed by

       [2]    zero or more letters, digits, underscores, or colons.

       Or, in formal textual notation:


                  ([_:] / &lt;alpha&gt;) ([_:] / &lt;alnum&gt;)*

       Examples of names:


                  Hello
                  ::world
                  _:submarine55_

       Examples of text which are not names:


                  12
                  .bogus
                  0wrong
                  @location


   RULES
       The main body of the text of a grammar specification is taken up  by  the
       rules.  Each  rule defines the sentence structure of one nonterminal sym&#8208;
       bol. Their basic structure is


                   &lt;&lt;name&gt;&gt;  &lt;-  &lt;&lt;expression&gt;&gt; ;

       The &lt;name&gt; specifies the nonterminal symbol to be defined,  the  &lt;expres&#8208;
       sion&gt; after the arrow (&lt;-) then declares its structure.

       Note  that each rule ends in a single semicolon, even the last.  I.e. the
       semicolon is a rule terminator, not a separator.

       We can have as many rules as we like, as long as we define each nontermi&#8208;
       nal  symbol at most once, and have at least one rule for each nonterminal
       symbol which occured in an expression, i.e. in either the  start  expres&#8208;
       sion of the grammar, or the right-hande side of a rule.

   EXPRESSIONS
       The  parsing  expressions are the meat of any specification. They declare
       the structure of the whole document (&lt;&lt;start-expression&gt;&gt;),  and  of  all
       nonterminal symbols.

       All  expressions are made up out of atomic expressions and operators com&#8208;
       bining them. We have operators for choosing between alternatives, repeti&#8208;
       tion of parts, and for look-ahead constraints. There is no explicit oper&#8208;
       ator for the sequencing (also known as concatenation) of  parts  however.
       This is specified by simply placing the parts adjacent to each other.

       Here are the operators, from highest to lowest priority (i.e. strength of
       binding):


                  # Binary operators.

                  &lt;&lt;expression-1&gt;&gt;     &lt;&lt;expression-2&gt;&gt;  # sequence. parse 1, then 2.
                  &lt;&lt;expression-1&gt;&gt;  /  &lt;&lt;expression-2&gt;&gt;  # alternative. try to parse 1, and parse 2 if 1 failed to parse.

                  # Prefix operators. Lookahead constraints. Same priority.

                  &amp; &lt;&lt;expression&gt;&gt;  # Parse expression, ok on successful parse.
                  ! &lt;&lt;expression&gt;&gt;  # Ditto, except ok on failure to parse.

                  # Suffix operators. Repetition. Same priority.

                  &lt;&lt;expression&gt;&gt; ?  # Parse expression none, or once (repeat 0 or 1).
                  &lt;&lt;expression&gt;&gt; *  # Parse expression zero or more times.
                  &lt;&lt;expression&gt;&gt; +  # Parse expression one or more times.

                  # Expression nesting

                  ( &lt;&lt;expression&gt;&gt; ) # Put an expression in parens to change its priority.
&#12;       With this we can now deconstruct the formal expression for names given in
       section Names:


                  ([_:] / &lt;alpha&gt;) ([_:] / &lt;alnum&gt;)*

       It is a sequence of two parts,

                  [_:] / &lt;alpha&gt;
       and

                  ([_:] / &lt;alnum&gt;)*
       The  parentheses  around  the  parts  kept their inner alternatives bound
       together against the normally higher priority of the  sequence.  Each  of
       the  two  parts  is  an  alternative,  with  the second part additionally
       repeated zero or more times, leaving us with the three atomic expressions


                  [_:]
                  &lt;alpha&gt;
                  &lt;alnum&gt;

       And atomic expressions are our next topic. They fall into three classes:

       [1]    names, i.e. nonterminal symbols,

       [2]    string literals, and

       [3]    character classes.

       Names we know about already, or see section Names for a refresher.

       String literals are simple. They are delimited by  (i.e.  start  and  end
       with)  either a single or double-apostroph, and in between the delimiters
       we can have any character but the delimiter itself. They can be empty  as
       well. Examples of strings are


                  &apos;&apos;
                  &quot;&quot;
                  &apos;hello&apos;
                  &quot;umbra&quot;
                  &quot;&apos;&quot;
                  &apos;&quot;&apos;

       The  last  two  examples  show  how to place any of the delimiters into a
       string.

       For the last, but not least of our atomic expressions, character classes,
       we  have  a number of predefined classes, shown below, and the ability to
       construct or own. The predefined classes are:


                  &lt;alnum&gt;    # Any unicode alphabet or digit character (string is alnum).
                  &lt;alpha&gt;    # Any unicode alphabet character (string is alpha).
                  &lt;ascii&gt;    # Any unicode character below codepoint 0x80 (string is ascii).
                  &lt;control&gt;  # Any unicode control character (string is control).
                  &lt;ddigit&gt;   # The digit characters [0-9].
                  &lt;digit&gt;    # Any unicode digit character (string is digit).
                  &lt;graph&gt;    # Any unicode printing character, except space (string is graph).
                  &lt;lower&gt;    # Any unicode lower-case alphabet character (string is lower).
                  &lt;print&gt;    # Any unicode printing character, incl. space (string is print).
                  &lt;punct&gt;    # Any unicode punctuation character (string is punct).
                  &lt;space&gt;    # Any unicode space character (string is space).
                  &lt;upper&gt;    # Any unicode upper-case alphabet character (string is upper).
                  &lt;wordchar&gt; # Any unicode word character (string is wordchar).
                  &lt;xdigit&gt;   # The hexadecimal digit characters [0-9a-fA-F].
                  .          # Any character, except end of input.

       And the syntax of custom-defined character classes is


                  [ &lt;&lt;range&gt;&gt;* ]

       where each range is either a single character, or of the form


                 &lt;&lt;character&gt;&gt; - &lt;character&gt;&gt;

       Examples for character classes we have seen already in the course of this
       introduction are


                  [_:]
                  [0-9]
                  [0-9a-fA-F]

       We  are  nearly done with expressions. The only piece left is to tell how
       the characters in character classes and string literals are specified.

       Basically characters in the input stand for themselves, and  in  addition
       to  that we several types of escape syntax to to repesent control charac&#8208;
       ters, or characters outside of the encoding the text is in.

       All the escaped forms are started with a backslash character  (&apos;\&apos;,  uni&#8208;
       code  codepoint 0x5C). This is then followed by a series of octal digits,
       or &apos;u&apos; and hexedecimal digits, or a regular character from  a  fixed  set
       for various control characters. Some examples:


                  \n \r \t \&apos; \&quot; \[ \] \\ #
                  \000 up to \277         # octal escape, all ascii character, leading 0&apos;s can be removed.
                  \u2CA7                  # hexadecimal escape, all unicode characters.
                  #                       # Here 2ca7 &lt;=&gt; Koptic Small Letter Tau


   WHITESPACE AND COMMENTS
       One issue not touched upon so far is whitespace and comments.

       Whitespace is any unicode space character, i.e. anything in the character
       class &lt;space&gt;, and comments.  The  latter  are  sequences  of  characters
       starting with a &apos;#&apos; (hash, unicode codepoint 0x23) and ending at the next
       end-of-line.

       Whitespace can be freely used between all syntactical elements of a gram&#8208;
       mar specification. It cannot be used inside of syntactical elements, like
       names, string literals, predefined character classes, etc.

   NONTERMINAL ATTRIBUTES
       Lastly, a more advanced topic. In the section Rules we gave the structure
       of a rule as


                   &lt;&lt;name&gt;&gt;  &lt;-  &lt;&lt;expression&gt;&gt; ;

       This  is not quite true. It is possible to associate a semantic mode with
       the nonterminal in the rule, by writing it  before  the  name,  separated
       from it by a colon, i.e. writing


                  &lt;&lt;mode&gt;&gt; : &lt;&lt;name&gt;&gt;  &lt;-  &lt;&lt;expression&gt;&gt; ;
&#12;       is  also  allowed. This mode is optional. The known modes and their mean&#8208;
       ings are:

       value  The semantic value of the nonterminal symbol is an abstract syntax
              tree  consisting of a single node node for the nonterminal itself,
              which has the ASTs of the symbol&apos;s right hand side  as  its  chil&#8208;
              dren.

       leaf   The semantic value of the nonterminal symbol is an abstract syntax
              tree consisting of a single node node for the nonterminal, without
              any  children.  Any ASTs generated by the symbol&apos;s right hand side
              are discarded.

       void   The nonterminal has no semantic value. Any ASTs generated  by  the
              symbol&apos;s right hand side are discarded (as well).

       Of  these three modes only leaf and void can be specified directly. value
       is implicitly specified by the absence of a mode before the nonterminal.

       Now, with all the above under our belt it should be possible to not  only
       read,  but understand the formal specification of the text representation
       shown in the next section, written in itself.

PEG SPECIFICATION LANGUAGE
       peg, a language for the specification of parsing expression  grammars  is
       meant  to  be  human readable, and writable as well, yet strict enough to
       allow its processing by machine.  Like  any  computer  language.  It  was
       defined  to  make  writing the specification of a grammar easy, something
       the other formats found in the Parser Tools do not lend themselves too.

       It is formally specified by the grammar shown below, written  in  itself.
       For  a tutorial / introduction to the language please go and read the PEG
       Language Tutorial.

              PEG pe-grammar-for-peg (Grammar)

                # --------------------------------------------------------------------
                      # Syntactical constructs

                      Grammar         &lt;- WHITESPACE Header Definition* Final EOF ;

                      Header          &lt;- PEG Identifier StartExpr ;
                      Definition      &lt;- Attribute? Identifier IS Expression SEMICOLON ;
                      Attribute       &lt;- (VOID / LEAF) COLON ;
                      Expression      &lt;- Sequence (SLASH Sequence)* ;
                      Sequence        &lt;- Prefix+ ;
                      Prefix          &lt;- (AND / NOT)? Suffix ;
                      Suffix          &lt;- Primary (QUESTION / STAR / PLUS)? ;
                      Primary         &lt;- ALNUM / ALPHA / ASCII / CONTROL / DDIGIT / DIGIT
                                      /  GRAPH / LOWER / PRINTABLE / PUNCT / SPACE / UPPER
                                      /  WORDCHAR / XDIGIT
                                      / Identifier
                                      /  OPEN Expression CLOSE
                                      /  Literal
                                      /  Class
                                      /  DOT
                                      ;
                      Literal         &lt;- APOSTROPH  (!APOSTROPH  Char)* APOSTROPH  WHITESPACE
                                      /  DAPOSTROPH (!DAPOSTROPH Char)* DAPOSTROPH WHITESPACE ;
                      Class           &lt;- OPENB (!CLOSEB Range)* CLOSEB WHITESPACE ;
                      Range           &lt;- Char TO Char / Char ;

                      StartExpr       &lt;- OPEN Expression CLOSE ;
              void:   Final           &lt;- END SEMICOLON WHITESPACE ;

                      # --------------------------------------------------------------------
                      # Lexing constructs

                      Identifier      &lt;- Ident WHITESPACE ;
              leaf:   Ident           &lt;- (&apos;_&apos; / &apos;:&apos; / &lt;alpha&gt;) (&apos;_&apos; / &apos;:&apos; / &lt;alnum&gt;)* ;
                      Char            &lt;- CharSpecial / CharOctalFull / CharOctalPart
                                      /  CharUnicode / CharUnescaped
                                      ;

              leaf:   CharSpecial     &lt;- &quot;\\&quot; [nrt&apos;&quot;\[\]\\] ;
              leaf:   CharOctalFull   &lt;- &quot;\\&quot; [0-2][0-7][0-7] ;
              leaf:   CharOctalPart   &lt;- &quot;\\&quot; [0-7][0-7]? ;
              leaf:   CharUnicode     &lt;- &quot;\\&quot; &apos;u&apos; HexDigit (HexDigit (HexDigit HexDigit?)?)? ;
              leaf:   CharUnescaped   &lt;- !&quot;\\&quot; . ;

              void:   HexDigit        &lt;- [0-9a-fA-F] ;

              void:   TO              &lt;- &apos;-&apos;           ;
              void:   OPENB           &lt;- &quot;[&quot;           ;
              void:   CLOSEB          &lt;- &quot;]&quot;           ;
              void:   APOSTROPH       &lt;- &quot;&apos;&quot;           ;
              void:   DAPOSTROPH      &lt;- &apos;&quot;&apos;           ;
              void:   PEG             &lt;- &quot;PEG&quot;   WHITESPACE ;
              void:   IS              &lt;- &quot;&lt;-&quot;    WHITESPACE ;
              leaf:   VOID            &lt;- &quot;void&quot;  WHITESPACE ; # Implies that definition has no semantic value.
              leaf:   LEAF            &lt;- &quot;leaf&quot;  WHITESPACE ; # Implies that definition has no terminals.
              void:   END             &lt;- &quot;END&quot;   WHITESPACE ;
              void:   SEMICOLON       &lt;- &quot;;&quot;     WHITESPACE ;
              void:   COLON           &lt;- &quot;:&quot;     WHITESPACE ;
              void:   SLASH           &lt;- &quot;/&quot;     WHITESPACE ;
              leaf:   AND             &lt;- &quot;&amp;&quot;     WHITESPACE ;
              leaf:   NOT             &lt;- &quot;!&quot;     WHITESPACE ;
              leaf:   QUESTION        &lt;- &quot;?&quot;     WHITESPACE ;
              leaf:   STAR            &lt;- &quot;*&quot;     WHITESPACE ;
              leaf:   PLUS            &lt;- &quot;+&quot;     WHITESPACE ;
              void:   OPEN            &lt;- &quot;(&quot;     WHITESPACE ;
              void:   CLOSE           &lt;- &quot;)&quot;     WHITESPACE ;
              leaf:   DOT             &lt;- &quot;.&quot;     WHITESPACE ;

              leaf:   ALNUM           &lt;- &quot;&lt;alnum&gt;&quot;    WHITESPACE ;
              leaf:   ALPHA           &lt;- &quot;&lt;alpha&gt;&quot;    WHITESPACE ;
              leaf:   ASCII           &lt;- &quot;&lt;ascii&gt;&quot;    WHITESPACE ;
              leaf:   CONTROL         &lt;- &quot;&lt;control&gt;&quot;  WHITESPACE ;
              leaf:   DDIGIT          &lt;- &quot;&lt;ddigit&gt;&quot;   WHITESPACE ;
              leaf:   DIGIT           &lt;- &quot;&lt;digit&gt;&quot;    WHITESPACE ;
              leaf:   GRAPH           &lt;- &quot;&lt;graph&gt;&quot;    WHITESPACE ;
              leaf:   LOWER           &lt;- &quot;&lt;lower&gt;&quot;    WHITESPACE ;
              leaf:   PRINTABLE       &lt;- &quot;&lt;print&gt;&quot;    WHITESPACE ;
              leaf:   PUNCT           &lt;- &quot;&lt;punct&gt;&quot;    WHITESPACE ;
              leaf:   SPACE           &lt;- &quot;&lt;space&gt;&quot;    WHITESPACE ;
              leaf:   UPPER           &lt;- &quot;&lt;upper&gt;&quot;    WHITESPACE ;
              leaf:   WORDCHAR        &lt;- &quot;&lt;wordchar&gt;&quot; WHITESPACE ;
              leaf:   XDIGIT          &lt;- &quot;&lt;xdigit&gt;&quot;   WHITESPACE ;

              void:   WHITESPACE      &lt;- (&quot; &quot; / &quot;\t&quot; / EOL / COMMENT)* ;
              void:   COMMENT         &lt;- &apos;#&apos; (!EOL .)* EOL ;
              void:   EOL             &lt;- &quot;\n\r&quot; / &quot;\n&quot; / &quot;\r&quot; ;
              void:   EOF             &lt;- !. ;

                      # --------------------------------------------------------------------
              END;


   EXAMPLE
       Our example specifies the grammar for a basic 4-operation calculator.

              PEG calculator (Expression)
                  Digit      &lt;- &apos;0&apos;/&apos;1&apos;/&apos;2&apos;/&apos;3&apos;/&apos;4&apos;/&apos;5&apos;/&apos;6&apos;/&apos;7&apos;/&apos;8&apos;/&apos;9&apos;       ;
                  Sign       &lt;- &apos;-&apos; / &apos;+&apos;                                     ;
                  Number     &lt;- Sign? Digit+                                  ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- &apos;*&apos; / &apos;/&apos;                                     ;
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- &apos;+&apos;/&apos;-&apos;                                       ;
                  Factor     &lt;- &apos;(&apos; Expression &apos;)&apos; / Number                   ;
              END;


       Using higher-level features of the notation, i.e. the  character  classes
       (predefined and custom), this example can be rewritten as

              PEG calculator (Expression)
                  Sign       &lt;- [-+] ;
                  Number     &lt;- Sign? &lt;ddigit&gt;+;
                  Expression &lt;- &apos;(&apos; Expression &apos;)&apos; / (Factor (MulOp Factor)*);
                  MulOp      &lt;- [*/];
                  Factor     &lt;- Term (AddOp Term)*;
                  AddOp      &lt;- [-+];
                  Term       &lt;- Number;
              END;


BUGS, IDEAS, FEEDBACK
       This  document,  and  the  package it describes, will undoubtedly contain
       bugs and other problems.  Please report such in the category  pt  of  the
       Tcllib   SF   Trackers  [http://sourceforge.net/tracker/?group_id=12883].
       Please also report any ideas for enhancements you  may  have  for  either
       package and/or documentation.

KEYWORDS
       EBNF,  LL(k),  PEG,  TDPL,  context-free  languages, expression, grammar,
       matching, parser, parsing expression, parsing  expression  grammar,  push
       down  automaton,  recursive  descent,  state, top-down parsing languages,
       transducer

CATEGORY
       Parsing and Grammars

COPYRIGHT
       Copyright (c) 2009 Andreas Kupries &lt;andreas_kupries@users.sourceforge.net&gt;




pt                                      1                 pt::peg_language(3tcl)

</pre></body></html>
