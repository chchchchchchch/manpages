<html>
<head><meta charset=utf-8/>
<title>pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancellation clean-up handlers</title></head>
<body><pre>

PTHREAD_CLEANUP_PUSH(3)     Linux Programmer&apos;s Manual    PTHREAD_CLEANUP_PUSH(3)



NAME
       pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancella&#8208;
       tion clean-up handlers

SYNOPSIS
       #include &lt;pthread.h&gt;

       void pthread_cleanup_push(void (*routine)(void *),
                                 void *arg);
       void pthread_cleanup_pop(int execute);

       Compile and link with -pthread.

DESCRIPTION
       These functions manipulate the calling thread&apos;s stack of thread-cancella&#8208;
       tion  clean-up  handlers.  A clean-up handler is a function that is auto&#8208;
       matically executed when a thread is canceled (or in various other circum&#8208;
       stances  described  below); it might, for example, unlock a mutex so that
       it becomes available to other threads in the process.

       The pthread_cleanup_push() function pushes routine onto the  top  of  the
       stack  of  clean-up  handlers.  When routine is later invoked, it will be
       given arg as its argument.

       The pthread_cleanup_pop() function removes the routine at the top of  the
       stack  of  clean-up  handlers,  and  optionally executes it if execute is
       nonzero.

       A cancellation clean-up handler is popped from the stack and executed  in
       the following circumstances:

       1. When  a  thread  is canceled, all of the stacked clean-up handlers are
          popped and executed in the reverse of the order  in  which  they  were
          pushed onto the stack.

       2. When a thread terminates by calling pthread_exit(3), all clean-up han&#8208;
          dlers are executed as described in  the  preceding  point.   (Clean-up
          handlers  are  not  called  if  the  thread terminates by performing a
          return from the thread start function.)

       3. When a thread calls pthread_cleanup_pop() with a nonzero execute argu&#8208;
          ment, the top-most clean-up handler is popped and executed.

       POSIX.1  permits  pthread_cleanup_push()  and pthread_cleanup_pop() to be
       implemented as macros that expand to text containing &apos;{&apos; and &apos;}&apos;, respec&#8208;
       tively.   For  this  reason,  the  caller must ensure that calls to these
       functions are paired within the same function, and at  the  same  lexical
       nesting  level.   (In other words, a clean-up handler is only established
       during the execution of a specified section of code.)

       Calling longjmp(3) (siglongjmp(3)) produces undefined results if any call
       has  been made to pthread_cleanup_push() or pthread_cleanup_pop() without
       the matching call of the  pair  since  the  jump  buffer  was  filled  by
       setjmp(3)  (sigsetjmp(3)).   Likewise, calling longjmp(3) (siglongjmp(3))
       from inside a clean-up handler produces undefined results unless the jump
       buffer was also filled by setjmp(3) (sigsetjmp(3)) inside the handler.

RETURN VALUE
       These functions do not return a value.

ERRORS
       There are no errors.
&#12;CONFORMING TO
       POSIX.1-2001.

NOTES
       On  Linux, the pthread_cleanup_push() and pthread_cleanup_pop() functions
       are implemented as macros that expand to text  containing  &apos;{&apos;  and  &apos;}&apos;,
       respectively.   This  means  that  variables declared within the scope of
       paired calls to these functions will only be visible within that scope.

       POSIX.1 says that the effect of using return, break, continue, or goto to
       prematurely   leave   a   block   bracketed   pthread_cleanup_push()  and
       pthread_cleanup_pop() is undefined.  Portable applications  should  avoid
       doing this.

EXAMPLE
       The  program  below provides a simple example of the use of the functions
       described in this page.  The program creates a  thread  that  executes  a
       loop bracketed by pthread_cleanup_push() and pthread_cleanup_pop().  This
       loop increments a global variable, cnt, once each second.   Depending  on
       what command-line arguments are supplied, the main thread sends the other
       thread a cancellation request, or sets a global variable that causes  the
       other thread to exit its loop and terminate normally (by doing a return).

       In  the  following  shell  session,  the main thread sends a cancellation
       request to the other thread:

           $ ./a.out
           New thread started
           cnt = 0
           cnt = 1
           Canceling thread
           Called clean-up handler
           Thread was canceled; cnt = 0

       From the above, we see that the thread was canceled, and that the cancel&#8208;
       lation  clean-up  handler was called and it reset the value of the global
       variable cnt to 0.

       In the next run, the main program sets  a  global  variable  that  causes
       other thread to terminate normally:

           $ ./a.out x
           New thread started
           cnt = 0
           cnt = 1
           Thread terminated normally; cnt = 2

       From  the  above,  we  see  that  the  clean-up  handler was not executed
       (because cleanup_pop_arg was 0), and therefore the value of cnt  was  not
       reset.

       In  the next run, the main program sets a global variable that causes the
       other thread to terminate normally, and  supplies  a  nonzero  value  for
       cleanup_pop_arg:

           $ ./a.out x 1
           New thread started
           cnt = 0
           cnt = 1
           Called clean-up handler
           Thread terminated normally; cnt = 0

       In  the  above,  we  see  that  although the thread was not canceled, the
       clean-up  handler  was  executed,   because   the   argument   given   to
       pthread_cleanup_pop() was nonzero.

   Program source

       #include &lt;pthread.h&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;stdio.h&gt;
       #include &lt;stdlib.h&gt;
       #include &lt;unistd.h&gt;
       #include &lt;errno.h&gt;

       #define handle_error_en(en, msg) \
               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

       static int done = 0;
       static int cleanup_pop_arg = 0;
       static int cnt = 0;

       static void
       cleanup_handler(void *arg)
       {
           printf(&quot;Called clean-up handler\n&quot;);
           cnt = 0;
       }

       static void *
       thread_start(void *arg)
       {
           time_t start, curr;

           printf(&quot;New thread started\n&quot;);

           pthread_cleanup_push(cleanup_handler, NULL);

           curr = start = time(NULL);

           while (!done) {
               pthread_testcancel();           /* A cancellation point */
               if (curr &lt; time(NULL)) {
                   curr = time(NULL);
                   printf(&quot;cnt = %d\n&quot;, cnt);  /* A cancellation point */
                   cnt++;
               }
           }

           pthread_cleanup_pop(cleanup_pop_arg);
           return NULL;
       }

       int
       main(int argc, char *argv[])
       {
           pthread_t thr;
           int s;
           void *res;

           s = pthread_create(&amp;thr, NULL, thread_start, NULL);
           if (s != 0)
               handle_error_en(s, &quot;pthread_create&quot;);

           sleep(2);           /* Allow new thread to run a while */

           if (argc &gt; 1) {
               if (argc &gt; 2)
                   cleanup_pop_arg = atoi(argv[2]);
               done = 1;

           } else {
               printf(&quot;Canceling thread\n&quot;);
               s = pthread_cancel(thr);
               if (s != 0)
                   handle_error_en(s, &quot;pthread_cancel&quot;);
           }
&#12;           s = pthread_join(thr, &amp;res);
           if (s != 0)
               handle_error_en(s, &quot;pthread_join&quot;);

           if (res == PTHREAD_CANCELED)
               printf(&quot;Thread was canceled; cnt = %d\n&quot;, cnt);
           else
               printf(&quot;Thread terminated normally; cnt = %d\n&quot;, cnt);
           exit(EXIT_SUCCESS);
       }

SEE ALSO
       pthread_cancel(3),  pthread_cleanup_push_defer_np(3),  pthread_setcancel&#8208;
       state(3), pthread_testcancel(3), pthreads(7)

COLOPHON
       This page is part of release 3.44 of  the  Linux  man-pages  project.   A
       description  of the project, and information about reporting bugs, can be
       found at http://www.kernel.org/doc/man-pages/.



Linux                              2008-11-24            PTHREAD_CLEANUP_PUSH(3)

</pre></body></html>
