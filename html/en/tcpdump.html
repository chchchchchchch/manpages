<html>
<head><meta charset=utf-8/>
<title>tcpdump - dump traffic on a network</title></head>
<body><pre>

TCPDUMP(8)                                                            TCPDUMP(8)



NAME
       tcpdump - dump traffic on a network

SYNOPSIS
       tcpdump [ -AbdDefhHIJKlLnNOpqRStuUvxX ] [ -B buffer_size ] [ -c count ]
               [ -C file_size ] [ -G rotate_seconds ] [ -F file ]
               [ -i interface ] [ -j tstamp_type ] [ -m module ] [ -M secret ]
               [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ]
               [ -W filecount ]
               [ -E spi@ipaddr algo:secret,...  ]
               [ -y datalinktype ] [ -z postrotate-command ] [ -Z user ]
               [ expression ]

DESCRIPTION
       Tcpdump  prints out a description of the contents of packets on a network
       interface that match the boolean expression.  It can also be run with the
       -w  flag,  which  causes  it  to save the packet data to a file for later
       analysis, and/or with the -r flag, which causes it to read from  a  saved
       packet file rather than to read packets from a network interface.  In all
       cases, only packets that match expression will be processed by tcpdump.

       Tcpdump will, if not run with the -c  flag,  continue  capturing  packets
       until  it  is  interrupted by a SIGINT signal (generated, for example, by
       typing your interrupt character, typically control-C) or a SIGTERM signal
       (typically  generated with the kill(1) command); if run with the -c flag,
       it will capture packets until it is interrupted by a  SIGINT  or  SIGTERM
       signal or the specified number of packets have been processed.

       When tcpdump finishes capturing packets, it will report counts of:

              packets  ``captured&apos;&apos;  (this is the number of packets that tcpdump
              has received and processed);

              packets ``received by filter&apos;&apos; (the meaning of this depends on the
              OS on which you&apos;re running tcpdump, and possibly on the way the OS
              was configured - if a filter was specified on the command line, on
              some  OSes  it  counts  packets  regardless  of  whether they were
              matched by the filter expression and, even if they were matched by
              the  filter expression, regardless of whether tcpdump has read and
              processed them yet, on other OSes it counts only packets that were
              matched by the filter expression regardless of whether tcpdump has
              read and processed them yet, and on  other  OSes  it  counts  only
              packets  that  were matched by the filter expression and were pro&#8208;
              cessed by tcpdump);

              packets ``dropped by kernel&apos;&apos; (this is the number of packets  that
              were dropped, due to a lack of buffer space, by the packet capture
              mechanism in the OS on which tcpdump is running, if the OS reports
              that  information  to applications; if not, it will be reported as
              0).

       On platforms that support the SIGINFO signal, such as most BSDs  (includ&#8208;
       ing Mac OS X) and Digital/Tru64 UNIX, it will report those counts when it
       receives a SIGINFO signal (generated, for example, by typing your  ``sta&#8208;
       tus&apos;&apos; character, typically control-T, although on some platforms, such as
       Mac OS X, the ``status&apos;&apos; character is not set by default, so you must set
       it with stty(1) in order to use it) and will continue capturing packets.

       Reading  packets  from a network interface may require that you have spe&#8208;
       cial privileges; see the pcap (3PCAP) man page for  details.   Reading  a
       saved packet file doesn&apos;t require special privileges.
&#12;OPTIONS
       -A     Print  each  packet (minus its link level header) in ASCII.  Handy
              for capturing web pages.

       -b     Print the AS number in BGP packets in ASDOT notation  rather  than
              ASPLAIN notation.

       -B     Set  the  operating  system capture buffer size to buffer_size, in
              units of KiB (1024 bytes).

       -c     Exit after receiving count packets.

       -C     Before writing a raw packet to a savefile, check whether the  file
              is  currently  larger than file_size and, if so, close the current
              savefile and open a new one.  Savefiles after the  first  savefile
              will have the name specified with the -w flag, with a number after
              it, starting at 1 and continuing upward.  The units  of  file_size
              are millions of bytes (1,000,000 bytes, not 1,048,576 bytes).

       -d     Dump the compiled packet-matching code in a human readable form to
              standard output and stop.

       -dd    Dump packet-matching code as a C program fragment.

       -ddd   Dump packet-matching code as  decimal  numbers  (preceded  with  a
              count).

       -D     Print  the  list of the network interfaces available on the system
              and on which tcpdump can capture packets.  For each network inter&#8208;
              face,  a number and an interface name, possibly followed by a text
              description of the interface, is printed.  The interface  name  or
              the  number can be supplied to the -i flag to specify an interface
              on which to capture.

              This can be useful on systems that don&apos;t have a  command  to  list
              them (e.g., Windows systems, or UNIX systems lacking ifconfig -a);
              the number can be useful on Windows 2000 and later systems,  where
              the interface name is a somewhat complex string.

              The  -D  flag  will  not be supported if tcpdump was built with an
              older version of libpcap that lacks the  pcap_findalldevs()  func&#8208;
              tion.

       -e     Print the link-level header on each dump line.

       -E     Use  spi@ipaddr  algo:secret for decrypting IPsec ESP packets that
              are addressed to addr and contain Security Parameter  Index  value
              spi.  This combination may be repeated with comma or newline sepa&#8208;
              ration.

              Note that setting the secret for IPv4 ESP packets is supported  at
              this time.

              Algorithms   may  be  des-cbc,  3des-cbc,  blowfish-cbc,  rc3-cbc,
              cast128-cbc, or none.  The default is  des-cbc.   The  ability  to
              decrypt packets is only present if tcpdump was compiled with cryp&#8208;
              tography enabled.

              secret is the ASCII text for ESP secret key.  If preceded  by  0x,
              then a hex value will be read.

              The  option  assumes  RFC2406 ESP, not RFC1827 ESP.  The option is
              only for debugging purposes, and the use of  this  option  with  a
              true  `secret&apos; key is discouraged.  By presenting IPsec secret key
              onto command line you make it visible to  others,  via  ps(1)  and
              other occasions.

              In  addition to the above syntax, the syntax file name may be used
              to have tcpdump read the provided file in. The file is opened upon
              receiving  the  first  ESP packet, so any special permissions that
              tcpdump may have been given should already have been given up.

       -f     Print `foreign&apos; IPv4 addresses numerically  rather  than  symboli&#8208;
              cally  (this option is intended to get around serious brain damage
              in Sun&apos;s NIS server &#8212; usually it hangs  forever  translating  non-
              local internet numbers).

              The  test  for  `foreign&apos;  IPv4  addresses  is done using the IPv4
              address and netmask of the interface on  which  capture  is  being
              done.   If  that  address or netmask are not available, available,
              either because the interface on which capture is being done has no
              address  or  netmask  or  because the capture is being done on the
              Linux &quot;any&quot; interface, which can capture on more than  one  inter&#8208;
              face, this option will not work correctly.

       -F     Use  file  as  input  for  the  filter  expression.  An additional
              expression given on the command line is ignored.

       -G     If specified, rotates the dump file specified with the  -w  option
              every rotate_seconds seconds.  Savefiles will have the name speci&#8208;
              fied by -w which should include a time format as defined by  strf&#8208;
              time(3).  If no time format is specified, each new file will over&#8208;
              write the previous.

              If used in conjunction with the -C option, filenames will take the
              form of `file&lt;count&gt;&apos;.

       -h     Print  the tcpdump and libpcap version strings, print a usage mes&#8208;
              sage, and exit.

       -H     Attempt to detect 802.11s draft mesh headers.

       -i     Listen on interface.  If unspecified, tcpdump searches the  system
              interface  list  for  the lowest numbered, configured up interface
              (excluding loopback).  Ties are broken by  choosing  the  earliest
              match.

              On  Linux systems with 2.2 or later kernels, an interface argument
              of ``any&apos;&apos; can be used to capture  packets  from  all  interfaces.
              Note  that captures on the ``any&apos;&apos; device will not be done in pro&#8208;
              miscuous mode.

              If the -D flag is supported, an interface  number  as  printed  by
              that flag can be used as the interface argument.

       -I     Put  the  interface  in  &quot;monitor mode&quot;; this is supported only on
              IEEE 802.11 Wi-Fi interfaces, and supported only on some operating
              systems.

              Note  that in monitor mode the adapter might disassociate from the
              network with which it&apos;s associated, so that you will not  be  able
              to  use  any wireless networks with that adapter.  This could pre&#8208;
              vent accessing files on a network server, or resolving host  names
              or network addresses, if you are capturing in monitor mode and are
              not connected to another network with another adapter.

              This flag will affect the output of the  -L  flag.   If  -I  isn&apos;t
              specified, only those link-layer types available when not in moni&#8208;
              tor mode will be shown; if -I is specified, only those  link-layer
              types available when in monitor mode will be shown.

       -j     Set the time stamp type for the capture to tstamp_type.  The names
              to use for the time stamp types are given in  pcap-tstamp-type(7);
              not  all  the types listed there will necessarily be valid for any
              given interface.

       -J     List the supported time stamp types for the  interface  and  exit.
              If  the  time  stamp type cannot be set for the interface, no time
              stamp types are listed.

       -K     Don&apos;t attempt to verify IP, TCP, or UDP checksums.  This is useful
              for interfaces that perform some or all of those checksum calcula&#8208;
              tion in hardware; otherwise, all outgoing TCP  checksums  will  be
              flagged as bad.

       -l     Make  stdout  line  buffered.   Useful if you want to see the data
              while capturing it.  E.g.,

                     tcpdump -l | tee dat

              or

                     tcpdump -l &gt; dat &amp; tail -f dat

              Note that on Windows,``line buffered&apos;&apos;  means  ``unbuffered&apos;&apos;,  so
              that WinDump will write each character individually if -l is spec&#8208;
              ified.

              -U is similar to -l in its behavior, but it will cause  output  to
              be ``packet-buffered&apos;&apos;, so that the output is written to stdout at
              the end of each packet rather than at the end of each  line;  this
              is buffered on all platforms, including Windows.

       -L     List the known data link types for the interface, in the specified
              mode, and exit.  The list of known data link types may  be  depen&#8208;
              dent  on the specified mode; for example, on some platforms, a Wi-
              Fi interface might support one set of data link types when not  in
              monitor  mode  (for  example,  it might support only fake Ethernet
              headers, or might support 802.11 headers but  not  support  802.11
              headers with radio information) and another set of data link types
              when in monitor mode (for example, it might support  802.11  head&#8208;
              ers,  or  802.11  headers  with radio information, only in monitor
              mode).

       -m     Load SMI MIB module definitions from file module.  This option can
              be used several times to load several MIB modules into tcpdump.

       -M     Use  secret as a shared secret for validating the digests found in
              TCP segments with the TCP-MD5 option (RFC 2385), if present.

       -n     Don&apos;t convert addresses (i.e., host addresses, port numbers, etc.)
              to names.

       -N     Don&apos;t print domain name qualification of host names.  E.g., if you
              give  this  flag  then  tcpdump  will  print  ``nic&apos;&apos;  instead  of
              ``nic.ddn.mil&apos;&apos;.

       -O     Do  not  run  the  packet-matching code optimizer.  This is useful
              only if you suspect a bug in the optimizer.

       -p     Don&apos;t put the interface into  promiscuous  mode.   Note  that  the
              interface  might  be  in  promiscuous  mode for some other reason;
              hence, `-p&apos; cannot be used as  an  abbreviation  for  `ether  host
              {local-hw-addr} or ether broadcast&apos;.

       -q     Quick  (quiet?) output.  Print less protocol information so output
              lines are shorter.

       -R     Assume ESP/AH packets to be based on old specification (RFC1825 to
              RFC1829).   If specified, tcpdump will not print replay prevention
              field.  Since there is no protocol version field in ESP/AH  speci&#8208;
              fication, tcpdump cannot deduce the version of ESP/AH protocol.

       -r     Read  packets  from  file  (which was created with the -w option).
              Standard input is used if file is ``-&apos;&apos;.

       -S     Print absolute, rather than relative, TCP sequence numbers.

       -s     Snarf snaplen bytes of data  from  each  packet  rather  than  the
              default  of  65535  bytes.  Packets truncated because of a limited
              snapshot are indicated in  the  output  with  ``[|proto]&apos;&apos;,  where
              proto  is  the  name of the protocol level at which the truncation
              has occurred.  Note that taking larger  snapshots  both  increases
              the  amount  of time it takes to process packets and, effectively,
              decreases the amount of packet buffering.  This may cause  packets
              to  be lost.  You should limit snaplen to the smallest number that
              will capture the protocol information you&apos;re interested in.   Set&#8208;
              ting  snaplen  to 0 sets it to the default of 65535, for backwards
              compatibility with recent older versions of tcpdump.

       -T     Force packets selected by &quot;expression&quot; to be interpreted the spec&#8208;
              ified type.  Currently known types are aodv (Ad-hoc On-demand Dis&#8208;
              tance Vector protocol), cnfp (Cisco NetFlow protocol), rpc (Remote
              Procedure  Call),  rtp  (Real-Time  Applications  protocol),  rtcp
              (Real-Time Applications control protocol),  snmp  (Simple  Network
              Management  Protocol),  tftp (Trivial File Transfer Protocol), vat
              (Visual Audio Tool), and wb (distributed White Board).

       -t     Don&apos;t print a timestamp on each dump line.

       -tt    Print an unformatted timestamp on each dump line.

       -ttt   Print a delta (micro-second resolution) between current and previ&#8208;
              ous line on each dump line.

       -tttt  Print a timestamp in default format proceeded by date on each dump
              line.

       -ttttt Print a delta (micro-second resolution) between current and  first
              line on each dump line.

       -u     Print undecoded NFS handles.

       -U     If  the -w option is not specified, make the printed packet output
              ``packet-buffered&apos;&apos;; i.e., as the description of the  contents  of
              each packet is printed, it will be written to the standard output,
              rather than, when not writing to a terminal,  being  written  only
              when the output buffer fills.

              If  the  -w  option is specified, make the saved raw packet output
              ``packet-buffered&apos;&apos;; i.e., as each packet is  saved,  it  will  be
              written  to  the  output file, rather than being written only when
              the output buffer fills.

              The -U flag will not be supported if tcpdump  was  built  with  an
              older  version  of  libpcap that lacks the pcap_dump_flush() func&#8208;
              tion.

       -v     When parsing and printing, produce (slightly more) verbose output.
              For  example,  the  time to live, identification, total length and
              options in an IP packet  are  printed.   Also  enables  additional
              packet  integrity  checks such as verifying the IP and ICMP header
              checksum.

              When writing to a file with the -w option, report, every  10  sec&#8208;
              onds, the number of packets captured.
&#12;       -vv    Even  more  verbose  output.   For  example, additional fields are
              printed from NFS reply packets, and SMB packets are fully decoded.

       -vvv   Even more verbose output.  For example, telnet SB ...  SE  options
              are printed in full.  With -X Telnet options are printed in hex as
              well.

       -w     Write the raw packets to file rather  than  parsing  and  printing
              them out.  They can later be printed with the -r option.  Standard
              output is used if file is ``-&apos;&apos;.

              This output will be buffered if written to a file or  pipe,  so  a
              program  reading  from the file or pipe may not see packets for an
              arbitrary amount of time after they are received.  Use the -U flag
              to cause packets to be written as soon as they are received.

              See pcap-savefile(5) for a description of the file format.

       -W     Used in conjunction with the -C option, this will limit the number
              of files created to the specified number,  and  begin  overwriting
              files  from  the beginning, thus creating a &apos;rotating&apos; buffer.  In
              addition, it will name the files with enough leading 0s to support
              the maximum number of files, allowing them to sort correctly.

              Used in conjunction with the -G option, this will limit the number
              of rotated dump files that get created, exiting with status 0 when
              reaching  the  limit.  If  used with -C as well, the behavior will
              result in cyclical files per timeslice.

       -x     When parsing and printing, in addition to printing the headers  of
              each  packet,  print the data of each packet (minus its link level
              header) in hex.  The smaller of the entire packet or snaplen bytes
              will  be printed.  Note that this is the entire link-layer packet,
              so for link layers that pad (e.g.  Ethernet),  the  padding  bytes
              will  also be printed when the higher layer packet is shorter than
              the required padding.

       -xx    When parsing and printing, in addition to printing the headers  of
              each  packet,  print  the  data of each packet, including its link
              level header, in hex.

       -X     When parsing and printing, in addition to printing the headers  of
              each  packet,  print the data of each packet (minus its link level
              header) in hex and ASCII.  This is very handy  for  analysing  new
              protocols.

       -XX    When  parsing and printing, in addition to printing the headers of
              each packet, print the data of each  packet,  including  its  link
              level header, in hex and ASCII.

       -y     Set the data link type to use while capturing packets to datalink&#8208;
              type.

       -z     Used in conjunction with the -C or -G options, this will make tcp&#8208;
              dump  run &quot; command file &quot; where file is the savefile being closed
              after each rotation. For example, specifying -z gzip or  -z  bzip2
              will compress each savefile using gzip or bzip2.

              Note that tcpdump will run the command in parallel to the capture,
              using the lowest priority so that this doesn&apos;t disturb the capture
              process.

              And  in  case  you  would  like to use a command that itself takes
              flags or different arguments, you can always write a shell  script
              that  will  take  the savefile name as the only argument, make the
              flags &amp; arguments arrangements and execute the  command  that  you
              want.

       -Z     If tcpdump is running as root, after opening the capture device or
              input savefile, but  before  opening  any  savefiles  for  output,
              change  the  user ID to user and the group ID to the primary group
              of user.

              This behavior can also be enabled by default at compile time.

        expression
              selects which packets will be dumped.  If no expression is  given,
              all  packets  on  the net will be dumped.  Otherwise, only packets
              for which expression is `true&apos; will be dumped.

              For the expression syntax, see pcap-filter(7).

              Expression arguments can be passed to tcpdump as either  a  single
              argument  or  as multiple arguments, whichever is more convenient.
              Generally, if the expression contains Shell metacharacters, it  is
              easier  to  pass  it as a single, quoted argument.  Multiple argu&#8208;
              ments are concatenated with spaces before being parsed.

EXAMPLES
       To print all packets arriving at or departing from sundown:
              tcpdump host sundown

       To print traffic between helios and either hot or ace:
              tcpdump host helios and \( hot or ace \)

       To print all IP packets between ace and any host except helios:
              tcpdump ip host ace and not helios

       To print all traffic between local hosts and hosts at Berkeley:
              tcpdump net ucb-ether

       To print all ftp traffic through internet gateway snup:  (note  that  the
       expression  is  quoted  to  prevent the shell from (mis-)interpreting the
       parentheses):
              tcpdump &apos;gateway snup and (port ftp or ftp-data)&apos;

       To print traffic neither sourced from nor destined for  local  hosts  (if
       you  gateway  to one other net, this stuff should never make it onto your
       local net).
              tcpdump ip and not net localnet

       To print the start and end packets (the SYN and FIN packets) of each  TCP
       conversation that involves a non-local host.
              tcpdump &apos;tcp[tcpflags] &amp; (tcp-syn|tcp-fin) != 0 and not src and dst net localnet&apos;

       To print all IPv4 HTTP packets to and from port 80, i.e. print only pack&#8208;
       ets that contain data, not, for example, SYN and FIN packets and ACK-only
       packets.  (IPv6 is left as an exercise for the reader.)
              tcpdump &apos;tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)&apos;

       To print IP packets longer than 576 bytes sent through gateway snup:
              tcpdump &apos;gateway snup and ip[2:2] &gt; 576&apos;

       To  print IP broadcast or multicast packets that were not sent via Ether&#8208;
       net broadcast or multicast:
              tcpdump &apos;ether[0] &amp; 1 = 0 and ip[16] &gt;= 224&apos;

       To print all ICMP packets that are not echo requests/replies  (i.e.,  not
       ping packets):
              tcpdump &apos;icmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply&apos;

OUTPUT FORMAT
       The output of tcpdump is protocol dependent.  The following gives a brief
       description and examples of most of the formats.

       Link Level Headers

       If the &apos;-e&apos; option is given, the link level header is  printed  out.   On
       Ethernets,  the  source  and  destination addresses, protocol, and packet
       length are printed.

       On FDDI networks, the  &apos;-e&apos; option causes tcpdump  to  print  the  `frame
       control&apos;  field,   the  source  and destination addresses, and the packet
       length.  (The `frame control&apos; field governs  the  interpretation  of  the
       rest  of  the  packet.  Normal packets (such as those containing IP data&#8208;
       grams) are `async&apos; packets, with a priority value between 0  and  7;  for
       example,  `async4&apos;.  Such packets are assumed to contain an 802.2 Logical
       Link Control (LLC) packet; the LLC header is printed if it is not an  ISO
       datagram or a so-called SNAP packet.

       On  Token  Ring  networks,  the  &apos;-e&apos;  option causes tcpdump to print the
       `access control&apos; and `frame control&apos; fields, the source  and  destination
       addresses,  and  the  packet  length.   As  on FDDI networks, packets are
       assumed to contain an LLC packet.  Regardless of whether the &apos;-e&apos;  option
       is  specified  or  not,  the  source  routing  information is printed for
       source-routed packets.

       On 802.11 networks, the &apos;-e&apos; option causes tcpdump to  print  the  `frame
       control&apos;  fields,  all  of  the  addresses  in the 802.11 header, and the
       packet length.  As on FDDI networks, packets are assumed  to  contain  an
       LLC packet.

       (N.B.:  The  following description assumes familiarity with the SLIP com&#8208;
       pression algorithm described in RFC-1144.)

       On SLIP links, a direction indicator (``I&apos;&apos; for inbound, ``O&apos;&apos;  for  out&#8208;
       bound),  packet  type,  and compression information are printed out.  The
       packet type is printed first.  The three types are ip,  utcp,  and  ctcp.
       No  further link information is printed for ip packets.  For TCP packets,
       the connection identifier is printed following the type.  If  the  packet
       is  compressed, its encoded header is printed out.  The special cases are
       printed out as *S+n and *SA+n,  where  n  is  the  amount  by  which  the
       sequence number (or sequence number and ack) has changed.  If it is not a
       special case, zero or more changes are printed.  A change is indicated by
       U  (urgent  pointer),  W  (window),  A  (ack), S (sequence number), and I
       (packet ID), followed by a delta  (+n  or  -n),  or  a  new  value  (=n).
       Finally,  the  amount  of data in the packet and compressed header length
       are printed.

       For example, the following line shows an outbound compressed TCP  packet,
       with  an  implicit  connection  identifier; the ack has changed by 6, the
       sequence number by 49, and the packet ID by 6; there are 3 bytes of  data
       and 6 bytes of compressed header:
              O ctcp * A+6 S+49 I+6 3 (6)

       ARP/RARP Packets

       Arp/rarp  output shows the type of request and its arguments.  The format
       is intended to be self explanatory.  Here is a short  sample  taken  from
       the start of an `rlogin&apos; from host rtsg to host csam:
              arp who-has csam tell rtsg
              arp reply csam is-at CSAM
       The  first line says that rtsg sent an arp packet asking for the Ethernet
       address of internet host csam.  Csam replies with  its  Ethernet  address
       (in  this  example, Ethernet addresses are in caps and internet addresses
       in lower case).

       This would look less redundant if we had done tcpdump -n:
              arp who-has 128.3.254.6 tell 128.3.254.68
              arp reply 128.3.254.6 is-at 02:07:01:00:01:c4
&#12;       If we had done tcpdump -e, the fact that the first  packet  is  broadcast
       and the second is point-to-point would be visible:
              RTSG Broadcast 0806  64: arp who-has csam tell rtsg
              CSAM RTSG 0806  64: arp reply csam is-at CSAM
       For  the  first packet this says the Ethernet source address is RTSG, the
       destination is the Ethernet broadcast address, the type  field  contained
       hex 0806 (type ETHER_ARP) and the total length was 64 bytes.

       TCP Packets

       (N.B.:The following description assumes familiarity with the TCP protocol
       described in RFC-793.  If you are not familiar with the protocol, neither
       this description nor tcpdump will be of much use to you.)

       The general format of a tcp protocol line is:
              src &gt; dst: flags data-seqno ack window urgent options
       Src and dst are the source and destination IP addresses and ports.  Flags
       are some combination of S (SYN), F (FIN), P (PUSH), R (RST), U  (URG),  W
       (ECN  CWR),  E  (ECN-Echo)  or  `.&apos; (ACK), or `none&apos; if no flags are set.
       Data-seqno describes the portion of sequence space covered by the data in
       this packet (see example below).  Ack is sequence number of the next data
       expected the other direction on this connection.  Window is the number of
       bytes  of receive buffer space available the other direction on this con&#8208;
       nection.  Urg indicates there is `urgent&apos; data in  the  packet.   Options
       are tcp options enclosed in angle brackets (e.g., &lt;mss 1024&gt;).

       Src,  dst  and  flags are always present.  The other fields depend on the
       contents of the packet&apos;s tcp protocol  header  and  are  output  only  if
       appropriate.

       Here is the opening portion of an rlogin from host rtsg to host csam.
              rtsg.1023 &gt; csam.login: S 768512:768512(0) win 4096 &lt;mss 1024&gt;
              csam.login &gt; rtsg.1023: S 947648:947648(0) ack 768513 win 4096 &lt;mss 1024&gt;
              rtsg.1023 &gt; csam.login: . ack 1 win 4096
              rtsg.1023 &gt; csam.login: P 1:2(1) ack 1 win 4096
              csam.login &gt; rtsg.1023: . ack 2 win 4096
              rtsg.1023 &gt; csam.login: P 2:21(19) ack 1 win 4096
              csam.login &gt; rtsg.1023: P 1:2(1) ack 21 win 4077
              csam.login &gt; rtsg.1023: P 2:3(1) ack 21 win 4077 urg 1
              csam.login &gt; rtsg.1023: P 3:4(1) ack 21 win 4077 urg 1
       The  first  line  says  that  tcp port 1023 on rtsg sent a packet to port
       login on csam.  The S indicates that the SYN flag was  set.   The  packet
       sequence  number  was  768512 and it contained no data.  (The notation is
       `first:last(nbytes)&apos; which means `sequence numbers first up  to  but  not
       including last which is nbytes bytes of user data&apos;.)  There was no piggy-
       backed ack, the available receive window was 4096 bytes and there  was  a
       max-segment-size option requesting an mss of 1024 bytes.

       Csam  replies with a similar packet except it includes a piggy-backed ack
       for rtsg&apos;s SYN.  Rtsg then acks csam&apos;s SYN.  The `.&apos; means the  ACK  flag
       was  set.  The packet contained no data so there is no data sequence num&#8208;
       ber.  Note that the ack sequence number is  a  small  integer  (1).   The
       first time tcpdump sees a tcp `conversation&apos;, it prints the sequence num&#8208;
       ber from the packet.  On subsequent packets of the conversation, the dif&#8208;
       ference  between  the  current  packet&apos;s sequence number and this initial
       sequence number is printed.  This means that sequence numbers  after  the
       first can be interpreted as relative byte positions in the conversation&apos;s
       data stream (with the first data byte each direction  being  `1&apos;).   `-S&apos;
       will  override  this feature, causing the original sequence numbers to be
       output.

       On the 6th line, rtsg sends csam 19 bytes of data (bytes 2 through 20  in
       the  rtsg  &#8594; csam side of the conversation).  The PUSH flag is set in the
       packet.  On the 7th line, csam says it&apos;s received data sent by rtsg up to
       but  not  including  byte 21.  Most of this data is apparently sitting in
       the socket buffer  since  csam&apos;s  receive  window  has  gotten  19  bytes
       smaller.   Csam  also  sends one byte of data to rtsg in this packet.  On
       the 8th and 9th lines, csam sends two bytes of  urgent,  pushed  data  to
       rtsg.

       If the snapshot was small enough that tcpdump didn&apos;t capture the full TCP
       header, it interprets as much of the header as it can  and  then  reports
       ``[|tcp]&apos;&apos;  to  indicate  the remainder could not be interpreted.  If the
       header contains a bogus option (one with a length that&apos;s either too small
       or beyond the end of the header), tcpdump reports it as ``[bad opt]&apos;&apos; and
       does not interpret any further options (since  it&apos;s  impossible  to  tell
       where  they  start).   If the header length indicates options are present
       but the IP datagram length is not long enough for the options to actually
       be there, tcpdump reports it as ``[bad hdr length]&apos;&apos;.

       Capturing  TCP  packets  with particular flag combinations (SYN-ACK, URG-
       ACK, etc.)

       There are 8 bits in the control bits section of the TCP header:

              CWR | ECE | URG | ACK | PSH | RST | SYN | FIN

       Let&apos;s assume that we want to watch packets used  in  establishing  a  TCP
       connection.  Recall that TCP uses a 3-way handshake protocol when it ini&#8208;
       tializes a new connection; the connection sequence with regard to the TCP
       control bits is

              1) Caller sends SYN
              2) Recipient responds with SYN, ACK
              3) Caller sends ACK

       Now  we&apos;re interested in capturing packets that have only the SYN bit set
       (Step 1).  Note that we don&apos;t want packets from step 2 (SYN-ACK), just  a
       plain  initial SYN.  What we need is a correct filter expression for tcp&#8208;
       dump.

       Recall the structure of a TCP header without options:

        0                            15                              31
       -----------------------------------------------------------------
       |          source port          |       destination port        |
       -----------------------------------------------------------------
       |                        sequence number                        |
       -----------------------------------------------------------------
       |                     acknowledgment number                     |
       -----------------------------------------------------------------
       |  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |
       -----------------------------------------------------------------
       |         TCP checksum          |       urgent pointer          |
       -----------------------------------------------------------------

       A TCP header usually holds 20 octets of data, unless options are present.
       The  first line of the graph contains octets 0 - 3, the second line shows
       octets 4 - 7 etc.

       Starting to count with 0, the relevant TCP control bits are contained  in
       octet 13:

        0             7|             15|             23|             31
       ----------------|---------------|---------------|----------------
       |  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |
       ----------------|---------------|---------------|----------------
       |               |  13th octet   |               |               |

       Let&apos;s have a closer look at octet no. 13:

                       |               |
                       |---------------|
                       |C|E|U|A|P|R|S|F|
                       |---------------|
                       |7   5   3     0|

       These  are  the  TCP control bits we are interested in.  We have numbered
       the bits in this octet from 0 to 7, right to left, so the PSH bit is  bit
       number 3, while the URG bit is number 5.

       Recall that we want to capture packets with only SYN set.  Let&apos;s see what
       happens to octet 13 if a TCP datagram arrives with the SYN bit set in its
       header:

                       |C|E|U|A|P|R|S|F|
                       |---------------|
                       |0 0 0 0 0 0 1 0|
                       |---------------|
                       |7 6 5 4 3 2 1 0|

       Looking  at  the control bits section we see that only bit number 1 (SYN)
       is set.

       Assuming that octet number 13 is an 8-bit  unsigned  integer  in  network
       byte order, the binary value of this octet is

              00000010

       and its decimal representation is

          7     6     5     4     3     2     1     0
       0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 1*2 + 0*2  =  2

       We&apos;re almost done, because now we know that if only SYN is set, the value
       of the 13th octet in the TCP header, when interpreted as a 8-bit unsigned
       integer in network byte order, must be exactly 2.

       This relationship can be expressed as
              tcp[13] == 2

       We  can  use  this expression as the filter for tcpdump in order to watch
       packets which have only SYN set:
              tcpdump -i xl0 tcp[13] == 2

       The expression says &quot;let the 13th octet of a TCP datagram have the  deci&#8208;
       mal value 2&quot;, which is exactly what we want.

       Now,  let&apos;s assume that we need to capture SYN packets, but we don&apos;t care
       if ACK or any other TCP control bit is set at the same time.   Let&apos;s  see
       what happens to octet 13 when a TCP datagram with SYN-ACK set arrives:

            |C|E|U|A|P|R|S|F|
            |---------------|
            |0 0 0 1 0 0 1 0|
            |---------------|
            |7 6 5 4 3 2 1 0|

       Now bits 1 and 4 are set in the 13th octet.  The binary value of octet 13
       is

                   00010010

       which translates to decimal

          7     6     5     4     3     2     1     0
       0*2 + 0*2 + 0*2 + 1*2 + 0*2 + 0*2 + 1*2 + 0*2   = 18

       Now we can&apos;t just use &apos;tcp[13] == 18&apos; in the tcpdump  filter  expression,
       because  that  would select only those packets that have SYN-ACK set, but
       not those with only SYN set.  Remember that we don&apos;t care if ACK  or  any
       other control bit is set as long as SYN is set.

       In  order  to achieve our goal, we need to logically AND the binary value
       of octet 13 with some other value to preserve the SYN bit.  We know  that
       we  want  SYN  to be set in any case, so we&apos;ll logically AND the value in
       the 13th octet with the binary value of a SYN:

                 00010010 SYN-ACK              00000010 SYN
            AND  00000010 (we want SYN)   AND  00000010 (we want SYN)
                 --------                      --------
            =    00000010                 =    00000010

       We see that this  AND  operation  delivers  the  same  result  regardless
       whether  ACK  or another TCP control bit is set.  The decimal representa&#8208;
       tion of the AND value as well as  the  result  of  this  operation  is  2
       (binary 00000010), so we know that for packets with SYN set the following
       relation must hold true:

              ( ( value of octet 13 ) AND ( 2 ) ) == ( 2 )

       This points us to the tcpdump filter expression
                   tcpdump -i xl0 &apos;tcp[13] &amp; 2 == 2&apos;

       Some offsets and field values may be expressed as names  rather  than  as
       numeric  values.  For example tcp[13] may be replaced with tcp[tcpflags].
       The following TCP flag field values are also available: tcp-fin, tcp-syn,
       tcp-rst, tcp-push, tcp-act, tcp-urg.

       This can be demonstrated as:
                   tcpdump -i xl0 &apos;tcp[tcpflags] &amp; tcp-push != 0&apos;

       Note  that  you should use single quotes or a backslash in the expression
       to hide the AND (&apos;&amp;&apos;) special character from the shell.

       UDP Packets

       UDP format is illustrated by this rwho packet:
              actinide.who &gt; broadcast.who: udp 84
       This says that port who on host actinide sent a udp datagram to port  who
       on  host broadcast, the Internet broadcast address.  The packet contained
       84 bytes of user data.

       Some UDP services are recognized (from the  source  or  destination  port
       number)  and  the higher level protocol information printed.  In particu&#8208;
       lar, Domain Name service  requests  (RFC-1034/1035)  and  Sun  RPC  calls
       (RFC-1050) to NFS.

       UDP Name Server Requests

       (N.B.:The  following description assumes familiarity with the Domain Ser&#8208;
       vice protocol described in RFC-1035.  If you are not  familiar  with  the
       protocol, the following description will appear to be written in greek.)

       Name server requests are formatted as
              src &gt; dst: id op? flags qtype qclass name (len)
              h2opolo.1538 &gt; helios.domain: 3+ A? ucbvax.berkeley.edu. (37)
       Host  h2opolo  asked  the  domain  server on helios for an address record
       (qtype=A) associated with the name ucbvax.berkeley.edu.  The query id was
       `3&apos;.   The  `+&apos;  indicates the recursion desired flag was set.  The query
       length was 37 bytes, not including the UDP and IP protocol headers.   The
       query  operation  was the normal one, Query, so the op field was omitted.
       If the op had been anything else, it would have been printed between  the
       `3&apos;  and  the  `+&apos;.   Similarly, the qclass was the normal one, C_IN, and
       omitted.  Any other qclass would have been printed immediately after  the
       `A&apos;.

       A  few  anomalies  are checked and may result in extra fields enclosed in
       square brackets:  If a query contains an  answer,  authority  records  or
       additional  records  section, ancount, nscount, or arcount are printed as
       `[na]&apos;, `[nn]&apos; or  `[nau]&apos; where n is the appropriate count.  If  any  of
       the  response bits are set (AA, RA or rcode) or any of the `must be zero&apos;
       bits are set in bytes two and three, `[b2&amp;3=x]&apos; is printed,  where  x  is
       the hex value of header bytes two and three.

       UDP Name Server Responses

       Name server responses are formatted as
              src &gt; dst:  id op rcode flags a/n/au type class data (len)
              helios.domain &gt; h2opolo.1538: 3 3/3/7 A 128.32.137.3 (273)
              helios.domain &gt; h2opolo.1537: 2 NXDomain* 0/1/0 (97)
       In  the  first example, helios responds to query id 3 from h2opolo with 3
       answer records, 3 name server records  and  7  additional  records.   The
       first  answer record is type A (address) and its data is internet address
       128.32.137.3.  The total size of the response was  273  bytes,  excluding
       UDP  and  IP  headers.   The  op (Query) and response code (NoError) were
       omitted, as was the class (C_IN) of the A record.

       In the second example, helios responds to query 2 with a response code of
       non-existent  domain  (NXDomain)  with no answers, one name server and no
       authority records.  The `*&apos; indicates that the authoritative  answer  bit
       was  set.   Since  there  were  no  answers,  no type, class or data were
       printed.

       Other flag characters that might appear are `-&apos; (recursion available, RA,
       not set) and `|&apos; (truncated message, TC, set).  If the `question&apos; section
       doesn&apos;t contain exactly one entry, `[nq]&apos; is printed.

       SMB/CIFS decoding

       tcpdump now includes fairly extensive SMB/CIFS/NBT decoding for  data  on
       UDP/137, UDP/138 and TCP/139.  Some primitive decoding of IPX and NetBEUI
       SMB data is also done.

       By default a fairly minimal decode is done, with  a  much  more  detailed
       decode  done  if  -v is used.  Be warned that with -v a single SMB packet
       may take up a page or more, so only use -v if you  really  want  all  the
       gory details.

       For  information  on  SMB packet formats and what all the fields mean see
       www.cifs.org or the pub/samba/specs/ directory on your favorite samba.org
       mirror   site.    The   SMB  patches  were  written  by  Andrew  Tridgell
       (tridge@samba.org).

       NFS Requests and Replies

       Sun NFS (Network File System) requests and replies are printed as:
              src.xid &gt; dst.nfs: len op args
              src.nfs &gt; dst.xid: reply stat len op results
              sushi.6709 &gt; wrl.nfs: 112 readlink fh 21,24/10.73165
              wrl.nfs &gt; sushi.6709: reply ok 40 readlink &quot;../var&quot;
              sushi.201b &gt; wrl.nfs:
                   144 lookup fh 9,74/4096.6878 &quot;xcolors&quot;
              wrl.nfs &gt; sushi.201b:
                   reply ok 128 lookup fh 9,74/4134.3150
       In the first line, host sushi sends a transaction with  id  6709  to  wrl
       (note that the number following the src host is a transaction id, not the
       source port).  The request was 112 bytes, excluding the UDP and IP  head&#8208;
       ers.   The  operation  was a readlink (read symbolic link) on file handle
       (fh) 21,24/10.731657119.  (If one is lucky, as in  this  case,  the  file
       handle  can  be interpreted as a major,minor device number pair, followed
       by the inode number and generation number.)  Wrl replies  `ok&apos;  with  the
       contents of the link.

       In  the third line, sushi asks wrl to lookup the name `xcolors&apos; in direc&#8208;
       tory file 9,74/4096.6878.  Note that the  data  printed  depends  on  the
       operation type.  The format is intended to be self explanatory if read in
       conjunction with an NFS protocol spec.

       If the -v (verbose) flag is given,  additional  information  is  printed.
       For example:
              sushi.1372a &gt; wrl.nfs:
                   148 read fh 21,11/12.195 8192 bytes @ 24576
              wrl.nfs &gt; sushi.1372a:
                   reply ok 1472 read REG 100664 ids 417/0 sz 29388
       (-v  also prints the IP header TTL, ID, length, and fragmentation fields,
       which have been omitted from this example.)  In  the  first  line,  sushi
       asks wrl to read 8192 bytes from file 21,11/12.195, at byte offset 24576.
       Wrl replies `ok&apos;; the packet shown on the second line is the first  frag&#8208;
       ment  of  the  reply,  and hence is only 1472 bytes long (the other bytes
       will follow in subsequent fragments, but these fragments do not have  NFS
       or  even UDP headers and so might not be printed, depending on the filter
       expression used).  Because the  -v  flag  is  given,  some  of  the  file
       attributes (which are returned in addition to the file data) are printed:
       the file type (``REG&apos;&apos;, for regular file), the file mode (in octal),  the
       uid and gid, and the file size.

       If the -v flag is given more than once, even more details are printed.

       Note  that  NFS  requests  are very large and much of the detail won&apos;t be
       printed unless snaplen is increased.  Try using `-s  192&apos;  to  watch  NFS
       traffic.

       NFS reply packets do not explicitly identify the RPC operation.  Instead,
       tcpdump keeps track of ``recent&apos;&apos;  requests,  and  matches  them  to  the
       replies using the transaction ID.  If a reply does not closely follow the
       corresponding request, it might not be parsable.

       AFS Requests and Replies

       Transarc AFS (Andrew File System) requests and replies are printed as:

              src.sport &gt; dst.dport: rx packet-type
              src.sport &gt; dst.dport: rx packet-type service call call-name args
              src.sport &gt; dst.dport: rx packet-type service reply call-name args
              elvis.7001 &gt; pike.afsfs:
                   rx data fs call rename old fid 536876964/1/1 &quot;.newsrc.new&quot;
                   new fid 536876964/1/1 &quot;.newsrc&quot;
              pike.afsfs &gt; elvis.7001: rx data fs reply rename
       In the first line, host elvis sends a RX packet to pike.  This was  a  RX
       data  packet  to  the fs (fileserver) service, and is the start of an RPC
       call.  The RPC call was a rename, with  the  old  directory  file  id  of
       536876964/1/1  and  an old filename of `.newsrc.new&apos;, and a new directory
       file id of 536876964/1/1 and a new filename of `.newsrc&apos;.  The host  pike
       responds  with  a  RPC  reply  to  the rename call (which was successful,
       because it was a data packet and not an abort packet).

       In general, all AFS RPCs are decoded at least by RPC call name.  Most AFS
       RPCs  have  at  least  some  of the arguments decoded (generally only the
       `interesting&apos; arguments, for some definition of interesting).

       The format is intended to be self-describing, but it will probably not be
       useful to people who are not familiar with the workings of AFS and RX.

       If  the  -v  (verbose)  flag  is given twice, acknowledgement packets and
       additional header information is printed, such as the  the  RX  call  ID,
       call number, sequence number, serial number, and the RX packet flags.

       If the -v flag is given twice, additional information is printed, such as
       the the RX call ID, serial number, and the  RX  packet  flags.   The  MTU
       negotiation information is also printed from RX ack packets.
&#12;       If  the  -v  flag is given three times, the security index and service id
       are printed.

       Error codes are printed for abort packets, with  the  exception  of  Ubik
       beacon  packets (because abort packets are used to signify a yes vote for
       the Ubik protocol).

       Note that AFS requests are very large and many of the arguments won&apos;t  be
       printed  unless  snaplen  is  increased.  Try using `-s 256&apos; to watch AFS
       traffic.

       AFS reply packets do not explicitly identify the RPC operation.  Instead,
       tcpdump  keeps  track  of  ``recent&apos;&apos;  requests,  and matches them to the
       replies using the call number and  service  ID.   If  a  reply  does  not
       closely follow the corresponding request, it might not be parsable.


       KIP AppleTalk (DDP in UDP)

       AppleTalk  DDP  packets encapsulated in UDP datagrams are de-encapsulated
       and dumped as DDP packets (i.e., all the UDP header information  is  dis&#8208;
       carded).   The  file  /etc/atalk.names is used to translate AppleTalk net
       and node numbers to names.  Lines in this file have the form
              number    name

              1.254          ether
              16.1      icsd-net
              1.254.110 ace
       The first two lines give the names of AppleTalk networks.  The third line
       gives  the  name of a particular host (a host is distinguished from a net
       by the 3rd octet in the number - a net number must have two octets and  a
       host number must have three octets.)  The number and name should be sepa&#8208;
       rated by whitespace (blanks or tabs).  The /etc/atalk.names file may con&#8208;
       tain blank lines or comment lines (lines starting with a `#&apos;).

       AppleTalk addresses are printed in the form
              net.host.port

              144.1.209.2 &gt; icsd-net.112.220
              office.2 &gt; icsd-net.112.220
              jssmag.149.235 &gt; icsd-net.2
       (If  the  /etc/atalk.names  doesn&apos;t exist or doesn&apos;t contain an entry for
       some AppleTalk host/net number, addresses are printed in  numeric  form.)
       In  the  first example, NBP (DDP port 2) on net 144.1 node 209 is sending
       to whatever is listening on port 220 of net icsd node  112.   The  second
       line  is  the  same  except  the  full  name  of the source node is known
       (`office&apos;).  The third line is a send from port 235 on  net  jssmag  node
       149  to  broadcast  on  the  icsd-net  NBP  port (note that the broadcast
       address (255) is indicated by a net name with no host number -  for  this
       reason  it&apos;s  a  good  idea  to keep node names and net names distinct in
       /etc/atalk.names).

       NBP (name binding protocol)  and  ATP  (AppleTalk  transaction  protocol)
       packets  have  their contents interpreted.  Other protocols just dump the
       protocol name (or number if no name is registered for the  protocol)  and
       packet size.

       NBP packets are formatted like the following examples:
              icsd-net.112.220 &gt; jssmag.2: nbp-lkup 190: &quot;=:LaserWriter@*&quot;
              jssmag.209.2 &gt; icsd-net.112.220: nbp-reply 190: &quot;RM1140:LaserWriter@*&quot; 250
              techpit.2 &gt; icsd-net.112.220: nbp-reply 190: &quot;techpit:LaserWriter@*&quot; 186
       The first line is a name lookup request for laserwriters sent by net icsd
       host 112 and broadcast on net jssmag.  The nbp id for the lookup is  190.
       The second line shows a reply for this request (note that it has the same
       id) from host jssmag.209 saying that it has a laserwriter resource  named
       &quot;RM1140&quot;  registered on port 250.  The third line is another reply to the
       same request saying host techpit has laserwriter &quot;techpit&quot; registered  on
       port 186.

       ATP packet formatting is demonstrated by the following example:
              jssmag.209.165 &gt; helios.132: atp-req  12266&lt;0-7&gt; 0xae030001
              helios.132 &gt; jssmag.209.165: atp-resp 12266:0 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:1 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:2 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:4 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:6 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp*12266:7 (512) 0xae040000
              jssmag.209.165 &gt; helios.132: atp-req  12266&lt;3,5&gt; 0xae030001
              helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000
              jssmag.209.165 &gt; helios.132: atp-rel  12266&lt;0-7&gt; 0xae030001
              jssmag.209.133 &gt; helios.132: atp-req* 12267&lt;0-7&gt; 0xae030002
       Jssmag.209  initiates transaction id 12266 with host helios by requesting
       up to 8 packets (the `&lt;0-7&gt;&apos;).  The hex number at the end of the line  is
       the value of the `userdata&apos; field in the request.

       Helios  responds  with  8  512-byte  packets.  The `:digit&apos; following the
       transaction id gives the packet sequence number in  the  transaction  and
       the  number  in parens is the amount of data in the packet, excluding the
       atp header.  The `*&apos; on packet 7 indicates that the EOM bit was set.

       Jssmag.209 then requests that packets 3 &amp;  5  be  retransmitted.   Helios
       resends  them  then  jssmag.209  releases the transaction.  Finally, jss&#8208;
       mag.209 initiates the next request.  The `*&apos;  on  the  request  indicates
       that XO (`exactly once&apos;) was not set.


       IP Fragmentation

       Fragmented Internet datagrams are printed as
              (frag id:size@offset+)
              (frag id:size@offset)
       (The first form indicates there are more fragments.  The second indicates
       this is the last fragment.)

       Id is the fragment id.  Size is the fragment size  (in  bytes)  excluding
       the IP header.  Offset is this fragment&apos;s offset (in bytes) in the origi&#8208;
       nal datagram.

       The fragment information is output for each fragment.  The first fragment
       contains  the  higher  level protocol header and the frag info is printed
       after the protocol info.  Fragments after the  first  contain  no  higher
       level  protocol  header and the frag info is printed after the source and
       destination addresses.  For example, here is part of  an  ftp  from  ari&#8208;
       zona.edu  to lbl-rtsg.arpa over a CSNET connection that doesn&apos;t appear to
       handle 576 byte datagrams:
              arizona.ftp-data &gt; rtsg.1170: . 1024:1332(308) ack 1 win 4096 (frag 595a:328@0+)
              arizona &gt; rtsg: (frag 595a:204@328)
              rtsg.1170 &gt; arizona.ftp-data: . ack 1536 win 2560
       There are a couple of things to note here:  First, addresses in  the  2nd
       line don&apos;t include port numbers.  This is because the TCP protocol infor&#8208;
       mation is all in the first fragment and we have no idea what the port  or
       sequence  numbers are when we print the later fragments.  Second, the tcp
       sequence information in the first line is printed as if  there  were  308
       bytes  of  user data when, in fact, there are 512 bytes (308 in the first
       frag and 204 in the second).   If  you  are  looking  for  holes  in  the
       sequence  space  or  trying  to match up acks with packets, this can fool
       you.

       A packet with the IP don&apos;t fragment flag is marked with a trailing (DF).

       Timestamps

       By default, all output lines are preceded by a timestamp.  The  timestamp
       is the current clock time in the form
              hh:mm:ss.frac
       and  is  as  accurate  as the kernel&apos;s clock.  The timestamp reflects the
       time the kernel first saw the packet.  No attempt is made to account  for
       the  time lag between when the Ethernet interface removed the packet from
       the wire and when the kernel serviced the `new packet&apos; interrupt.

SEE ALSO
       stty(1), pcap(3PCAP), bpf(4), nit(4P), pcap-savefile(5),  pcap-filter(7),
       pcap-tstamp-type(7)

AUTHORS
       The original authors are:

       Van  Jacobson, Craig Leres and Steven McCanne, all of the Lawrence Berke&#8208;
       ley National Laboratory, University of California, Berkeley, CA.

       It is currently being maintained by tcpdump.org.

       The current version is available via http:

              http://www.tcpdump.org/

       The original distribution is available via anonymous ftp:

              ftp://ftp.ee.lbl.gov/tcpdump.tar.Z

       IPv6/IPsec support is added by WIDE/KAME project.  This program uses Eric
       Young&apos;s SSLeay library, under specific configurations.

BUGS
       Please  send  problems,  bugs, questions, desirable enhancements, patches
       etc. to:

              tcpdump-workers@lists.tcpdump.org

       NIT doesn&apos;t let you watch your own outbound traffic, BPF will.  We recom&#8208;
       mend that you use the latter.

       On Linux systems with 2.0[.x] kernels:

              packets on the loopback device will be seen twice;

              packet filtering cannot be done in the kernel, so that all packets
              must be copied from the kernel in order to  be  filtered  in  user
              mode;

              all  of  a  packet,  not  just the part that&apos;s within the snapshot
              length, will be copied from the kernel (the 2.0[.x] packet capture
              mechanism,  if  asked  to  copy only part of a packet to userland,
              will not report the true length of the packet;  this  would  cause
              most IP packets to get an error from tcpdump);

              capturing on some PPP devices won&apos;t work correctly.

       We recommend that you upgrade to a 2.2 or later kernel.

       Some  attempt  should  be made to reassemble IP fragments or, at least to
       compute the right length for the higher level protocol.

       Name server inverse queries are not dumped correctly: the  (empty)  ques&#8208;
       tion  section  is  printed  rather than real query in the answer section.
       Some believe that inverse queries are themselves a bug and prefer to  fix
       the program generating them rather than tcpdump.
&#12;       A  packet  trace  that  crosses  a daylight savings time change will give
       skewed time stamps (the time change is ignored).

       Filter expressions on fields other than those in Token Ring headers  will
       not correctly handle source-routed Token Ring packets.

       Filter  expressions on fields other than those in 802.11 headers will not
       correctly handle 802.11 data packets with both To DS and From DS set.

       ip6 proto should chase header chain, but at this moment it does not.  ip6
       protochain is supplied for this behavior.

       Arithmetic  expression against transport layer headers, like tcp[0], does
       not work against IPv6 packets.  It only looks at IPv4 packets.



                                  05 March 2009                       TCPDUMP(8)

</pre></body></html>
